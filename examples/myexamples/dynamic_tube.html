<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - geometry - cube</title>
		<meta charset="utf-8" />
		<meta
			name="viewport"
			content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0"
		/>
		<link type="text/css" rel="stylesheet" href="../main.css" />
	</head>
	<body>
		<script type="module">
			import * as THREE from "../../build/three.module.js";
			import { OrbitControls } from "../jsm/controls/OrbitControls.js";
			import { SceneUtils } from "../jsm/utils/SceneUtils.js";

			import { GLTFLoader } from "../jsm/loaders/GLTFLoader.js";
			import { RGBELoader } from "../jsm/loaders/RGBELoader.js";
			import { FBXLoader } from "../jsm/loaders/FBXLoader.js";
			import { RoughnessMipmapper } from "../jsm/utils/RoughnessMipmapper.js";

			let camera, scene, renderer;
			let mesh;

			init();
			animate();

			const modelMeshes = [];

			function init() {
				camera = new THREE.PerspectiveCamera(
					70,
					window.innerWidth / window.innerHeight,
					1,
					1000
				);
				camera.position.z = 50;

				scene = new THREE.Scene();

				scene.background = new THREE.Color(0x777777);

				scene.add(new THREE.AmbientLight(0xffffff, 2));

				const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
				scene.add(directionalLight);

				const pathArr = [
					-43.26, 92.049, 48.325, -43.26, 0, 48.325, -5, 0, 48.325, -5, 0, -65,
					-5, -93, -65,
				];

				const arrowTexture = new THREE.TextureLoader().load(
					"../textures/arrow.png"
				);
				arrowTexture.offset.x = 0;
				arrowTexture.offset.y = 0.5;
				arrowTexture.repeat.x = 10;
				arrowTexture.repeat.y = 4;
				arrowTexture.wrapS = THREE.RepeatWrapping;
				arrowTexture.wrapT = THREE.RepeatWrapping;
				setInterval(() => {
					arrowTexture.offset.x -= 0.00076;
				});
				mesh = createTube(pathArr, arrowTexture);
				scene.add(mesh);

				renderer = new THREE.WebGLRenderer({ antialias: true });
				renderer.setPixelRatio(window.devicePixelRatio);
				renderer.setSize(window.innerWidth, window.innerHeight);
				document.body.appendChild(renderer.domElement);

				const controls = new OrbitControls(camera, renderer.domElement);

				// 读取模型

				const loader = new GLTFLoader().setPath("../models/gltf/Tube/");
				const models = ["loose.glb"];

				models.forEach((model, i) => {
					loader.load(model, function (gltf) {
						gltf.scene.traverse(function (child) {
							if (child.type === "LineSegments") {
								const mesh = createTube(
									child.geometry.attributes.position.array,
									arrowTexture,
									0.1
								);
								scene.add(mesh);
							}
							if (child.isMesh) {
								// modelMeshes.push(child);
								// if (child.name === "tube") {
								// child.material = createDynamicMaterial();
								// const mesh = child.clone();
								// mesh.name = child.name + "_copy";
								// mesh.position.y = 5;
								// scene.add(mesh);
								// scene.add(new THREE.BoxHelper(child));
								// }
							}
						});

						scene.add(gltf.scene);
					});
				});

				window.addEventListener("resize", onWindowResize);
			}

			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize(window.innerWidth, window.innerHeight);
			}

			function animate() {
				requestAnimationFrame(animate);

				renderer.render(scene, camera);
			}

			// 动态创建一个管道
			function createTube(pathArr, texture = null, radius = 10) {
				let curveArr = [];
				for (let i = 0; i < pathArr.length; i += 3) {
					curveArr.push(
						new THREE.Vector3(pathArr[i], pathArr[i + 1], pathArr[i + 2])
					);
				}
				const curve = new THREE.CatmullRomCurve3(curveArr);

				const tubeGeometry = new THREE.TubeGeometry(
					curve,
					100,
					radius,
					50,
					false
				);

				const basicMaterial = new THREE.MeshBasicMaterial({
					color: 0x001155,
					side: THREE.DoubleSide,
					transparent: true,
					opacity: 0.5,
				});

				const tubeMaterial = createDynamicMaterial(texture);

				// 多材质
				const tube = SceneUtils.createMultiMaterialObject(tubeGeometry, [
					basicMaterial,
					tubeMaterial,
				]);
				return tube;
			}

			function createDynamicMaterial(texture = undefined) {
				// 数据纹理
				const width = 2;
				const height = 1;

				const size = width * height;
				const data = new Uint8Array(4 * size);
				const colors = [
					[255, 255, 255, 255],
					[0, 0, 0, 0],
				];

				for (let i = 0; i < size; i++) {
					const stride = i * 4;
					const color = colors[i];
					data[stride] = color[0];
					data[stride + 1] = color[1];
					data[stride + 2] = color[2];
					data[stride + 3] = color[3];
				}

				// used the buffer to create a DataTexture

				if (!texture) {
					texture = new THREE.DataTexture(
						data,
						width,
						height,
						THREE.RGBAFormat
					);

					texture.needsUpdate = true;

					// 设置阵列模式 RepeatWrapping
					texture.wrapS = THREE.ClampToEdgeWrapping;
					texture.wrapT = THREE.RepeatWrapping;
					texture.repeat.x = 1;
					texture.repeat.y = 1;
					// 设置x方向的重复数(沿着管道路径方向)
					// 设置y方向的重复数(环绕管道方向)
					texture.offset.x = 0.5;
					texture.offset.y = 0;

					setInterval(() => {
						texture.offset.x -= 0.001;
						if (texture.offset.x < -0.5) {
							texture.offset.x = 0.5;
						}
					});
				}

				const tubeMaterial = new THREE.MeshPhongMaterial({
					map: texture,
					transparent: true,
					color: new THREE.Color(0x00ffff),
					side: THREE.DoubleSide,
				});

				return tubeMaterial;
			}
		</script>
	</body>
</html>
