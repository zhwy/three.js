/**
 * @license
 * Copyright 2010-2021 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.THREE = {}));
}(this, (function (exports) { 'use strict';

	var REVISION = '133';
	var MOUSE = {
		LEFT: 0,
		MIDDLE: 1,
		RIGHT: 2,
		ROTATE: 0,
		DOLLY: 1,
		PAN: 2
	};
	var TOUCH = {
		ROTATE: 0,
		PAN: 1,
		DOLLY_PAN: 2,
		DOLLY_ROTATE: 3
	};
	var CullFaceNone = 0;
	var CullFaceBack = 1;
	var CullFaceFront = 2;
	var CullFaceFrontBack = 3;
	var BasicShadowMap = 0;
	var PCFShadowMap = 1;
	var PCFSoftShadowMap = 2;
	var VSMShadowMap = 3;
	var FrontSide = 0;
	var BackSide = 1;
	var DoubleSide = 2;
	var FlatShading = 1;
	var SmoothShading = 2;
	var NoBlending = 0;
	var NormalBlending = 1;
	var AdditiveBlending = 2;
	var SubtractiveBlending = 3;
	var MultiplyBlending = 4;
	var CustomBlending = 5;
	var AddEquation = 100;
	var SubtractEquation = 101;
	var ReverseSubtractEquation = 102;
	var MinEquation = 103;
	var MaxEquation = 104;
	var ZeroFactor = 200;
	var OneFactor = 201;
	var SrcColorFactor = 202;
	var OneMinusSrcColorFactor = 203;
	var SrcAlphaFactor = 204;
	var OneMinusSrcAlphaFactor = 205;
	var DstAlphaFactor = 206;
	var OneMinusDstAlphaFactor = 207;
	var DstColorFactor = 208;
	var OneMinusDstColorFactor = 209;
	var SrcAlphaSaturateFactor = 210;
	var NeverDepth = 0;
	var AlwaysDepth = 1;
	var LessDepth = 2;
	var LessEqualDepth = 3;
	var EqualDepth = 4;
	var GreaterEqualDepth = 5;
	var GreaterDepth = 6;
	var NotEqualDepth = 7;
	var MultiplyOperation = 0;
	var MixOperation = 1;
	var AddOperation = 2;
	var NoToneMapping = 0;
	var LinearToneMapping = 1;
	var ReinhardToneMapping = 2;
	var CineonToneMapping = 3;
	var ACESFilmicToneMapping = 4;
	var CustomToneMapping = 5;
	var UVMapping = 300;
	var CubeReflectionMapping = 301;
	var CubeRefractionMapping = 302;
	var EquirectangularReflectionMapping = 303;
	var EquirectangularRefractionMapping = 304;
	var CubeUVReflectionMapping = 306;
	var CubeUVRefractionMapping = 307;
	var RepeatWrapping = 1000;
	var ClampToEdgeWrapping = 1001;
	var MirroredRepeatWrapping = 1002;
	var NearestFilter = 1003;
	var NearestMipmapNearestFilter = 1004;
	var NearestMipMapNearestFilter = 1004;
	var NearestMipmapLinearFilter = 1005;
	var NearestMipMapLinearFilter = 1005;
	var LinearFilter = 1006;
	var LinearMipmapNearestFilter = 1007;
	var LinearMipMapNearestFilter = 1007;
	var LinearMipmapLinearFilter = 1008;
	var LinearMipMapLinearFilter = 1008;
	var UnsignedByteType = 1009;
	var ByteType = 1010;
	var ShortType = 1011;
	var UnsignedShortType = 1012;
	var IntType = 1013;
	var UnsignedIntType = 1014;
	var FloatType = 1015;
	var HalfFloatType = 1016;
	var UnsignedShort4444Type = 1017;
	var UnsignedShort5551Type = 1018;
	var UnsignedShort565Type = 1019;
	var UnsignedInt248Type = 1020;
	var AlphaFormat = 1021;
	var RGBFormat = 1022;
	var RGBAFormat = 1023;
	var LuminanceFormat = 1024;
	var LuminanceAlphaFormat = 1025;
	var RGBEFormat = RGBAFormat;
	var DepthFormat = 1026;
	var DepthStencilFormat = 1027;
	var RedFormat = 1028;
	var RedIntegerFormat = 1029;
	var RGFormat = 1030;
	var RGIntegerFormat = 1031;
	var RGBIntegerFormat = 1032;
	var RGBAIntegerFormat = 1033;
	var RGB_S3TC_DXT1_Format = 33776;
	var RGBA_S3TC_DXT1_Format = 33777;
	var RGBA_S3TC_DXT3_Format = 33778;
	var RGBA_S3TC_DXT5_Format = 33779;
	var RGB_PVRTC_4BPPV1_Format = 35840;
	var RGB_PVRTC_2BPPV1_Format = 35841;
	var RGBA_PVRTC_4BPPV1_Format = 35842;
	var RGBA_PVRTC_2BPPV1_Format = 35843;
	var RGB_ETC1_Format = 36196;
	var RGB_ETC2_Format = 37492;
	var RGBA_ETC2_EAC_Format = 37496;
	var RGBA_ASTC_4x4_Format = 37808;
	var RGBA_ASTC_5x4_Format = 37809;
	var RGBA_ASTC_5x5_Format = 37810;
	var RGBA_ASTC_6x5_Format = 37811;
	var RGBA_ASTC_6x6_Format = 37812;
	var RGBA_ASTC_8x5_Format = 37813;
	var RGBA_ASTC_8x6_Format = 37814;
	var RGBA_ASTC_8x8_Format = 37815;
	var RGBA_ASTC_10x5_Format = 37816;
	var RGBA_ASTC_10x6_Format = 37817;
	var RGBA_ASTC_10x8_Format = 37818;
	var RGBA_ASTC_10x10_Format = 37819;
	var RGBA_ASTC_12x10_Format = 37820;
	var RGBA_ASTC_12x12_Format = 37821;
	var RGBA_BPTC_Format = 36492;
	var SRGB8_ALPHA8_ASTC_4x4_Format = 37840;
	var SRGB8_ALPHA8_ASTC_5x4_Format = 37841;
	var SRGB8_ALPHA8_ASTC_5x5_Format = 37842;
	var SRGB8_ALPHA8_ASTC_6x5_Format = 37843;
	var SRGB8_ALPHA8_ASTC_6x6_Format = 37844;
	var SRGB8_ALPHA8_ASTC_8x5_Format = 37845;
	var SRGB8_ALPHA8_ASTC_8x6_Format = 37846;
	var SRGB8_ALPHA8_ASTC_8x8_Format = 37847;
	var SRGB8_ALPHA8_ASTC_10x5_Format = 37848;
	var SRGB8_ALPHA8_ASTC_10x6_Format = 37849;
	var SRGB8_ALPHA8_ASTC_10x8_Format = 37850;
	var SRGB8_ALPHA8_ASTC_10x10_Format = 37851;
	var SRGB8_ALPHA8_ASTC_12x10_Format = 37852;
	var SRGB8_ALPHA8_ASTC_12x12_Format = 37853;
	var LoopOnce = 2200;
	var LoopRepeat = 2201;
	var LoopPingPong = 2202;
	var InterpolateDiscrete = 2300;
	var InterpolateLinear = 2301;
	var InterpolateSmooth = 2302;
	var ZeroCurvatureEnding = 2400;
	var ZeroSlopeEnding = 2401;
	var WrapAroundEnding = 2402;
	var NormalAnimationBlendMode = 2500;
	var AdditiveAnimationBlendMode = 2501;
	var TrianglesDrawMode = 0;
	var TriangleStripDrawMode = 1;
	var TriangleFanDrawMode = 2;
	var LinearEncoding = 3000;
	var sRGBEncoding = 3001;
	var GammaEncoding = 3007;
	var RGBEEncoding = 3002;
	var LogLuvEncoding = 3003;
	var RGBM7Encoding = 3004;
	var RGBM16Encoding = 3005;
	var RGBDEncoding = 3006;
	var BasicDepthPacking = 3200;
	var RGBADepthPacking = 3201;
	var TangentSpaceNormalMap = 0;
	var ObjectSpaceNormalMap = 1;
	var ZeroStencilOp = 0;
	var KeepStencilOp = 7680;
	var ReplaceStencilOp = 7681;
	var IncrementStencilOp = 7682;
	var DecrementStencilOp = 7683;
	var IncrementWrapStencilOp = 34055;
	var DecrementWrapStencilOp = 34056;
	var InvertStencilOp = 5386;
	var NeverStencilFunc = 512;
	var LessStencilFunc = 513;
	var EqualStencilFunc = 514;
	var LessEqualStencilFunc = 515;
	var GreaterStencilFunc = 516;
	var NotEqualStencilFunc = 517;
	var GreaterEqualStencilFunc = 518;
	var AlwaysStencilFunc = 519;
	var StaticDrawUsage = 35044;
	var DynamicDrawUsage = 35048;
	var StreamDrawUsage = 35040;
	var StaticReadUsage = 35045;
	var DynamicReadUsage = 35049;
	var StreamReadUsage = 35041;
	var StaticCopyUsage = 35046;
	var DynamicCopyUsage = 35050;
	var StreamCopyUsage = 35042;
	var GLSL1 = '100';
	var GLSL3 = '300 es';

	function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
		try {
			var info = gen[key](arg);
			var value = info.value;
		} catch (error) {
			reject(error);
			return;
		}

		if (info.done) {
			resolve(value);
		} else {
			Promise.resolve(value).then(_next, _throw);
		}
	}

	function _asyncToGenerator(fn) {
		return function () {
			var self = this,
					args = arguments;
			return new Promise(function (resolve, reject) {
				var gen = fn.apply(self, args);

				function _next(value) {
					asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
				}

				function _throw(err) {
					asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
				}

				_next(undefined);
			});
		};
	}

	function _defineProperties(target, props) {
		for (var i = 0; i < props.length; i++) {
			var descriptor = props[i];
			descriptor.enumerable = descriptor.enumerable || false;
			descriptor.configurable = true;
			if ("value" in descriptor) descriptor.writable = true;
			Object.defineProperty(target, descriptor.key, descriptor);
		}
	}

	function _createClass(Constructor, protoProps, staticProps) {
		if (protoProps) _defineProperties(Constructor.prototype, protoProps);
		if (staticProps) _defineProperties(Constructor, staticProps);
		return Constructor;
	}

	function _extends() {
		_extends = Object.assign || function (target) {
			for (var i = 1; i < arguments.length; i++) {
				var source = arguments[i];

				for (var key in source) {
					if (Object.prototype.hasOwnProperty.call(source, key)) {
						target[key] = source[key];
					}
				}
			}

			return target;
		};

		return _extends.apply(this, arguments);
	}

	function _inheritsLoose(subClass, superClass) {
		subClass.prototype = Object.create(superClass.prototype);
		subClass.prototype.constructor = subClass;
		subClass.__proto__ = superClass;
	}

	function _assertThisInitialized(self) {
		if (self === void 0) {
			throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
		}

		return self;
	}

	function _unsupportedIterableToArray(o, minLen) {
		if (!o) return;
		if (typeof o === "string") return _arrayLikeToArray(o, minLen);
		var n = Object.prototype.toString.call(o).slice(8, -1);
		if (n === "Object" && o.constructor) n = o.constructor.name;
		if (n === "Map" || n === "Set") return Array.from(o);
		if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
	}

	function _arrayLikeToArray(arr, len) {
		if (len == null || len > arr.length) len = arr.length;

		for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

		return arr2;
	}

	function _createForOfIteratorHelperLoose(o, allowArrayLike) {
		var it;

		if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
			if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
				if (it) o = it;
				var i = 0;
				return function () {
					if (i >= o.length) return {
						done: true
					};
					return {
						done: false,
						value: o[i++]
					};
				};
			}

			throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
		}

		it = o[Symbol.iterator]();
		return it.next.bind(it);
	}

	/**
	 * https://github.com/mrdoob/eventdispatcher.js/
	 */
	var EventDispatcher = /*#__PURE__*/function () {
		function EventDispatcher() {}

		var _proto = EventDispatcher.prototype;

		_proto.addEventListener = function addEventListener(type, listener) {
			if (this._listeners === undefined) this._listeners = {};
			var listeners = this._listeners;

			if (listeners[type] === undefined) {
				listeners[type] = [];
			}

			if (listeners[type].indexOf(listener) === -1) {
				listeners[type].push(listener);
			}
		};

		_proto.hasEventListener = function hasEventListener(type, listener) {
			if (this._listeners === undefined) return false;
			var listeners = this._listeners;
			return listeners[type] !== undefined && listeners[type].indexOf(listener) !== -1;
		};

		_proto.removeEventListener = function removeEventListener(type, listener) {
			if (this._listeners === undefined) return;
			var listeners = this._listeners;
			var listenerArray = listeners[type];

			if (listenerArray !== undefined) {
				var index = listenerArray.indexOf(listener);

				if (index !== -1) {
					listenerArray.splice(index, 1);
				}
			}
		};

		_proto.dispatchEvent = function dispatchEvent(event) {
			if (this._listeners === undefined) return;
			var listeners = this._listeners;
			var listenerArray = listeners[event.type];

			if (listenerArray !== undefined) {
				event.target = this; // Make a copy, in case listeners are removed while iterating.

				var array = listenerArray.slice(0);

				for (var i = 0, l = array.length; i < l; i++) {
					array[i].call(this, event);
				}

				event.target = null;
			}
		};

		return EventDispatcher;
	}();

	var _seed = 1234567;
	var DEG2RAD = Math.PI / 180;
	var RAD2DEG = 180 / Math.PI; //

	var _lut = [];

	for (var i = 0; i < 256; i++) {
		_lut[i] = (i < 16 ? '0' : '') + i.toString(16);
	}

	var hasRandomUUID = typeof crypto !== 'undefined' && 'randomUUID' in crypto;

	function generateUUID() {
		if (hasRandomUUID) {
			return crypto.randomUUID().toUpperCase();
		} // TODO Remove this code when crypto.randomUUID() is available everywhere
		// http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136


		var d0 = Math.random() * 0xffffffff | 0;
		var d1 = Math.random() * 0xffffffff | 0;
		var d2 = Math.random() * 0xffffffff | 0;
		var d3 = Math.random() * 0xffffffff | 0;
		var uuid = _lut[d0 & 0xff] + _lut[d0 >> 8 & 0xff] + _lut[d0 >> 16 & 0xff] + _lut[d0 >> 24 & 0xff] + '-' + _lut[d1 & 0xff] + _lut[d1 >> 8 & 0xff] + '-' + _lut[d1 >> 16 & 0x0f | 0x40] + _lut[d1 >> 24 & 0xff] + '-' + _lut[d2 & 0x3f | 0x80] + _lut[d2 >> 8 & 0xff] + '-' + _lut[d2 >> 16 & 0xff] + _lut[d2 >> 24 & 0xff] + _lut[d3 & 0xff] + _lut[d3 >> 8 & 0xff] + _lut[d3 >> 16 & 0xff] + _lut[d3 >> 24 & 0xff]; // .toUpperCase() here flattens concatenated strings to save heap memory space.

		return uuid.toUpperCase();
	}

	function clamp(value, min, max) {
		return Math.max(min, Math.min(max, value));
	} // compute euclidian modulo of m % n
	// https://en.wikipedia.org/wiki/Modulo_operation


	function euclideanModulo(n, m) {
		return (n % m + m) % m;
	} // Linear mapping from range <a1, a2> to range <b1, b2>


	function mapLinear(x, a1, a2, b1, b2) {
		return b1 + (x - a1) * (b2 - b1) / (a2 - a1);
	} // https://www.gamedev.net/tutorials/programming/general-and-gameplay-programming/inverse-lerp-a-super-useful-yet-often-overlooked-function-r5230/


	function inverseLerp(x, y, value) {
		if (x !== y) {
			return (value - x) / (y - x);
		} else {
			return 0;
		}
	} // https://en.wikipedia.org/wiki/Linear_interpolation


	function lerp(x, y, t) {
		return (1 - t) * x + t * y;
	} // http://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/


	function damp(x, y, lambda, dt) {
		return lerp(x, y, 1 - Math.exp(-lambda * dt));
	} // https://www.desmos.com/calculator/vcsjnyz7x4


	function pingpong(x, length) {
		if (length === void 0) {
			length = 1;
		}

		return length - Math.abs(euclideanModulo(x, length * 2) - length);
	} // http://en.wikipedia.org/wiki/Smoothstep


	function smoothstep(x, min, max) {
		if (x <= min) return 0;
		if (x >= max) return 1;
		x = (x - min) / (max - min);
		return x * x * (3 - 2 * x);
	}

	function smootherstep(x, min, max) {
		if (x <= min) return 0;
		if (x >= max) return 1;
		x = (x - min) / (max - min);
		return x * x * x * (x * (x * 6 - 15) + 10);
	} // Random integer from <low, high> interval


	function randInt(low, high) {
		return low + Math.floor(Math.random() * (high - low + 1));
	} // Random float from <low, high> interval


	function randFloat(low, high) {
		return low + Math.random() * (high - low);
	} // Random float from <-range/2, range/2> interval


	function randFloatSpread(range) {
		return range * (0.5 - Math.random());
	} // Deterministic pseudo-random float in the interval [ 0, 1 ]


	function seededRandom(s) {
		if (s !== undefined) _seed = s % 2147483647; // Park-Miller algorithm

		_seed = _seed * 16807 % 2147483647;
		return (_seed - 1) / 2147483646;
	}

	function degToRad(degrees) {
		return degrees * DEG2RAD;
	}

	function radToDeg(radians) {
		return radians * RAD2DEG;
	}

	function isPowerOfTwo(value) {
		return (value & value - 1) === 0 && value !== 0;
	}

	function ceilPowerOfTwo(value) {
		return Math.pow(2, Math.ceil(Math.log(value) / Math.LN2));
	}

	function floorPowerOfTwo(value) {
		return Math.pow(2, Math.floor(Math.log(value) / Math.LN2));
	}

	function setQuaternionFromProperEuler(q, a, b, c, order) {
		// Intrinsic Proper Euler Angles - see https://en.wikipedia.org/wiki/Euler_angles
		// rotations are applied to the axes in the order specified by 'order'
		// rotation by angle 'a' is applied first, then by angle 'b', then by angle 'c'
		// angles are in radians
		var cos = Math.cos;
		var sin = Math.sin;
		var c2 = cos(b / 2);
		var s2 = sin(b / 2);
		var c13 = cos((a + c) / 2);
		var s13 = sin((a + c) / 2);
		var c1_3 = cos((a - c) / 2);
		var s1_3 = sin((a - c) / 2);
		var c3_1 = cos((c - a) / 2);
		var s3_1 = sin((c - a) / 2);

		switch (order) {
			case 'XYX':
				q.set(c2 * s13, s2 * c1_3, s2 * s1_3, c2 * c13);
				break;

			case 'YZY':
				q.set(s2 * s1_3, c2 * s13, s2 * c1_3, c2 * c13);
				break;

			case 'ZXZ':
				q.set(s2 * c1_3, s2 * s1_3, c2 * s13, c2 * c13);
				break;

			case 'XZX':
				q.set(c2 * s13, s2 * s3_1, s2 * c3_1, c2 * c13);
				break;

			case 'YXY':
				q.set(s2 * c3_1, c2 * s13, s2 * s3_1, c2 * c13);
				break;

			case 'ZYZ':
				q.set(s2 * s3_1, s2 * c3_1, c2 * s13, c2 * c13);
				break;

			default:
				console.warn('THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: ' + order);
		}
	}

	var MathUtils = /*#__PURE__*/Object.freeze({
		__proto__: null,
		DEG2RAD: DEG2RAD,
		RAD2DEG: RAD2DEG,
		generateUUID: generateUUID,
		clamp: clamp,
		euclideanModulo: euclideanModulo,
		mapLinear: mapLinear,
		inverseLerp: inverseLerp,
		lerp: lerp,
		damp: damp,
		pingpong: pingpong,
		smoothstep: smoothstep,
		smootherstep: smootherstep,
		randInt: randInt,
		randFloat: randFloat,
		randFloatSpread: randFloatSpread,
		seededRandom: seededRandom,
		degToRad: degToRad,
		radToDeg: radToDeg,
		isPowerOfTwo: isPowerOfTwo,
		ceilPowerOfTwo: ceilPowerOfTwo,
		floorPowerOfTwo: floorPowerOfTwo,
		setQuaternionFromProperEuler: setQuaternionFromProperEuler
	});

	var Vector2 = /*#__PURE__*/function () {
		function Vector2(x, y) {
			if (x === void 0) {
				x = 0;
			}

			if (y === void 0) {
				y = 0;
			}

			this.x = x;
			this.y = y;
		}

		var _proto = Vector2.prototype;

		_proto.set = function set(x, y) {
			this.x = x;
			this.y = y;
			return this;
		};

		_proto.setScalar = function setScalar(scalar) {
			this.x = scalar;
			this.y = scalar;
			return this;
		};

		_proto.setX = function setX(x) {
			this.x = x;
			return this;
		};

		_proto.setY = function setY(y) {
			this.y = y;
			return this;
		};

		_proto.setComponent = function setComponent(index, value) {
			switch (index) {
				case 0:
					this.x = value;
					break;

				case 1:
					this.y = value;
					break;

				default:
					throw new Error('index is out of range: ' + index);
			}

			return this;
		};

		_proto.getComponent = function getComponent(index) {
			switch (index) {
				case 0:
					return this.x;

				case 1:
					return this.y;

				default:
					throw new Error('index is out of range: ' + index);
			}
		};

		_proto.clone = function clone() {
			return new this.constructor(this.x, this.y);
		};

		_proto.copy = function copy(v) {
			this.x = v.x;
			this.y = v.y;
			return this;
		};

		_proto.add = function add(v, w) {
			if (w !== undefined) {
				console.warn('THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');
				return this.addVectors(v, w);
			}

			this.x += v.x;
			this.y += v.y;
			return this;
		};

		_proto.addScalar = function addScalar(s) {
			this.x += s;
			this.y += s;
			return this;
		};

		_proto.addVectors = function addVectors(a, b) {
			this.x = a.x + b.x;
			this.y = a.y + b.y;
			return this;
		};

		_proto.addScaledVector = function addScaledVector(v, s) {
			this.x += v.x * s;
			this.y += v.y * s;
			return this;
		};

		_proto.sub = function sub(v, w) {
			if (w !== undefined) {
				console.warn('THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');
				return this.subVectors(v, w);
			}

			this.x -= v.x;
			this.y -= v.y;
			return this;
		};

		_proto.subScalar = function subScalar(s) {
			this.x -= s;
			this.y -= s;
			return this;
		};

		_proto.subVectors = function subVectors(a, b) {
			this.x = a.x - b.x;
			this.y = a.y - b.y;
			return this;
		};

		_proto.multiply = function multiply(v) {
			this.x *= v.x;
			this.y *= v.y;
			return this;
		};

		_proto.multiplyScalar = function multiplyScalar(scalar) {
			this.x *= scalar;
			this.y *= scalar;
			return this;
		};

		_proto.divide = function divide(v) {
			this.x /= v.x;
			this.y /= v.y;
			return this;
		};

		_proto.divideScalar = function divideScalar(scalar) {
			return this.multiplyScalar(1 / scalar);
		};

		_proto.applyMatrix3 = function applyMatrix3(m) {
			var x = this.x,
					y = this.y;
			var e = m.elements;
			this.x = e[0] * x + e[3] * y + e[6];
			this.y = e[1] * x + e[4] * y + e[7];
			return this;
		};

		_proto.min = function min(v) {
			this.x = Math.min(this.x, v.x);
			this.y = Math.min(this.y, v.y);
			return this;
		};

		_proto.max = function max(v) {
			this.x = Math.max(this.x, v.x);
			this.y = Math.max(this.y, v.y);
			return this;
		};

		_proto.clamp = function clamp(min, max) {
			// assumes min < max, componentwise
			this.x = Math.max(min.x, Math.min(max.x, this.x));
			this.y = Math.max(min.y, Math.min(max.y, this.y));
			return this;
		};

		_proto.clampScalar = function clampScalar(minVal, maxVal) {
			this.x = Math.max(minVal, Math.min(maxVal, this.x));
			this.y = Math.max(minVal, Math.min(maxVal, this.y));
			return this;
		};

		_proto.clampLength = function clampLength(min, max) {
			var length = this.length();
			return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
		};

		_proto.floor = function floor() {
			this.x = Math.floor(this.x);
			this.y = Math.floor(this.y);
			return this;
		};

		_proto.ceil = function ceil() {
			this.x = Math.ceil(this.x);
			this.y = Math.ceil(this.y);
			return this;
		};

		_proto.round = function round() {
			this.x = Math.round(this.x);
			this.y = Math.round(this.y);
			return this;
		};

		_proto.roundToZero = function roundToZero() {
			this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
			this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
			return this;
		};

		_proto.negate = function negate() {
			this.x = -this.x;
			this.y = -this.y;
			return this;
		};

		_proto.dot = function dot(v) {
			return this.x * v.x + this.y * v.y;
		};

		_proto.cross = function cross(v) {
			return this.x * v.y - this.y * v.x;
		};

		_proto.lengthSq = function lengthSq() {
			return this.x * this.x + this.y * this.y;
		};

		_proto.length = function length() {
			return Math.sqrt(this.x * this.x + this.y * this.y);
		};

		_proto.manhattanLength = function manhattanLength() {
			return Math.abs(this.x) + Math.abs(this.y);
		};

		_proto.normalize = function normalize() {
			return this.divideScalar(this.length() || 1);
		};

		_proto.angle = function angle() {
			// computes the angle in radians with respect to the positive x-axis
			var angle = Math.atan2(-this.y, -this.x) + Math.PI;
			return angle;
		};

		_proto.distanceTo = function distanceTo(v) {
			return Math.sqrt(this.distanceToSquared(v));
		};

		_proto.distanceToSquared = function distanceToSquared(v) {
			var dx = this.x - v.x,
					dy = this.y - v.y;
			return dx * dx + dy * dy;
		};

		_proto.manhattanDistanceTo = function manhattanDistanceTo(v) {
			return Math.abs(this.x - v.x) + Math.abs(this.y - v.y);
		};

		_proto.setLength = function setLength(length) {
			return this.normalize().multiplyScalar(length);
		};

		_proto.lerp = function lerp(v, alpha) {
			this.x += (v.x - this.x) * alpha;
			this.y += (v.y - this.y) * alpha;
			return this;
		};

		_proto.lerpVectors = function lerpVectors(v1, v2, alpha) {
			this.x = v1.x + (v2.x - v1.x) * alpha;
			this.y = v1.y + (v2.y - v1.y) * alpha;
			return this;
		};

		_proto.equals = function equals(v) {
			return v.x === this.x && v.y === this.y;
		};

		_proto.fromArray = function fromArray(array, offset) {
			if (offset === void 0) {
				offset = 0;
			}

			this.x = array[offset];
			this.y = array[offset + 1];
			return this;
		};

		_proto.toArray = function toArray(array, offset) {
			if (array === void 0) {
				array = [];
			}

			if (offset === void 0) {
				offset = 0;
			}

			array[offset] = this.x;
			array[offset + 1] = this.y;
			return array;
		};

		_proto.fromBufferAttribute = function fromBufferAttribute(attribute, index, offset) {
			if (offset !== undefined) {
				console.warn('THREE.Vector2: offset has been removed from .fromBufferAttribute().');
			}

			this.x = attribute.getX(index);
			this.y = attribute.getY(index);
			return this;
		};

		_proto.rotateAround = function rotateAround(center, angle) {
			var c = Math.cos(angle),
					s = Math.sin(angle);
			var x = this.x - center.x;
			var y = this.y - center.y;
			this.x = x * c - y * s + center.x;
			this.y = x * s + y * c + center.y;
			return this;
		};

		_proto.random = function random() {
			this.x = Math.random();
			this.y = Math.random();
			return this;
		};

		_proto[Symbol.iterator] = /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
			return regeneratorRuntime.wrap(function _callee$(_context) {
				while (1) {
					switch (_context.prev = _context.next) {
						case 0:
							_context.next = 2;
							return this.x;

						case 2:
							_context.next = 4;
							return this.y;

						case 4:
						case "end":
							return _context.stop();
					}
				}
			}, _callee, this);
		});

		_createClass(Vector2, [{
			key: "width",
			get: function get() {
				return this.x;
			},
			set: function set(value) {
				this.x = value;
			}
		}, {
			key: "height",
			get: function get() {
				return this.y;
			},
			set: function set(value) {
				this.y = value;
			}
		}]);

		return Vector2;
	}();

	Vector2.prototype.isVector2 = true;

	var Matrix3 = /*#__PURE__*/function () {
		function Matrix3() {
			this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1];

			if (arguments.length > 0) {
				console.error('THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.');
			}
		}

		var _proto = Matrix3.prototype;

		_proto.set = function set(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
			var te = this.elements;
			te[0] = n11;
			te[1] = n21;
			te[2] = n31;
			te[3] = n12;
			te[4] = n22;
			te[5] = n32;
			te[6] = n13;
			te[7] = n23;
			te[8] = n33;
			return this;
		};

		_proto.identity = function identity() {
			this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);
			return this;
		};

		_proto.copy = function copy(m) {
			var te = this.elements;
			var me = m.elements;
			te[0] = me[0];
			te[1] = me[1];
			te[2] = me[2];
			te[3] = me[3];
			te[4] = me[4];
			te[5] = me[5];
			te[6] = me[6];
			te[7] = me[7];
			te[8] = me[8];
			return this;
		};

		_proto.extractBasis = function extractBasis(xAxis, yAxis, zAxis) {
			xAxis.setFromMatrix3Column(this, 0);
			yAxis.setFromMatrix3Column(this, 1);
			zAxis.setFromMatrix3Column(this, 2);
			return this;
		};

		_proto.setFromMatrix4 = function setFromMatrix4(m) {
			var me = m.elements;
			this.set(me[0], me[4], me[8], me[1], me[5], me[9], me[2], me[6], me[10]);
			return this;
		};

		_proto.multiply = function multiply(m) {
			return this.multiplyMatrices(this, m);
		};

		_proto.premultiply = function premultiply(m) {
			return this.multiplyMatrices(m, this);
		};

		_proto.multiplyMatrices = function multiplyMatrices(a, b) {
			var ae = a.elements;
			var be = b.elements;
			var te = this.elements;
			var a11 = ae[0],
					a12 = ae[3],
					a13 = ae[6];
			var a21 = ae[1],
					a22 = ae[4],
					a23 = ae[7];
			var a31 = ae[2],
					a32 = ae[5],
					a33 = ae[8];
			var b11 = be[0],
					b12 = be[3],
					b13 = be[6];
			var b21 = be[1],
					b22 = be[4],
					b23 = be[7];
			var b31 = be[2],
					b32 = be[5],
					b33 = be[8];
			te[0] = a11 * b11 + a12 * b21 + a13 * b31;
			te[3] = a11 * b12 + a12 * b22 + a13 * b32;
			te[6] = a11 * b13 + a12 * b23 + a13 * b33;
			te[1] = a21 * b11 + a22 * b21 + a23 * b31;
			te[4] = a21 * b12 + a22 * b22 + a23 * b32;
			te[7] = a21 * b13 + a22 * b23 + a23 * b33;
			te[2] = a31 * b11 + a32 * b21 + a33 * b31;
			te[5] = a31 * b12 + a32 * b22 + a33 * b32;
			te[8] = a31 * b13 + a32 * b23 + a33 * b33;
			return this;
		};

		_proto.multiplyScalar = function multiplyScalar(s) {
			var te = this.elements;
			te[0] *= s;
			te[3] *= s;
			te[6] *= s;
			te[1] *= s;
			te[4] *= s;
			te[7] *= s;
			te[2] *= s;
			te[5] *= s;
			te[8] *= s;
			return this;
		};

		_proto.determinant = function determinant() {
			var te = this.elements;
			var a = te[0],
					b = te[1],
					c = te[2],
					d = te[3],
					e = te[4],
					f = te[5],
					g = te[6],
					h = te[7],
					i = te[8];
			return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;
		};

		_proto.invert = function invert() {
			var te = this.elements,
					n11 = te[0],
					n21 = te[1],
					n31 = te[2],
					n12 = te[3],
					n22 = te[4],
					n32 = te[5],
					n13 = te[6],
					n23 = te[7],
					n33 = te[8],
					t11 = n33 * n22 - n32 * n23,
					t12 = n32 * n13 - n33 * n12,
					t13 = n23 * n12 - n22 * n13,
					det = n11 * t11 + n21 * t12 + n31 * t13;
			if (det === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
			var detInv = 1 / det;
			te[0] = t11 * detInv;
			te[1] = (n31 * n23 - n33 * n21) * detInv;
			te[2] = (n32 * n21 - n31 * n22) * detInv;
			te[3] = t12 * detInv;
			te[4] = (n33 * n11 - n31 * n13) * detInv;
			te[5] = (n31 * n12 - n32 * n11) * detInv;
			te[6] = t13 * detInv;
			te[7] = (n21 * n13 - n23 * n11) * detInv;
			te[8] = (n22 * n11 - n21 * n12) * detInv;
			return this;
		};

		_proto.transpose = function transpose() {
			var tmp;
			var m = this.elements;
			tmp = m[1];
			m[1] = m[3];
			m[3] = tmp;
			tmp = m[2];
			m[2] = m[6];
			m[6] = tmp;
			tmp = m[5];
			m[5] = m[7];
			m[7] = tmp;
			return this;
		};

		_proto.getNormalMatrix = function getNormalMatrix(matrix4) {
			return this.setFromMatrix4(matrix4).invert().transpose();
		};

		_proto.transposeIntoArray = function transposeIntoArray(r) {
			var m = this.elements;
			r[0] = m[0];
			r[1] = m[3];
			r[2] = m[6];
			r[3] = m[1];
			r[4] = m[4];
			r[5] = m[7];
			r[6] = m[2];
			r[7] = m[5];
			r[8] = m[8];
			return this;
		};

		_proto.setUvTransform = function setUvTransform(tx, ty, sx, sy, rotation, cx, cy) {
			var c = Math.cos(rotation);
			var s = Math.sin(rotation);
			this.set(sx * c, sx * s, -sx * (c * cx + s * cy) + cx + tx, -sy * s, sy * c, -sy * (-s * cx + c * cy) + cy + ty, 0, 0, 1);
			return this;
		};

		_proto.scale = function scale(sx, sy) {
			var te = this.elements;
			te[0] *= sx;
			te[3] *= sx;
			te[6] *= sx;
			te[1] *= sy;
			te[4] *= sy;
			te[7] *= sy;
			return this;
		};

		_proto.rotate = function rotate(theta) {
			var c = Math.cos(theta);
			var s = Math.sin(theta);
			var te = this.elements;
			var a11 = te[0],
					a12 = te[3],
					a13 = te[6];
			var a21 = te[1],
					a22 = te[4],
					a23 = te[7];
			te[0] = c * a11 + s * a21;
			te[3] = c * a12 + s * a22;
			te[6] = c * a13 + s * a23;
			te[1] = -s * a11 + c * a21;
			te[4] = -s * a12 + c * a22;
			te[7] = -s * a13 + c * a23;
			return this;
		};

		_proto.translate = function translate(tx, ty) {
			var te = this.elements;
			te[0] += tx * te[2];
			te[3] += tx * te[5];
			te[6] += tx * te[8];
			te[1] += ty * te[2];
			te[4] += ty * te[5];
			te[7] += ty * te[8];
			return this;
		};

		_proto.equals = function equals(matrix) {
			var te = this.elements;
			var me = matrix.elements;

			for (var i = 0; i < 9; i++) {
				if (te[i] !== me[i]) return false;
			}

			return true;
		};

		_proto.fromArray = function fromArray(array, offset) {
			if (offset === void 0) {
				offset = 0;
			}

			for (var i = 0; i < 9; i++) {
				this.elements[i] = array[i + offset];
			}

			return this;
		};

		_proto.toArray = function toArray(array, offset) {
			if (array === void 0) {
				array = [];
			}

			if (offset === void 0) {
				offset = 0;
			}

			var te = this.elements;
			array[offset] = te[0];
			array[offset + 1] = te[1];
			array[offset + 2] = te[2];
			array[offset + 3] = te[3];
			array[offset + 4] = te[4];
			array[offset + 5] = te[5];
			array[offset + 6] = te[6];
			array[offset + 7] = te[7];
			array[offset + 8] = te[8];
			return array;
		};

		_proto.clone = function clone() {
			return new this.constructor().fromArray(this.elements);
		};

		return Matrix3;
	}();

	Matrix3.prototype.isMatrix3 = true;

	function arrayMax(array) {
		if (array.length === 0) return -Infinity;
		var max = array[0];

		for (var i = 1, l = array.length; i < l; ++i) {
			if (array[i] > max) max = array[i];
		}

		return max;
	}

	var TYPED_ARRAYS = {
		Int8Array: Int8Array,
		Uint8Array: Uint8Array,
		Uint8ClampedArray: Uint8ClampedArray,
		Int16Array: Int16Array,
		Uint16Array: Uint16Array,
		Int32Array: Int32Array,
		Uint32Array: Uint32Array,
		Float32Array: Float32Array,
		Float64Array: Float64Array
	};

	function getTypedArray(type, buffer) {
		return new TYPED_ARRAYS[type](buffer);
	}

	function createElementNS(name) {
		return document.createElementNS('http://www.w3.org/1999/xhtml', name);
	}

	var _canvas;

	var ImageUtils = /*#__PURE__*/function () {
		function ImageUtils() {}

		ImageUtils.getDataURL = function getDataURL(image) {
			if (/^data:/i.test(image.src)) {
				return image.src;
			}

			if (typeof HTMLCanvasElement == 'undefined') {
				return image.src;
			}

			var canvas;

			if (image instanceof HTMLCanvasElement) {
				canvas = image;
			} else {
				if (_canvas === undefined) _canvas = createElementNS('canvas');
				_canvas.width = image.width;
				_canvas.height = image.height;

				var context = _canvas.getContext('2d');

				if (image instanceof ImageData) {
					context.putImageData(image, 0, 0);
				} else {
					context.drawImage(image, 0, 0, image.width, image.height);
				}

				canvas = _canvas;
			}

			if (canvas.width > 2048 || canvas.height > 2048) {
				console.warn('THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons', image);
				return canvas.toDataURL('image/jpeg', 0.6);
			} else {
				return canvas.toDataURL('image/png');
			}
		};

		return ImageUtils;
	}();

	var textureId = 0;

	var Texture = /*#__PURE__*/function (_EventDispatcher) {
		_inheritsLoose(Texture, _EventDispatcher);

		function Texture(image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding) {
			var _this;

			if (image === void 0) {
				image = Texture.DEFAULT_IMAGE;
			}

			if (mapping === void 0) {
				mapping = Texture.DEFAULT_MAPPING;
			}

			if (wrapS === void 0) {
				wrapS = ClampToEdgeWrapping;
			}

			if (wrapT === void 0) {
				wrapT = ClampToEdgeWrapping;
			}

			if (magFilter === void 0) {
				magFilter = LinearFilter;
			}

			if (minFilter === void 0) {
				minFilter = LinearMipmapLinearFilter;
			}

			if (format === void 0) {
				format = RGBAFormat;
			}

			if (type === void 0) {
				type = UnsignedByteType;
			}

			if (anisotropy === void 0) {
				anisotropy = 1;
			}

			if (encoding === void 0) {
				encoding = LinearEncoding;
			}

			_this = _EventDispatcher.call(this) || this;
			Object.defineProperty(_assertThisInitialized(_this), 'id', {
				value: textureId++
			});
			_this.uuid = generateUUID();
			_this.name = '';
			_this.image = image;
			_this.mipmaps = [];
			_this.mapping = mapping;
			_this.wrapS = wrapS;
			_this.wrapT = wrapT;
			_this.magFilter = magFilter;
			_this.minFilter = minFilter;
			_this.anisotropy = anisotropy;
			_this.format = format;
			_this.internalFormat = null;
			_this.type = type;
			_this.offset = new Vector2(0, 0);
			_this.repeat = new Vector2(1, 1);
			_this.center = new Vector2(0, 0);
			_this.rotation = 0;
			_this.matrixAutoUpdate = true;
			_this.matrix = new Matrix3();
			_this.generateMipmaps = true;
			_this.premultiplyAlpha = false;
			_this.flipY = true;
			_this.unpackAlignment = 4; // valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)
			// Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.
			//
			// Also changing the encoding after already used by a Material will not automatically make the Material
			// update. You need to explicitly call Material.needsUpdate to trigger it to recompile.

			_this.encoding = encoding;
			_this.version = 0;
			_this.onUpdate = null;
			_this.isRenderTargetTexture = false;
			return _this;
		}

		var _proto = Texture.prototype;

		_proto.updateMatrix = function updateMatrix() {
			this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
		};

		_proto.clone = function clone() {
			return new this.constructor().copy(this);
		};

		_proto.copy = function copy(source) {
			this.name = source.name;
			this.image = source.image;
			this.mipmaps = source.mipmaps.slice(0);
			this.mapping = source.mapping;
			this.wrapS = source.wrapS;
			this.wrapT = source.wrapT;
			this.magFilter = source.magFilter;
			this.minFilter = source.minFilter;
			this.anisotropy = source.anisotropy;
			this.format = source.format;
			this.internalFormat = source.internalFormat;
			this.type = source.type;
			this.offset.copy(source.offset);
			this.repeat.copy(source.repeat);
			this.center.copy(source.center);
			this.rotation = source.rotation;
			this.matrixAutoUpdate = source.matrixAutoUpdate;
			this.matrix.copy(source.matrix);
			this.generateMipmaps = source.generateMipmaps;
			this.premultiplyAlpha = source.premultiplyAlpha;
			this.flipY = source.flipY;
			this.unpackAlignment = source.unpackAlignment;
			this.encoding = source.encoding;
			return this;
		};

		_proto.toJSON = function toJSON(meta) {
			var isRootObject = meta === undefined || typeof meta === 'string';

			if (!isRootObject && meta.textures[this.uuid] !== undefined) {
				return meta.textures[this.uuid];
			}

			var output = {
				metadata: {
					version: 4.5,
					type: 'Texture',
					generator: 'Texture.toJSON'
				},
				uuid: this.uuid,
				name: this.name,
				mapping: this.mapping,
				repeat: [this.repeat.x, this.repeat.y],
				offset: [this.offset.x, this.offset.y],
				center: [this.center.x, this.center.y],
				rotation: this.rotation,
				wrap: [this.wrapS, this.wrapT],
				format: this.format,
				type: this.type,
				encoding: this.encoding,
				minFilter: this.minFilter,
				magFilter: this.magFilter,
				anisotropy: this.anisotropy,
				flipY: this.flipY,
				premultiplyAlpha: this.premultiplyAlpha,
				unpackAlignment: this.unpackAlignment
			};

			if (this.image !== undefined) {
				// TODO: Move to THREE.Image
				var image = this.image;

				if (image.uuid === undefined) {
					image.uuid = generateUUID(); // UGH
				}

				if (!isRootObject && meta.images[image.uuid] === undefined) {
					var url;

					if (Array.isArray(image)) {
						// process array of images e.g. CubeTexture
						url = [];

						for (var i = 0, l = image.length; i < l; i++) {
							// check cube texture with data textures
							if (image[i].isDataTexture) {
								url.push(serializeImage(image[i].image));
							} else {
								url.push(serializeImage(image[i]));
							}
						}
					} else {
						// process single image
						url = serializeImage(image);
					}

					meta.images[image.uuid] = {
						uuid: image.uuid,
						url: url
					};
				}

				output.image = image.uuid;
			}

			if (!isRootObject) {
				meta.textures[this.uuid] = output;
			}

			return output;
		};

		_proto.dispose = function dispose() {
			this.dispatchEvent({
				type: 'dispose'
			});
		};

		_proto.transformUv = function transformUv(uv) {
			if (this.mapping !== UVMapping) return uv;
			uv.applyMatrix3(this.matrix);

			if (uv.x < 0 || uv.x > 1) {
				switch (this.wrapS) {
					case RepeatWrapping:
						uv.x = uv.x - Math.floor(uv.x);
						break;

					case ClampToEdgeWrapping:
						uv.x = uv.x < 0 ? 0 : 1;
						break;

					case MirroredRepeatWrapping:
						if (Math.abs(Math.floor(uv.x) % 2) === 1) {
							uv.x = Math.ceil(uv.x) - uv.x;
						} else {
							uv.x = uv.x - Math.floor(uv.x);
						}

						break;
				}
			}

			if (uv.y < 0 || uv.y > 1) {
				switch (this.wrapT) {
					case RepeatWrapping:
						uv.y = uv.y - Math.floor(uv.y);
						break;

					case ClampToEdgeWrapping:
						uv.y = uv.y < 0 ? 0 : 1;
						break;

					case MirroredRepeatWrapping:
						if (Math.abs(Math.floor(uv.y) % 2) === 1) {
							uv.y = Math.ceil(uv.y) - uv.y;
						} else {
							uv.y = uv.y - Math.floor(uv.y);
						}

						break;
				}
			}

			if (this.flipY) {
				uv.y = 1 - uv.y;
			}

			return uv;
		};

		_createClass(Texture, [{
			key: "needsUpdate",
			set: function set(value) {
				if (value === true) this.version++;
			}
		}]);

		return Texture;
	}(EventDispatcher);

	Texture.DEFAULT_IMAGE = undefined;
	Texture.DEFAULT_MAPPING = UVMapping;
	Texture.prototype.isTexture = true;

	function serializeImage(image) {
		if (typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement || typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap) {
			// default images
			return ImageUtils.getDataURL(image);
		} else {
			if (image.data) {
				// images of DataTexture
				return {
					data: Array.prototype.slice.call(image.data),
					width: image.width,
					height: image.height,
					type: image.data.constructor.name
				};
			} else {
				console.warn('THREE.Texture: Unable to serialize Texture.');
				return {};
			}
		}
	}

	var Vector4 = /*#__PURE__*/function () {
		function Vector4(x, y, z, w) {
			if (x === void 0) {
				x = 0;
			}

			if (y === void 0) {
				y = 0;
			}

			if (z === void 0) {
				z = 0;
			}

			if (w === void 0) {
				w = 1;
			}

			this.x = x;
			this.y = y;
			this.z = z;
			this.w = w;
		}

		var _proto = Vector4.prototype;

		_proto.set = function set(x, y, z, w) {
			this.x = x;
			this.y = y;
			this.z = z;
			this.w = w;
			return this;
		};

		_proto.setScalar = function setScalar(scalar) {
			this.x = scalar;
			this.y = scalar;
			this.z = scalar;
			this.w = scalar;
			return this;
		};

		_proto.setX = function setX(x) {
			this.x = x;
			return this;
		};

		_proto.setY = function setY(y) {
			this.y = y;
			return this;
		};

		_proto.setZ = function setZ(z) {
			this.z = z;
			return this;
		};

		_proto.setW = function setW(w) {
			this.w = w;
			return this;
		};

		_proto.setComponent = function setComponent(index, value) {
			switch (index) {
				case 0:
					this.x = value;
					break;

				case 1:
					this.y = value;
					break;

				case 2:
					this.z = value;
					break;

				case 3:
					this.w = value;
					break;

				default:
					throw new Error('index is out of range: ' + index);
			}

			return this;
		};

		_proto.getComponent = function getComponent(index) {
			switch (index) {
				case 0:
					return this.x;

				case 1:
					return this.y;

				case 2:
					return this.z;

				case 3:
					return this.w;

				default:
					throw new Error('index is out of range: ' + index);
			}
		};

		_proto.clone = function clone() {
			return new this.constructor(this.x, this.y, this.z, this.w);
		};

		_proto.copy = function copy(v) {
			this.x = v.x;
			this.y = v.y;
			this.z = v.z;
			this.w = v.w !== undefined ? v.w : 1;
			return this;
		};

		_proto.add = function add(v, w) {
			if (w !== undefined) {
				console.warn('THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');
				return this.addVectors(v, w);
			}

			this.x += v.x;
			this.y += v.y;
			this.z += v.z;
			this.w += v.w;
			return this;
		};

		_proto.addScalar = function addScalar(s) {
			this.x += s;
			this.y += s;
			this.z += s;
			this.w += s;
			return this;
		};

		_proto.addVectors = function addVectors(a, b) {
			this.x = a.x + b.x;
			this.y = a.y + b.y;
			this.z = a.z + b.z;
			this.w = a.w + b.w;
			return this;
		};

		_proto.addScaledVector = function addScaledVector(v, s) {
			this.x += v.x * s;
			this.y += v.y * s;
			this.z += v.z * s;
			this.w += v.w * s;
			return this;
		};

		_proto.sub = function sub(v, w) {
			if (w !== undefined) {
				console.warn('THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');
				return this.subVectors(v, w);
			}

			this.x -= v.x;
			this.y -= v.y;
			this.z -= v.z;
			this.w -= v.w;
			return this;
		};

		_proto.subScalar = function subScalar(s) {
			this.x -= s;
			this.y -= s;
			this.z -= s;
			this.w -= s;
			return this;
		};

		_proto.subVectors = function subVectors(a, b) {
			this.x = a.x - b.x;
			this.y = a.y - b.y;
			this.z = a.z - b.z;
			this.w = a.w - b.w;
			return this;
		};

		_proto.multiply = function multiply(v) {
			this.x *= v.x;
			this.y *= v.y;
			this.z *= v.z;
			this.w *= v.w;
			return this;
		};

		_proto.multiplyScalar = function multiplyScalar(scalar) {
			this.x *= scalar;
			this.y *= scalar;
			this.z *= scalar;
			this.w *= scalar;
			return this;
		};

		_proto.applyMatrix4 = function applyMatrix4(m) {
			var x = this.x,
					y = this.y,
					z = this.z,
					w = this.w;
			var e = m.elements;
			this.x = e[0] * x + e[4] * y + e[8] * z + e[12] * w;
			this.y = e[1] * x + e[5] * y + e[9] * z + e[13] * w;
			this.z = e[2] * x + e[6] * y + e[10] * z + e[14] * w;
			this.w = e[3] * x + e[7] * y + e[11] * z + e[15] * w;
			return this;
		};

		_proto.divideScalar = function divideScalar(scalar) {
			return this.multiplyScalar(1 / scalar);
		};

		_proto.setAxisAngleFromQuaternion = function setAxisAngleFromQuaternion(q) {
			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm
			// q is assumed to be normalized
			this.w = 2 * Math.acos(q.w);
			var s = Math.sqrt(1 - q.w * q.w);

			if (s < 0.0001) {
				this.x = 1;
				this.y = 0;
				this.z = 0;
			} else {
				this.x = q.x / s;
				this.y = q.y / s;
				this.z = q.z / s;
			}

			return this;
		};

		_proto.setAxisAngleFromRotationMatrix = function setAxisAngleFromRotationMatrix(m) {
			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm
			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
			var angle, x, y, z; // variables for result

			var epsilon = 0.01,
					// margin to allow for rounding errors
			epsilon2 = 0.1,
					// margin to distinguish between 0 and 180 degrees
			te = m.elements,
					m11 = te[0],
					m12 = te[4],
					m13 = te[8],
					m21 = te[1],
					m22 = te[5],
					m23 = te[9],
					m31 = te[2],
					m32 = te[6],
					m33 = te[10];

			if (Math.abs(m12 - m21) < epsilon && Math.abs(m13 - m31) < epsilon && Math.abs(m23 - m32) < epsilon) {
				// singularity found
				// first check for identity matrix which must have +1 for all terms
				// in leading diagonal and zero in other terms
				if (Math.abs(m12 + m21) < epsilon2 && Math.abs(m13 + m31) < epsilon2 && Math.abs(m23 + m32) < epsilon2 && Math.abs(m11 + m22 + m33 - 3) < epsilon2) {
					// this singularity is identity matrix so angle = 0
					this.set(1, 0, 0, 0);
					return this; // zero angle, arbitrary axis
				} // otherwise this singularity is angle = 180


				angle = Math.PI;
				var xx = (m11 + 1) / 2;
				var yy = (m22 + 1) / 2;
				var zz = (m33 + 1) / 2;
				var xy = (m12 + m21) / 4;
				var xz = (m13 + m31) / 4;
				var yz = (m23 + m32) / 4;

				if (xx > yy && xx > zz) {
					// m11 is the largest diagonal term
					if (xx < epsilon) {
						x = 0;
						y = 0.707106781;
						z = 0.707106781;
					} else {
						x = Math.sqrt(xx);
						y = xy / x;
						z = xz / x;
					}
				} else if (yy > zz) {
					// m22 is the largest diagonal term
					if (yy < epsilon) {
						x = 0.707106781;
						y = 0;
						z = 0.707106781;
					} else {
						y = Math.sqrt(yy);
						x = xy / y;
						z = yz / y;
					}
				} else {
					// m33 is the largest diagonal term so base result on this
					if (zz < epsilon) {
						x = 0.707106781;
						y = 0.707106781;
						z = 0;
					} else {
						z = Math.sqrt(zz);
						x = xz / z;
						y = yz / z;
					}
				}

				this.set(x, y, z, angle);
				return this; // return 180 deg rotation
			} // as we have reached here there are no singularities so we can handle normally


			var s = Math.sqrt((m32 - m23) * (m32 - m23) + (m13 - m31) * (m13 - m31) + (m21 - m12) * (m21 - m12)); // used to normalize

			if (Math.abs(s) < 0.001) s = 1; // prevent divide by zero, should not happen if matrix is orthogonal and should be
			// caught by singularity test above, but I've left it in just in case

			this.x = (m32 - m23) / s;
			this.y = (m13 - m31) / s;
			this.z = (m21 - m12) / s;
			this.w = Math.acos((m11 + m22 + m33 - 1) / 2);
			return this;
		};

		_proto.min = function min(v) {
			this.x = Math.min(this.x, v.x);
			this.y = Math.min(this.y, v.y);
			this.z = Math.min(this.z, v.z);
			this.w = Math.min(this.w, v.w);
			return this;
		};

		_proto.max = function max(v) {
			this.x = Math.max(this.x, v.x);
			this.y = Math.max(this.y, v.y);
			this.z = Math.max(this.z, v.z);
			this.w = Math.max(this.w, v.w);
			return this;
		};

		_proto.clamp = function clamp(min, max) {
			// assumes min < max, componentwise
			this.x = Math.max(min.x, Math.min(max.x, this.x));
			this.y = Math.max(min.y, Math.min(max.y, this.y));
			this.z = Math.max(min.z, Math.min(max.z, this.z));
			this.w = Math.max(min.w, Math.min(max.w, this.w));
			return this;
		};

		_proto.clampScalar = function clampScalar(minVal, maxVal) {
			this.x = Math.max(minVal, Math.min(maxVal, this.x));
			this.y = Math.max(minVal, Math.min(maxVal, this.y));
			this.z = Math.max(minVal, Math.min(maxVal, this.z));
			this.w = Math.max(minVal, Math.min(maxVal, this.w));
			return this;
		};

		_proto.clampLength = function clampLength(min, max) {
			var length = this.length();
			return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
		};

		_proto.floor = function floor() {
			this.x = Math.floor(this.x);
			this.y = Math.floor(this.y);
			this.z = Math.floor(this.z);
			this.w = Math.floor(this.w);
			return this;
		};

		_proto.ceil = function ceil() {
			this.x = Math.ceil(this.x);
			this.y = Math.ceil(this.y);
			this.z = Math.ceil(this.z);
			this.w = Math.ceil(this.w);
			return this;
		};

		_proto.round = function round() {
			this.x = Math.round(this.x);
			this.y = Math.round(this.y);
			this.z = Math.round(this.z);
			this.w = Math.round(this.w);
			return this;
		};

		_proto.roundToZero = function roundToZero() {
			this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
			this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
			this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
			this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w);
			return this;
		};

		_proto.negate = function negate() {
			this.x = -this.x;
			this.y = -this.y;
			this.z = -this.z;
			this.w = -this.w;
			return this;
		};

		_proto.dot = function dot(v) {
			return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
		};

		_proto.lengthSq = function lengthSq() {
			return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
		};

		_proto.length = function length() {
			return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
		};

		_proto.manhattanLength = function manhattanLength() {
			return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
		};

		_proto.normalize = function normalize() {
			return this.divideScalar(this.length() || 1);
		};

		_proto.setLength = function setLength(length) {
			return this.normalize().multiplyScalar(length);
		};

		_proto.lerp = function lerp(v, alpha) {
			this.x += (v.x - this.x) * alpha;
			this.y += (v.y - this.y) * alpha;
			this.z += (v.z - this.z) * alpha;
			this.w += (v.w - this.w) * alpha;
			return this;
		};

		_proto.lerpVectors = function lerpVectors(v1, v2, alpha) {
			this.x = v1.x + (v2.x - v1.x) * alpha;
			this.y = v1.y + (v2.y - v1.y) * alpha;
			this.z = v1.z + (v2.z - v1.z) * alpha;
			this.w = v1.w + (v2.w - v1.w) * alpha;
			return this;
		};

		_proto.equals = function equals(v) {
			return v.x === this.x && v.y === this.y && v.z === this.z && v.w === this.w;
		};

		_proto.fromArray = function fromArray(array, offset) {
			if (offset === void 0) {
				offset = 0;
			}

			this.x = array[offset];
			this.y = array[offset + 1];
			this.z = array[offset + 2];
			this.w = array[offset + 3];
			return this;
		};

		_proto.toArray = function toArray(array, offset) {
			if (array === void 0) {
				array = [];
			}

			if (offset === void 0) {
				offset = 0;
			}

			array[offset] = this.x;
			array[offset + 1] = this.y;
			array[offset + 2] = this.z;
			array[offset + 3] = this.w;
			return array;
		};

		_proto.fromBufferAttribute = function fromBufferAttribute(attribute, index, offset) {
			if (offset !== undefined) {
				console.warn('THREE.Vector4: offset has been removed from .fromBufferAttribute().');
			}

			this.x = attribute.getX(index);
			this.y = attribute.getY(index);
			this.z = attribute.getZ(index);
			this.w = attribute.getW(index);
			return this;
		};

		_proto.random = function random() {
			this.x = Math.random();
			this.y = Math.random();
			this.z = Math.random();
			this.w = Math.random();
			return this;
		};

		_proto[Symbol.iterator] = /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
			return regeneratorRuntime.wrap(function _callee$(_context) {
				while (1) {
					switch (_context.prev = _context.next) {
						case 0:
							_context.next = 2;
							return this.x;

						case 2:
							_context.next = 4;
							return this.y;

						case 4:
							_context.next = 6;
							return this.z;

						case 6:
							_context.next = 8;
							return this.w;

						case 8:
						case "end":
							return _context.stop();
					}
				}
			}, _callee, this);
		});

		_createClass(Vector4, [{
			key: "width",
			get: function get() {
				return this.z;
			},
			set: function set(value) {
				this.z = value;
			}
		}, {
			key: "height",
			get: function get() {
				return this.w;
			},
			set: function set(value) {
				this.w = value;
			}
		}]);

		return Vector4;
	}();

	Vector4.prototype.isVector4 = true;

	/*
	 In options, we can specify:
	 * Texture parameters for an auto-generated target texture
	 * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers
	*/

	var WebGLRenderTarget = /*#__PURE__*/function (_EventDispatcher) {
		_inheritsLoose(WebGLRenderTarget, _EventDispatcher);

		function WebGLRenderTarget(width, height, options) {
			var _this;

			if (options === void 0) {
				options = {};
			}

			_this = _EventDispatcher.call(this) || this;
			_this.width = width;
			_this.height = height;
			_this.depth = 1;
			_this.scissor = new Vector4(0, 0, width, height);
			_this.scissorTest = false;
			_this.viewport = new Vector4(0, 0, width, height);
			_this.texture = new Texture(undefined, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding);
			_this.texture.isRenderTargetTexture = true;
			_this.texture.image = {
				width: width,
				height: height,
				depth: 1
			};
			_this.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : false;
			_this.texture.internalFormat = options.internalFormat !== undefined ? options.internalFormat : null;
			_this.texture.minFilter = options.minFilter !== undefined ? options.minFilter : LinearFilter;
			_this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;
			_this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : false;
			_this.depthTexture = options.depthTexture !== undefined ? options.depthTexture : null;
			return _this;
		}

		var _proto = WebGLRenderTarget.prototype;

		_proto.setTexture = function setTexture(texture) {
			texture.image = {
				width: this.width,
				height: this.height,
				depth: this.depth
			};
			this.texture = texture;
		};

		_proto.setSize = function setSize(width, height, depth) {
			if (depth === void 0) {
				depth = 1;
			}

			if (this.width !== width || this.height !== height || this.depth !== depth) {
				this.width = width;
				this.height = height;
				this.depth = depth;
				this.texture.image.width = width;
				this.texture.image.height = height;
				this.texture.image.depth = depth;
				this.dispose();
			}

			this.viewport.set(0, 0, width, height);
			this.scissor.set(0, 0, width, height);
		};

		_proto.clone = function clone() {
			return new this.constructor().copy(this);
		};

		_proto.copy = function copy(source) {
			this.width = source.width;
			this.height = source.height;
			this.depth = source.depth;
			this.viewport.copy(source.viewport);
			this.texture = source.texture.clone();
			this.texture.image = _extends({}, this.texture.image); // See #20328.

			this.depthBuffer = source.depthBuffer;
			this.stencilBuffer = source.stencilBuffer;
			this.depthTexture = source.depthTexture;
			return this;
		};

		_proto.dispose = function dispose() {
			this.dispatchEvent({
				type: 'dispose'
			});
		};

		return WebGLRenderTarget;
	}(EventDispatcher);

	WebGLRenderTarget.prototype.isWebGLRenderTarget = true;

	var WebGLMultipleRenderTargets = /*#__PURE__*/function (_WebGLRenderTarget) {
		_inheritsLoose(WebGLMultipleRenderTargets, _WebGLRenderTarget);

		function WebGLMultipleRenderTargets(width, height, count) {
			var _this;

			_this = _WebGLRenderTarget.call(this, width, height) || this;
			var texture = _this.texture;
			_this.texture = [];

			for (var i = 0; i < count; i++) {
				_this.texture[i] = texture.clone();
			}

			return _this;
		}

		var _proto = WebGLMultipleRenderTargets.prototype;

		_proto.setSize = function setSize(width, height, depth) {
			if (depth === void 0) {
				depth = 1;
			}

			if (this.width !== width || this.height !== height || this.depth !== depth) {
				this.width = width;
				this.height = height;
				this.depth = depth;

				for (var i = 0, il = this.texture.length; i < il; i++) {
					this.texture[i].image.width = width;
					this.texture[i].image.height = height;
					this.texture[i].image.depth = depth;
				}

				this.dispose();
			}

			this.viewport.set(0, 0, width, height);
			this.scissor.set(0, 0, width, height);
			return this;
		};

		_proto.copy = function copy(source) {
			this.dispose();
			this.width = source.width;
			this.height = source.height;
			this.depth = source.depth;
			this.viewport.set(0, 0, this.width, this.height);
			this.scissor.set(0, 0, this.width, this.height);
			this.depthBuffer = source.depthBuffer;
			this.stencilBuffer = source.stencilBuffer;
			this.depthTexture = source.depthTexture;
			this.texture.length = 0;

			for (var i = 0, il = source.texture.length; i < il; i++) {
				this.texture[i] = source.texture[i].clone();
			}

			return this;
		};

		return WebGLMultipleRenderTargets;
	}(WebGLRenderTarget);

	WebGLMultipleRenderTargets.prototype.isWebGLMultipleRenderTargets = true;

	var WebGLMultisampleRenderTarget = /*#__PURE__*/function (_WebGLRenderTarget) {
		_inheritsLoose(WebGLMultisampleRenderTarget, _WebGLRenderTarget);

		function WebGLMultisampleRenderTarget(width, height, options) {
			var _this;

			_this = _WebGLRenderTarget.call(this, width, height, options) || this;
			_this.samples = 4;
			return _this;
		}

		var _proto = WebGLMultisampleRenderTarget.prototype;

		_proto.copy = function copy(source) {
			_WebGLRenderTarget.prototype.copy.call(this, source);

			this.samples = source.samples;
			return this;
		};

		return WebGLMultisampleRenderTarget;
	}(WebGLRenderTarget);

	WebGLMultisampleRenderTarget.prototype.isWebGLMultisampleRenderTarget = true;

	var Quaternion = /*#__PURE__*/function () {
		function Quaternion(x, y, z, w) {
			if (x === void 0) {
				x = 0;
			}

			if (y === void 0) {
				y = 0;
			}

			if (z === void 0) {
				z = 0;
			}

			if (w === void 0) {
				w = 1;
			}

			this._x = x;
			this._y = y;
			this._z = z;
			this._w = w;
		}

		Quaternion.slerp = function slerp(qa, qb, qm, t) {
			console.warn('THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead.');
			return qm.slerpQuaternions(qa, qb, t);
		};

		Quaternion.slerpFlat = function slerpFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t) {
			// fuzz-free, array-based Quaternion SLERP operation
			var x0 = src0[srcOffset0 + 0],
					y0 = src0[srcOffset0 + 1],
					z0 = src0[srcOffset0 + 2],
					w0 = src0[srcOffset0 + 3];
			var x1 = src1[srcOffset1 + 0],
					y1 = src1[srcOffset1 + 1],
					z1 = src1[srcOffset1 + 2],
					w1 = src1[srcOffset1 + 3];

			if (t === 0) {
				dst[dstOffset + 0] = x0;
				dst[dstOffset + 1] = y0;
				dst[dstOffset + 2] = z0;
				dst[dstOffset + 3] = w0;
				return;
			}

			if (t === 1) {
				dst[dstOffset + 0] = x1;
				dst[dstOffset + 1] = y1;
				dst[dstOffset + 2] = z1;
				dst[dstOffset + 3] = w1;
				return;
			}

			if (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {
				var s = 1 - t;
				var cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,
						dir = cos >= 0 ? 1 : -1,
						sqrSin = 1 - cos * cos; // Skip the Slerp for tiny steps to avoid numeric problems:

				if (sqrSin > Number.EPSILON) {
					var sin = Math.sqrt(sqrSin),
							len = Math.atan2(sin, cos * dir);
					s = Math.sin(s * len) / sin;
					t = Math.sin(t * len) / sin;
				}

				var tDir = t * dir;
				x0 = x0 * s + x1 * tDir;
				y0 = y0 * s + y1 * tDir;
				z0 = z0 * s + z1 * tDir;
				w0 = w0 * s + w1 * tDir; // Normalize in case we just did a lerp:

				if (s === 1 - t) {
					var f = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);
					x0 *= f;
					y0 *= f;
					z0 *= f;
					w0 *= f;
				}
			}

			dst[dstOffset] = x0;
			dst[dstOffset + 1] = y0;
			dst[dstOffset + 2] = z0;
			dst[dstOffset + 3] = w0;
		};

		Quaternion.multiplyQuaternionsFlat = function multiplyQuaternionsFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1) {
			var x0 = src0[srcOffset0];
			var y0 = src0[srcOffset0 + 1];
			var z0 = src0[srcOffset0 + 2];
			var w0 = src0[srcOffset0 + 3];
			var x1 = src1[srcOffset1];
			var y1 = src1[srcOffset1 + 1];
			var z1 = src1[srcOffset1 + 2];
			var w1 = src1[srcOffset1 + 3];
			dst[dstOffset] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;
			dst[dstOffset + 1] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;
			dst[dstOffset + 2] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;
			dst[dstOffset + 3] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;
			return dst;
		};

		var _proto = Quaternion.prototype;

		_proto.set = function set(x, y, z, w) {
			this._x = x;
			this._y = y;
			this._z = z;
			this._w = w;

			this._onChangeCallback();

			return this;
		};

		_proto.clone = function clone() {
			return new this.constructor(this._x, this._y, this._z, this._w);
		};

		_proto.copy = function copy(quaternion) {
			this._x = quaternion.x;
			this._y = quaternion.y;
			this._z = quaternion.z;
			this._w = quaternion.w;

			this._onChangeCallback();

			return this;
		};

		_proto.setFromEuler = function setFromEuler(euler, update) {
			if (!(euler && euler.isEuler)) {
				throw new Error('THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.');
			}

			var x = euler._x,
					y = euler._y,
					z = euler._z,
					order = euler._order; // http://www.mathworks.com/matlabcentral/fileexchange/
			// 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
			//	content/SpinCalc.m

			var cos = Math.cos;
			var sin = Math.sin;
			var c1 = cos(x / 2);
			var c2 = cos(y / 2);
			var c3 = cos(z / 2);
			var s1 = sin(x / 2);
			var s2 = sin(y / 2);
			var s3 = sin(z / 2);

			switch (order) {
				case 'XYZ':
					this._x = s1 * c2 * c3 + c1 * s2 * s3;
					this._y = c1 * s2 * c3 - s1 * c2 * s3;
					this._z = c1 * c2 * s3 + s1 * s2 * c3;
					this._w = c1 * c2 * c3 - s1 * s2 * s3;
					break;

				case 'YXZ':
					this._x = s1 * c2 * c3 + c1 * s2 * s3;
					this._y = c1 * s2 * c3 - s1 * c2 * s3;
					this._z = c1 * c2 * s3 - s1 * s2 * c3;
					this._w = c1 * c2 * c3 + s1 * s2 * s3;
					break;

				case 'ZXY':
					this._x = s1 * c2 * c3 - c1 * s2 * s3;
					this._y = c1 * s2 * c3 + s1 * c2 * s3;
					this._z = c1 * c2 * s3 + s1 * s2 * c3;
					this._w = c1 * c2 * c3 - s1 * s2 * s3;
					break;

				case 'ZYX':
					this._x = s1 * c2 * c3 - c1 * s2 * s3;
					this._y = c1 * s2 * c3 + s1 * c2 * s3;
					this._z = c1 * c2 * s3 - s1 * s2 * c3;
					this._w = c1 * c2 * c3 + s1 * s2 * s3;
					break;

				case 'YZX':
					this._x = s1 * c2 * c3 + c1 * s2 * s3;
					this._y = c1 * s2 * c3 + s1 * c2 * s3;
					this._z = c1 * c2 * s3 - s1 * s2 * c3;
					this._w = c1 * c2 * c3 - s1 * s2 * s3;
					break;

				case 'XZY':
					this._x = s1 * c2 * c3 - c1 * s2 * s3;
					this._y = c1 * s2 * c3 - s1 * c2 * s3;
					this._z = c1 * c2 * s3 + s1 * s2 * c3;
					this._w = c1 * c2 * c3 + s1 * s2 * s3;
					break;

				default:
					console.warn('THREE.Quaternion: .setFromEuler() encountered an unknown order: ' + order);
			}

			if (update !== false) this._onChangeCallback();
			return this;
		};

		_proto.setFromAxisAngle = function setFromAxisAngle(axis, angle) {
			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm
			// assumes axis is normalized
			var halfAngle = angle / 2,
					s = Math.sin(halfAngle);
			this._x = axis.x * s;
			this._y = axis.y * s;
			this._z = axis.z * s;
			this._w = Math.cos(halfAngle);

			this._onChangeCallback();

			return this;
		};

		_proto.setFromRotationMatrix = function setFromRotationMatrix(m) {
			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm
			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
			var te = m.elements,
					m11 = te[0],
					m12 = te[4],
					m13 = te[8],
					m21 = te[1],
					m22 = te[5],
					m23 = te[9],
					m31 = te[2],
					m32 = te[6],
					m33 = te[10],
					trace = m11 + m22 + m33;

			if (trace > 0) {
				var s = 0.5 / Math.sqrt(trace + 1.0);
				this._w = 0.25 / s;
				this._x = (m32 - m23) * s;
				this._y = (m13 - m31) * s;
				this._z = (m21 - m12) * s;
			} else if (m11 > m22 && m11 > m33) {
				var _s = 2.0 * Math.sqrt(1.0 + m11 - m22 - m33);

				this._w = (m32 - m23) / _s;
				this._x = 0.25 * _s;
				this._y = (m12 + m21) / _s;
				this._z = (m13 + m31) / _s;
			} else if (m22 > m33) {
				var _s2 = 2.0 * Math.sqrt(1.0 + m22 - m11 - m33);

				this._w = (m13 - m31) / _s2;
				this._x = (m12 + m21) / _s2;
				this._y = 0.25 * _s2;
				this._z = (m23 + m32) / _s2;
			} else {
				var _s3 = 2.0 * Math.sqrt(1.0 + m33 - m11 - m22);

				this._w = (m21 - m12) / _s3;
				this._x = (m13 + m31) / _s3;
				this._y = (m23 + m32) / _s3;
				this._z = 0.25 * _s3;
			}

			this._onChangeCallback();

			return this;
		};

		_proto.setFromUnitVectors = function setFromUnitVectors(vFrom, vTo) {
			// assumes direction vectors vFrom and vTo are normalized
			var r = vFrom.dot(vTo) + 1;

			if (r < Number.EPSILON) {
				// vFrom and vTo point in opposite directions
				r = 0;

				if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {
					this._x = -vFrom.y;
					this._y = vFrom.x;
					this._z = 0;
					this._w = r;
				} else {
					this._x = 0;
					this._y = -vFrom.z;
					this._z = vFrom.y;
					this._w = r;
				}
			} else {
				// crossVectors( vFrom, vTo ); // inlined to avoid cyclic dependency on Vector3
				this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;
				this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;
				this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;
				this._w = r;
			}

			return this.normalize();
		};

		_proto.angleTo = function angleTo(q) {
			return 2 * Math.acos(Math.abs(clamp(this.dot(q), -1, 1)));
		};

		_proto.rotateTowards = function rotateTowards(q, step) {
			var angle = this.angleTo(q);
			if (angle === 0) return this;
			var t = Math.min(1, step / angle);
			this.slerp(q, t);
			return this;
		};

		_proto.identity = function identity() {
			return this.set(0, 0, 0, 1);
		};

		_proto.invert = function invert() {
			// quaternion is assumed to have unit length
			return this.conjugate();
		};

		_proto.conjugate = function conjugate() {
			this._x *= -1;
			this._y *= -1;
			this._z *= -1;

			this._onChangeCallback();

			return this;
		};

		_proto.dot = function dot(v) {
			return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;
		};

		_proto.lengthSq = function lengthSq() {
			return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
		};

		_proto.length = function length() {
			return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
		};

		_proto.normalize = function normalize() {
			var l = this.length();

			if (l === 0) {
				this._x = 0;
				this._y = 0;
				this._z = 0;
				this._w = 1;
			} else {
				l = 1 / l;
				this._x = this._x * l;
				this._y = this._y * l;
				this._z = this._z * l;
				this._w = this._w * l;
			}

			this._onChangeCallback();

			return this;
		};

		_proto.multiply = function multiply(q, p) {
			if (p !== undefined) {
				console.warn('THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.');
				return this.multiplyQuaternions(q, p);
			}

			return this.multiplyQuaternions(this, q);
		};

		_proto.premultiply = function premultiply(q) {
			return this.multiplyQuaternions(q, this);
		};

		_proto.multiplyQuaternions = function multiplyQuaternions(a, b) {
			// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm
			var qax = a._x,
					qay = a._y,
					qaz = a._z,
					qaw = a._w;
			var qbx = b._x,
					qby = b._y,
					qbz = b._z,
					qbw = b._w;
			this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
			this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
			this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
			this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;

			this._onChangeCallback();

			return this;
		};

		_proto.slerp = function slerp(qb, t) {
			if (t === 0) return this;
			if (t === 1) return this.copy(qb);
			var x = this._x,
					y = this._y,
					z = this._z,
					w = this._w; // http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/

			var cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;

			if (cosHalfTheta < 0) {
				this._w = -qb._w;
				this._x = -qb._x;
				this._y = -qb._y;
				this._z = -qb._z;
				cosHalfTheta = -cosHalfTheta;
			} else {
				this.copy(qb);
			}

			if (cosHalfTheta >= 1.0) {
				this._w = w;
				this._x = x;
				this._y = y;
				this._z = z;
				return this;
			}

			var sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta;

			if (sqrSinHalfTheta <= Number.EPSILON) {
				var s = 1 - t;
				this._w = s * w + t * this._w;
				this._x = s * x + t * this._x;
				this._y = s * y + t * this._y;
				this._z = s * z + t * this._z;
				this.normalize();

				this._onChangeCallback();

				return this;
			}

			var sinHalfTheta = Math.sqrt(sqrSinHalfTheta);
			var halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);
			var ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta,
					ratioB = Math.sin(t * halfTheta) / sinHalfTheta;
			this._w = w * ratioA + this._w * ratioB;
			this._x = x * ratioA + this._x * ratioB;
			this._y = y * ratioA + this._y * ratioB;
			this._z = z * ratioA + this._z * ratioB;

			this._onChangeCallback();

			return this;
		};

		_proto.slerpQuaternions = function slerpQuaternions(qa, qb, t) {
			this.copy(qa).slerp(qb, t);
		};

		_proto.random = function random() {
			// Derived from http://planning.cs.uiuc.edu/node198.html
			// Note, this source uses w, x, y, z ordering,
			// so we swap the order below.
			var u1 = Math.random();
			var sqrt1u1 = Math.sqrt(1 - u1);
			var sqrtu1 = Math.sqrt(u1);
			var u2 = 2 * Math.PI * Math.random();
			var u3 = 2 * Math.PI * Math.random();
			return this.set(sqrt1u1 * Math.cos(u2), sqrtu1 * Math.sin(u3), sqrtu1 * Math.cos(u3), sqrt1u1 * Math.sin(u2));
		};

		_proto.equals = function equals(quaternion) {
			return quaternion._x === this._x && quaternion._y === this._y && quaternion._z === this._z && quaternion._w === this._w;
		};

		_proto.fromArray = function fromArray(array, offset) {
			if (offset === void 0) {
				offset = 0;
			}

			this._x = array[offset];
			this._y = array[offset + 1];
			this._z = array[offset + 2];
			this._w = array[offset + 3];

			this._onChangeCallback();

			return this;
		};

		_proto.toArray = function toArray(array, offset) {
			if (array === void 0) {
				array = [];
			}

			if (offset === void 0) {
				offset = 0;
			}

			array[offset] = this._x;
			array[offset + 1] = this._y;
			array[offset + 2] = this._z;
			array[offset + 3] = this._w;
			return array;
		};

		_proto.fromBufferAttribute = function fromBufferAttribute(attribute, index) {
			this._x = attribute.getX(index);
			this._y = attribute.getY(index);
			this._z = attribute.getZ(index);
			this._w = attribute.getW(index);
			return this;
		};

		_proto._onChange = function _onChange(callback) {
			this._onChangeCallback = callback;
			return this;
		};

		_proto._onChangeCallback = function _onChangeCallback() {};

		_createClass(Quaternion, [{
			key: "x",
			get: function get() {
				return this._x;
			},
			set: function set(value) {
				this._x = value;

				this._onChangeCallback();
			}
		}, {
			key: "y",
			get: function get() {
				return this._y;
			},
			set: function set(value) {
				this._y = value;

				this._onChangeCallback();
			}
		}, {
			key: "z",
			get: function get() {
				return this._z;
			},
			set: function set(value) {
				this._z = value;

				this._onChangeCallback();
			}
		}, {
			key: "w",
			get: function get() {
				return this._w;
			},
			set: function set(value) {
				this._w = value;

				this._onChangeCallback();
			}
		}]);

		return Quaternion;
	}();

	Quaternion.prototype.isQuaternion = true;

	var Vector3 = /*#__PURE__*/function () {
		function Vector3(x, y, z) {
			if (x === void 0) {
				x = 0;
			}

			if (y === void 0) {
				y = 0;
			}

			if (z === void 0) {
				z = 0;
			}

			this.x = x;
			this.y = y;
			this.z = z;
		}

		var _proto = Vector3.prototype;

		_proto.set = function set(x, y, z) {
			if (z === undefined) z = this.z; // sprite.scale.set(x,y)

			this.x = x;
			this.y = y;
			this.z = z;
			return this;
		};

		_proto.setScalar = function setScalar(scalar) {
			this.x = scalar;
			this.y = scalar;
			this.z = scalar;
			return this;
		};

		_proto.setX = function setX(x) {
			this.x = x;
			return this;
		};

		_proto.setY = function setY(y) {
			this.y = y;
			return this;
		};

		_proto.setZ = function setZ(z) {
			this.z = z;
			return this;
		};

		_proto.setComponent = function setComponent(index, value) {
			switch (index) {
				case 0:
					this.x = value;
					break;

				case 1:
					this.y = value;
					break;

				case 2:
					this.z = value;
					break;

				default:
					throw new Error('index is out of range: ' + index);
			}

			return this;
		};

		_proto.getComponent = function getComponent(index) {
			switch (index) {
				case 0:
					return this.x;

				case 1:
					return this.y;

				case 2:
					return this.z;

				default:
					throw new Error('index is out of range: ' + index);
			}
		};

		_proto.clone = function clone() {
			return new this.constructor(this.x, this.y, this.z);
		};

		_proto.copy = function copy(v) {
			this.x = v.x;
			this.y = v.y;
			this.z = v.z;
			return this;
		};

		_proto.add = function add(v, w) {
			if (w !== undefined) {
				console.warn('THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');
				return this.addVectors(v, w);
			}

			this.x += v.x;
			this.y += v.y;
			this.z += v.z;
			return this;
		};

		_proto.addScalar = function addScalar(s) {
			this.x += s;
			this.y += s;
			this.z += s;
			return this;
		};

		_proto.addVectors = function addVectors(a, b) {
			this.x = a.x + b.x;
			this.y = a.y + b.y;
			this.z = a.z + b.z;
			return this;
		};

		_proto.addScaledVector = function addScaledVector(v, s) {
			this.x += v.x * s;
			this.y += v.y * s;
			this.z += v.z * s;
			return this;
		};

		_proto.sub = function sub(v, w) {
			if (w !== undefined) {
				console.warn('THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');
				return this.subVectors(v, w);
			}

			this.x -= v.x;
			this.y -= v.y;
			this.z -= v.z;
			return this;
		};

		_proto.subScalar = function subScalar(s) {
			this.x -= s;
			this.y -= s;
			this.z -= s;
			return this;
		};

		_proto.subVectors = function subVectors(a, b) {
			this.x = a.x - b.x;
			this.y = a.y - b.y;
			this.z = a.z - b.z;
			return this;
		};

		_proto.multiply = function multiply(v, w) {
			if (w !== undefined) {
				console.warn('THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.');
				return this.multiplyVectors(v, w);
			}

			this.x *= v.x;
			this.y *= v.y;
			this.z *= v.z;
			return this;
		};

		_proto.multiplyScalar = function multiplyScalar(scalar) {
			this.x *= scalar;
			this.y *= scalar;
			this.z *= scalar;
			return this;
		};

		_proto.multiplyVectors = function multiplyVectors(a, b) {
			this.x = a.x * b.x;
			this.y = a.y * b.y;
			this.z = a.z * b.z;
			return this;
		};

		_proto.applyEuler = function applyEuler(euler) {
			if (!(euler && euler.isEuler)) {
				console.error('THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.');
			}

			return this.applyQuaternion(_quaternion.setFromEuler(euler));
		};

		_proto.applyAxisAngle = function applyAxisAngle(axis, angle) {
			return this.applyQuaternion(_quaternion.setFromAxisAngle(axis, angle));
		};

		_proto.applyMatrix3 = function applyMatrix3(m) {
			var x = this.x,
					y = this.y,
					z = this.z;
			var e = m.elements;
			this.x = e[0] * x + e[3] * y + e[6] * z;
			this.y = e[1] * x + e[4] * y + e[7] * z;
			this.z = e[2] * x + e[5] * y + e[8] * z;
			return this;
		};

		_proto.applyNormalMatrix = function applyNormalMatrix(m) {
			return this.applyMatrix3(m).normalize();
		};

		_proto.applyMatrix4 = function applyMatrix4(m) {
			var x = this.x,
					y = this.y,
					z = this.z;
			var e = m.elements;
			var w = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15]);
			this.x = (e[0] * x + e[4] * y + e[8] * z + e[12]) * w;
			this.y = (e[1] * x + e[5] * y + e[9] * z + e[13]) * w;
			this.z = (e[2] * x + e[6] * y + e[10] * z + e[14]) * w;
			return this;
		};

		_proto.applyQuaternion = function applyQuaternion(q) {
			var x = this.x,
					y = this.y,
					z = this.z;
			var qx = q.x,
					qy = q.y,
					qz = q.z,
					qw = q.w; // calculate quat * vector

			var ix = qw * x + qy * z - qz * y;
			var iy = qw * y + qz * x - qx * z;
			var iz = qw * z + qx * y - qy * x;
			var iw = -qx * x - qy * y - qz * z; // calculate result * inverse quat

			this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
			this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
			this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
			return this;
		};

		_proto.project = function project(camera) {
			return this.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(camera.projectionMatrix);
		};

		_proto.unproject = function unproject(camera) {
			return this.applyMatrix4(camera.projectionMatrixInverse).applyMatrix4(camera.matrixWorld);
		};

		_proto.transformDirection = function transformDirection(m) {
			// input: THREE.Matrix4 affine matrix
			// vector interpreted as a direction
			var x = this.x,
					y = this.y,
					z = this.z;
			var e = m.elements;
			this.x = e[0] * x + e[4] * y + e[8] * z;
			this.y = e[1] * x + e[5] * y + e[9] * z;
			this.z = e[2] * x + e[6] * y + e[10] * z;
			return this.normalize();
		};

		_proto.divide = function divide(v) {
			this.x /= v.x;
			this.y /= v.y;
			this.z /= v.z;
			return this;
		};

		_proto.divideScalar = function divideScalar(scalar) {
			return this.multiplyScalar(1 / scalar);
		};

		_proto.min = function min(v) {
			this.x = Math.min(this.x, v.x);
			this.y = Math.min(this.y, v.y);
			this.z = Math.min(this.z, v.z);
			return this;
		};

		_proto.max = function max(v) {
			this.x = Math.max(this.x, v.x);
			this.y = Math.max(this.y, v.y);
			this.z = Math.max(this.z, v.z);
			return this;
		};

		_proto.clamp = function clamp(min, max) {
			// assumes min < max, componentwise
			this.x = Math.max(min.x, Math.min(max.x, this.x));
			this.y = Math.max(min.y, Math.min(max.y, this.y));
			this.z = Math.max(min.z, Math.min(max.z, this.z));
			return this;
		};

		_proto.clampScalar = function clampScalar(minVal, maxVal) {
			this.x = Math.max(minVal, Math.min(maxVal, this.x));
			this.y = Math.max(minVal, Math.min(maxVal, this.y));
			this.z = Math.max(minVal, Math.min(maxVal, this.z));
			return this;
		};

		_proto.clampLength = function clampLength(min, max) {
			var length = this.length();
			return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
		};

		_proto.floor = function floor() {
			this.x = Math.floor(this.x);
			this.y = Math.floor(this.y);
			this.z = Math.floor(this.z);
			return this;
		};

		_proto.ceil = function ceil() {
			this.x = Math.ceil(this.x);
			this.y = Math.ceil(this.y);
			this.z = Math.ceil(this.z);
			return this;
		};

		_proto.round = function round() {
			this.x = Math.round(this.x);
			this.y = Math.round(this.y);
			this.z = Math.round(this.z);
			return this;
		};

		_proto.roundToZero = function roundToZero() {
			this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
			this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
			this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
			return this;
		};

		_proto.negate = function negate() {
			this.x = -this.x;
			this.y = -this.y;
			this.z = -this.z;
			return this;
		};

		_proto.dot = function dot(v) {
			return this.x * v.x + this.y * v.y + this.z * v.z;
		} // TODO lengthSquared?
		;

		_proto.lengthSq = function lengthSq() {
			return this.x * this.x + this.y * this.y + this.z * this.z;
		};

		_proto.length = function length() {
			return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
		};

		_proto.manhattanLength = function manhattanLength() {
			return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
		};

		_proto.normalize = function normalize() {
			return this.divideScalar(this.length() || 1);
		};

		_proto.setLength = function setLength(length) {
			return this.normalize().multiplyScalar(length);
		};

		_proto.lerp = function lerp(v, alpha) {
			this.x += (v.x - this.x) * alpha;
			this.y += (v.y - this.y) * alpha;
			this.z += (v.z - this.z) * alpha;
			return this;
		};

		_proto.lerpVectors = function lerpVectors(v1, v2, alpha) {
			this.x = v1.x + (v2.x - v1.x) * alpha;
			this.y = v1.y + (v2.y - v1.y) * alpha;
			this.z = v1.z + (v2.z - v1.z) * alpha;
			return this;
		};

		_proto.cross = function cross(v, w) {
			if (w !== undefined) {
				console.warn('THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.');
				return this.crossVectors(v, w);
			}

			return this.crossVectors(this, v);
		};

		_proto.crossVectors = function crossVectors(a, b) {
			var ax = a.x,
					ay = a.y,
					az = a.z;
			var bx = b.x,
					by = b.y,
					bz = b.z;
			this.x = ay * bz - az * by;
			this.y = az * bx - ax * bz;
			this.z = ax * by - ay * bx;
			return this;
		};

		_proto.projectOnVector = function projectOnVector(v) {
			var denominator = v.lengthSq();
			if (denominator === 0) return this.set(0, 0, 0);
			var scalar = v.dot(this) / denominator;
			return this.copy(v).multiplyScalar(scalar);
		};

		_proto.projectOnPlane = function projectOnPlane(planeNormal) {
			_vector.copy(this).projectOnVector(planeNormal);

			return this.sub(_vector);
		};

		_proto.reflect = function reflect(normal) {
			// reflect incident vector off plane orthogonal to normal
			// normal is assumed to have unit length
			return this.sub(_vector.copy(normal).multiplyScalar(2 * this.dot(normal)));
		};

		_proto.angleTo = function angleTo(v) {
			var denominator = Math.sqrt(this.lengthSq() * v.lengthSq());
			if (denominator === 0) return Math.PI / 2;
			var theta = this.dot(v) / denominator; // clamp, to handle numerical problems

			return Math.acos(clamp(theta, -1, 1));
		};

		_proto.distanceTo = function distanceTo(v) {
			return Math.sqrt(this.distanceToSquared(v));
		};

		_proto.distanceToSquared = function distanceToSquared(v) {
			var dx = this.x - v.x,
					dy = this.y - v.y,
					dz = this.z - v.z;
			return dx * dx + dy * dy + dz * dz;
		};

		_proto.manhattanDistanceTo = function manhattanDistanceTo(v) {
			return Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z);
		};

		_proto.setFromSpherical = function setFromSpherical(s) {
			return this.setFromSphericalCoords(s.radius, s.phi, s.theta);
		};

		_proto.setFromSphericalCoords = function setFromSphericalCoords(radius, phi, theta) {
			var sinPhiRadius = Math.sin(phi) * radius;
			this.x = sinPhiRadius * Math.sin(theta);
			this.y = Math.cos(phi) * radius;
			this.z = sinPhiRadius * Math.cos(theta);
			return this;
		};

		_proto.setFromCylindrical = function setFromCylindrical(c) {
			return this.setFromCylindricalCoords(c.radius, c.theta, c.y);
		};

		_proto.setFromCylindricalCoords = function setFromCylindricalCoords(radius, theta, y) {
			this.x = radius * Math.sin(theta);
			this.y = y;
			this.z = radius * Math.cos(theta);
			return this;
		};

		_proto.setFromMatrixPosition = function setFromMatrixPosition(m) {
			var e = m.elements;
			this.x = e[12];
			this.y = e[13];
			this.z = e[14];
			return this;
		};

		_proto.setFromMatrixScale = function setFromMatrixScale(m) {
			var sx = this.setFromMatrixColumn(m, 0).length();
			var sy = this.setFromMatrixColumn(m, 1).length();
			var sz = this.setFromMatrixColumn(m, 2).length();
			this.x = sx;
			this.y = sy;
			this.z = sz;
			return this;
		};

		_proto.setFromMatrixColumn = function setFromMatrixColumn(m, index) {
			return this.fromArray(m.elements, index * 4);
		};

		_proto.setFromMatrix3Column = function setFromMatrix3Column(m, index) {
			return this.fromArray(m.elements, index * 3);
		};

		_proto.equals = function equals(v) {
			return v.x === this.x && v.y === this.y && v.z === this.z;
		};

		_proto.fromArray = function fromArray(array, offset) {
			if (offset === void 0) {
				offset = 0;
			}

			this.x = array[offset];
			this.y = array[offset + 1];
			this.z = array[offset + 2];
			return this;
		};

		_proto.toArray = function toArray(array, offset) {
			if (array === void 0) {
				array = [];
			}

			if (offset === void 0) {
				offset = 0;
			}

			array[offset] = this.x;
			array[offset + 1] = this.y;
			array[offset + 2] = this.z;
			return array;
		};

		_proto.fromBufferAttribute = function fromBufferAttribute(attribute, index, offset) {
			if (offset !== undefined) {
				console.warn('THREE.Vector3: offset has been removed from .fromBufferAttribute().');
			}

			this.x = attribute.getX(index);
			this.y = attribute.getY(index);
			this.z = attribute.getZ(index);
			return this;
		};

		_proto.random = function random() {
			this.x = Math.random();
			this.y = Math.random();
			this.z = Math.random();
			return this;
		};

		_proto.randomDirection = function randomDirection() {
			// Derived from https://mathworld.wolfram.com/SpherePointPicking.html
			var u = (Math.random() - 0.5) * 2;
			var t = Math.random() * Math.PI * 2;
			var f = Math.sqrt(1 - Math.pow(u, 2));
			this.x = f * Math.cos(t);
			this.y = f * Math.sin(t);
			this.z = u;
			return this;
		};

		_proto[Symbol.iterator] = /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
			return regeneratorRuntime.wrap(function _callee$(_context) {
				while (1) {
					switch (_context.prev = _context.next) {
						case 0:
							_context.next = 2;
							return this.x;

						case 2:
							_context.next = 4;
							return this.y;

						case 4:
							_context.next = 6;
							return this.z;

						case 6:
						case "end":
							return _context.stop();
					}
				}
			}, _callee, this);
		});
		return Vector3;
	}();

	Vector3.prototype.isVector3 = true;

	var _vector = /*@__PURE__*/new Vector3();

	var _quaternion = /*@__PURE__*/new Quaternion();

	var Box3 = /*#__PURE__*/function () {
		function Box3(min, max) {
			if (min === void 0) {
				min = new Vector3(+Infinity, +Infinity, +Infinity);
			}

			if (max === void 0) {
				max = new Vector3(-Infinity, -Infinity, -Infinity);
			}

			this.min = min;
			this.max = max;
		}

		var _proto = Box3.prototype;

		_proto.set = function set(min, max) {
			this.min.copy(min);
			this.max.copy(max);
			return this;
		};

		_proto.setFromArray = function setFromArray(array) {
			var minX = +Infinity;
			var minY = +Infinity;
			var minZ = +Infinity;
			var maxX = -Infinity;
			var maxY = -Infinity;
			var maxZ = -Infinity;

			for (var i = 0, l = array.length; i < l; i += 3) {
				var x = array[i];
				var y = array[i + 1];
				var z = array[i + 2];
				if (x < minX) minX = x;
				if (y < minY) minY = y;
				if (z < minZ) minZ = z;
				if (x > maxX) maxX = x;
				if (y > maxY) maxY = y;
				if (z > maxZ) maxZ = z;
			}

			this.min.set(minX, minY, minZ);
			this.max.set(maxX, maxY, maxZ);
			return this;
		};

		_proto.setFromBufferAttribute = function setFromBufferAttribute(attribute) {
			var minX = +Infinity;
			var minY = +Infinity;
			var minZ = +Infinity;
			var maxX = -Infinity;
			var maxY = -Infinity;
			var maxZ = -Infinity;

			for (var i = 0, l = attribute.count; i < l; i++) {
				var x = attribute.getX(i);
				var y = attribute.getY(i);
				var z = attribute.getZ(i);
				if (x < minX) minX = x;
				if (y < minY) minY = y;
				if (z < minZ) minZ = z;
				if (x > maxX) maxX = x;
				if (y > maxY) maxY = y;
				if (z > maxZ) maxZ = z;
			}

			this.min.set(minX, minY, minZ);
			this.max.set(maxX, maxY, maxZ);
			return this;
		};

		_proto.setFromPoints = function setFromPoints(points) {
			this.makeEmpty();

			for (var i = 0, il = points.length; i < il; i++) {
				this.expandByPoint(points[i]);
			}

			return this;
		};

		_proto.setFromCenterAndSize = function setFromCenterAndSize(center, size) {
			var halfSize = _vector$1.copy(size).multiplyScalar(0.5);

			this.min.copy(center).sub(halfSize);
			this.max.copy(center).add(halfSize);
			return this;
		};

		_proto.setFromObject = function setFromObject(object) {
			this.makeEmpty();
			return this.expandByObject(object);
		};

		_proto.clone = function clone() {
			return new this.constructor().copy(this);
		};

		_proto.copy = function copy(box) {
			this.min.copy(box.min);
			this.max.copy(box.max);
			return this;
		};

		_proto.makeEmpty = function makeEmpty() {
			this.min.x = this.min.y = this.min.z = +Infinity;
			this.max.x = this.max.y = this.max.z = -Infinity;
			return this;
		};

		_proto.isEmpty = function isEmpty() {
			// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes
			return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
		};

		_proto.getCenter = function getCenter(target) {
			return this.isEmpty() ? target.set(0, 0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
		};

		_proto.getSize = function getSize(target) {
			return this.isEmpty() ? target.set(0, 0, 0) : target.subVectors(this.max, this.min);
		};

		_proto.expandByPoint = function expandByPoint(point) {
			this.min.min(point);
			this.max.max(point);
			return this;
		};

		_proto.expandByVector = function expandByVector(vector) {
			this.min.sub(vector);
			this.max.add(vector);
			return this;
		};

		_proto.expandByScalar = function expandByScalar(scalar) {
			this.min.addScalar(-scalar);
			this.max.addScalar(scalar);
			return this;
		};

		_proto.expandByObject = function expandByObject(object) {
			// Computes the world-axis-aligned bounding box of an object (including its children),
			// accounting for both the object's, and children's, world transforms
			object.updateWorldMatrix(false, false);
			var geometry = object.geometry;

			if (geometry !== undefined) {
				if (geometry.boundingBox === null) {
					geometry.computeBoundingBox();
				}

				_box.copy(geometry.boundingBox);

				_box.applyMatrix4(object.matrixWorld);

				this.union(_box);
			}

			var children = object.children;

			for (var i = 0, l = children.length; i < l; i++) {
				this.expandByObject(children[i]);
			}

			return this;
		};

		_proto.containsPoint = function containsPoint(point) {
			return point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y || point.z < this.min.z || point.z > this.max.z ? false : true;
		};

		_proto.containsBox = function containsBox(box) {
			return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y && this.min.z <= box.min.z && box.max.z <= this.max.z;
		};

		_proto.getParameter = function getParameter(point, target) {
			// This can potentially have a divide by zero if the box
			// has a size dimension of 0.
			return target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y), (point.z - this.min.z) / (this.max.z - this.min.z));
		};

		_proto.intersectsBox = function intersectsBox(box) {
			// using 6 splitting planes to rule out intersections.
			return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y || box.max.z < this.min.z || box.min.z > this.max.z ? false : true;
		};

		_proto.intersectsSphere = function intersectsSphere(sphere) {
			// Find the point on the AABB closest to the sphere center.
			this.clampPoint(sphere.center, _vector$1); // If that point is inside the sphere, the AABB and sphere intersect.

			return _vector$1.distanceToSquared(sphere.center) <= sphere.radius * sphere.radius;
		};

		_proto.intersectsPlane = function intersectsPlane(plane) {
			// We compute the minimum and maximum dot product values. If those values
			// are on the same side (back or front) of the plane, then there is no intersection.
			var min, max;

			if (plane.normal.x > 0) {
				min = plane.normal.x * this.min.x;
				max = plane.normal.x * this.max.x;
			} else {
				min = plane.normal.x * this.max.x;
				max = plane.normal.x * this.min.x;
			}

			if (plane.normal.y > 0) {
				min += plane.normal.y * this.min.y;
				max += plane.normal.y * this.max.y;
			} else {
				min += plane.normal.y * this.max.y;
				max += plane.normal.y * this.min.y;
			}

			if (plane.normal.z > 0) {
				min += plane.normal.z * this.min.z;
				max += plane.normal.z * this.max.z;
			} else {
				min += plane.normal.z * this.max.z;
				max += plane.normal.z * this.min.z;
			}

			return min <= -plane.constant && max >= -plane.constant;
		};

		_proto.intersectsTriangle = function intersectsTriangle(triangle) {
			if (this.isEmpty()) {
				return false;
			} // compute box center and extents


			this.getCenter(_center);

			_extents.subVectors(this.max, _center); // translate triangle to aabb origin


			_v0.subVectors(triangle.a, _center);

			_v1.subVectors(triangle.b, _center);

			_v2.subVectors(triangle.c, _center); // compute edge vectors for triangle


			_f0.subVectors(_v1, _v0);

			_f1.subVectors(_v2, _v1);

			_f2.subVectors(_v0, _v2); // test against axes that are given by cross product combinations of the edges of the triangle and the edges of the aabb
			// make an axis testing of each of the 3 sides of the aabb against each of the 3 sides of the triangle = 9 axis of separation
			// axis_ij = u_i x f_j (u0, u1, u2 = face normals of aabb = x,y,z axes vectors since aabb is axis aligned)


			var axes = [0, -_f0.z, _f0.y, 0, -_f1.z, _f1.y, 0, -_f2.z, _f2.y, _f0.z, 0, -_f0.x, _f1.z, 0, -_f1.x, _f2.z, 0, -_f2.x, -_f0.y, _f0.x, 0, -_f1.y, _f1.x, 0, -_f2.y, _f2.x, 0];

			if (!satForAxes(axes, _v0, _v1, _v2, _extents)) {
				return false;
			} // test 3 face normals from the aabb


			axes = [1, 0, 0, 0, 1, 0, 0, 0, 1];

			if (!satForAxes(axes, _v0, _v1, _v2, _extents)) {
				return false;
			} // finally testing the face normal of the triangle
			// use already existing triangle edge vectors here


			_triangleNormal.crossVectors(_f0, _f1);

			axes = [_triangleNormal.x, _triangleNormal.y, _triangleNormal.z];
			return satForAxes(axes, _v0, _v1, _v2, _extents);
		};

		_proto.clampPoint = function clampPoint(point, target) {
			return target.copy(point).clamp(this.min, this.max);
		};

		_proto.distanceToPoint = function distanceToPoint(point) {
			var clampedPoint = _vector$1.copy(point).clamp(this.min, this.max);

			return clampedPoint.sub(point).length();
		};

		_proto.getBoundingSphere = function getBoundingSphere(target) {
			this.getCenter(target.center);
			target.radius = this.getSize(_vector$1).length() * 0.5;
			return target;
		};

		_proto.intersect = function intersect(box) {
			this.min.max(box.min);
			this.max.min(box.max); // ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.

			if (this.isEmpty()) this.makeEmpty();
			return this;
		};

		_proto.union = function union(box) {
			this.min.min(box.min);
			this.max.max(box.max);
			return this;
		};

		_proto.applyMatrix4 = function applyMatrix4(matrix) {
			// transform of empty box is an empty box.
			if (this.isEmpty()) return this; // NOTE: I am using a binary pattern to specify all 2^3 combinations below

			_points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix); // 000


			_points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix); // 001


			_points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix); // 010


			_points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix); // 011


			_points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix); // 100


			_points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix); // 101


			_points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix); // 110


			_points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix); // 111


			this.setFromPoints(_points);
			return this;
		};

		_proto.translate = function translate(offset) {
			this.min.add(offset);
			this.max.add(offset);
			return this;
		};

		_proto.equals = function equals(box) {
			return box.min.equals(this.min) && box.max.equals(this.max);
		};

		return Box3;
	}();

	Box3.prototype.isBox3 = true;
	var _points = [/*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3()];

	var _vector$1 = /*@__PURE__*/new Vector3();

	var _box = /*@__PURE__*/new Box3(); // triangle centered vertices


	var _v0 = /*@__PURE__*/new Vector3();

	var _v1 = /*@__PURE__*/new Vector3();

	var _v2 = /*@__PURE__*/new Vector3(); // triangle edge vectors


	var _f0 = /*@__PURE__*/new Vector3();

	var _f1 = /*@__PURE__*/new Vector3();

	var _f2 = /*@__PURE__*/new Vector3();

	var _center = /*@__PURE__*/new Vector3();

	var _extents = /*@__PURE__*/new Vector3();

	var _triangleNormal = /*@__PURE__*/new Vector3();

	var _testAxis = /*@__PURE__*/new Vector3();

	function satForAxes(axes, v0, v1, v2, extents) {
		for (var i = 0, j = axes.length - 3; i <= j; i += 3) {
			_testAxis.fromArray(axes, i); // project the aabb onto the seperating axis


			var r = extents.x * Math.abs(_testAxis.x) + extents.y * Math.abs(_testAxis.y) + extents.z * Math.abs(_testAxis.z); // project all 3 vertices of the triangle onto the seperating axis

			var p0 = v0.dot(_testAxis);
			var p1 = v1.dot(_testAxis);
			var p2 = v2.dot(_testAxis); // actual test, basically see if either of the most extreme of the triangle points intersects r

			if (Math.max(-Math.max(p0, p1, p2), Math.min(p0, p1, p2)) > r) {
				// points of the projected triangle are outside the projected half-length of the aabb
				// the axis is seperating and we can exit
				return false;
			}
		}

		return true;
	}

	var _box$1 = /*@__PURE__*/new Box3();

	var _v1$1 = /*@__PURE__*/new Vector3();

	var _toFarthestPoint = /*@__PURE__*/new Vector3();

	var _toPoint = /*@__PURE__*/new Vector3();

	var Sphere = /*#__PURE__*/function () {
		function Sphere(center, radius) {
			if (center === void 0) {
				center = new Vector3();
			}

			if (radius === void 0) {
				radius = -1;
			}

			this.center = center;
			this.radius = radius;
		}

		var _proto = Sphere.prototype;

		_proto.set = function set(center, radius) {
			this.center.copy(center);
			this.radius = radius;
			return this;
		};

		_proto.setFromPoints = function setFromPoints(points, optionalCenter) {
			var center = this.center;

			if (optionalCenter !== undefined) {
				center.copy(optionalCenter);
			} else {
				_box$1.setFromPoints(points).getCenter(center);
			}

			var maxRadiusSq = 0;

			for (var i = 0, il = points.length; i < il; i++) {
				maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i]));
			}

			this.radius = Math.sqrt(maxRadiusSq);
			return this;
		};

		_proto.copy = function copy(sphere) {
			this.center.copy(sphere.center);
			this.radius = sphere.radius;
			return this;
		};

		_proto.isEmpty = function isEmpty() {
			return this.radius < 0;
		};

		_proto.makeEmpty = function makeEmpty() {
			this.center.set(0, 0, 0);
			this.radius = -1;
			return this;
		};

		_proto.containsPoint = function containsPoint(point) {
			return point.distanceToSquared(this.center) <= this.radius * this.radius;
		};

		_proto.distanceToPoint = function distanceToPoint(point) {
			return point.distanceTo(this.center) - this.radius;
		};

		_proto.intersectsSphere = function intersectsSphere(sphere) {
			var radiusSum = this.radius + sphere.radius;
			return sphere.center.distanceToSquared(this.center) <= radiusSum * radiusSum;
		};

		_proto.intersectsBox = function intersectsBox(box) {
			return box.intersectsSphere(this);
		};

		_proto.intersectsPlane = function intersectsPlane(plane) {
			return Math.abs(plane.distanceToPoint(this.center)) <= this.radius;
		};

		_proto.clampPoint = function clampPoint(point, target) {
			var deltaLengthSq = this.center.distanceToSquared(point);
			target.copy(point);

			if (deltaLengthSq > this.radius * this.radius) {
				target.sub(this.center).normalize();
				target.multiplyScalar(this.radius).add(this.center);
			}

			return target;
		};

		_proto.getBoundingBox = function getBoundingBox(target) {
			if (this.isEmpty()) {
				// Empty sphere produces empty bounding box
				target.makeEmpty();
				return target;
			}

			target.set(this.center, this.center);
			target.expandByScalar(this.radius);
			return target;
		};

		_proto.applyMatrix4 = function applyMatrix4(matrix) {
			this.center.applyMatrix4(matrix);
			this.radius = this.radius * matrix.getMaxScaleOnAxis();
			return this;
		};

		_proto.translate = function translate(offset) {
			this.center.add(offset);
			return this;
		};

		_proto.expandByPoint = function expandByPoint(point) {
			// from https://github.com/juj/MathGeoLib/blob/2940b99b99cfe575dd45103ef20f4019dee15b54/src/Geometry/Sphere.cpp#L649-L671
			_toPoint.subVectors(point, this.center);

			var lengthSq = _toPoint.lengthSq();

			if (lengthSq > this.radius * this.radius) {
				var length = Math.sqrt(lengthSq);
				var missingRadiusHalf = (length - this.radius) * 0.5; // Nudge this sphere towards the target point. Add half the missing distance to radius,
				// and the other half to position. This gives a tighter enclosure, instead of if
				// the whole missing distance were just added to radius.

				this.center.add(_toPoint.multiplyScalar(missingRadiusHalf / length));
				this.radius += missingRadiusHalf;
			}

			return this;
		};

		_proto.union = function union(sphere) {
			// from https://github.com/juj/MathGeoLib/blob/2940b99b99cfe575dd45103ef20f4019dee15b54/src/Geometry/Sphere.cpp#L759-L769
			// To enclose another sphere into this sphere, we only need to enclose two points:
			// 1) Enclose the farthest point on the other sphere into this sphere.
			// 2) Enclose the opposite point of the farthest point into this sphere.
			_toFarthestPoint.subVectors(sphere.center, this.center).normalize().multiplyScalar(sphere.radius);

			this.expandByPoint(_v1$1.copy(sphere.center).add(_toFarthestPoint));
			this.expandByPoint(_v1$1.copy(sphere.center).sub(_toFarthestPoint));
			return this;
		};

		_proto.equals = function equals(sphere) {
			return sphere.center.equals(this.center) && sphere.radius === this.radius;
		};

		_proto.clone = function clone() {
			return new this.constructor().copy(this);
		};

		return Sphere;
	}();

	var _vector$2 = /*@__PURE__*/new Vector3();

	var _segCenter = /*@__PURE__*/new Vector3();

	var _segDir = /*@__PURE__*/new Vector3();

	var _diff = /*@__PURE__*/new Vector3();

	var _edge1 = /*@__PURE__*/new Vector3();

	var _edge2 = /*@__PURE__*/new Vector3();

	var _normal = /*@__PURE__*/new Vector3();

	var Ray = /*#__PURE__*/function () {
		function Ray(origin, direction) {
			if (origin === void 0) {
				origin = new Vector3();
			}

			if (direction === void 0) {
				direction = new Vector3(0, 0, -1);
			}

			this.origin = origin;
			this.direction = direction;
		}

		var _proto = Ray.prototype;

		_proto.set = function set(origin, direction) {
			this.origin.copy(origin);
			this.direction.copy(direction);
			return this;
		};

		_proto.copy = function copy(ray) {
			this.origin.copy(ray.origin);
			this.direction.copy(ray.direction);
			return this;
		};

		_proto.at = function at(t, target) {
			return target.copy(this.direction).multiplyScalar(t).add(this.origin);
		};

		_proto.lookAt = function lookAt(v) {
			this.direction.copy(v).sub(this.origin).normalize();
			return this;
		};

		_proto.recast = function recast(t) {
			this.origin.copy(this.at(t, _vector$2));
			return this;
		};

		_proto.closestPointToPoint = function closestPointToPoint(point, target) {
			target.subVectors(point, this.origin);
			var directionDistance = target.dot(this.direction);

			if (directionDistance < 0) {
				return target.copy(this.origin);
			}

			return target.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
		};

		_proto.distanceToPoint = function distanceToPoint(point) {
			return Math.sqrt(this.distanceSqToPoint(point));
		};

		_proto.distanceSqToPoint = function distanceSqToPoint(point) {
			var directionDistance = _vector$2.subVectors(point, this.origin).dot(this.direction); // point behind the ray


			if (directionDistance < 0) {
				return this.origin.distanceToSquared(point);
			}

			_vector$2.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);

			return _vector$2.distanceToSquared(point);
		};

		_proto.distanceSqToSegment = function distanceSqToSegment(v0, v1, optionalPointOnRay, optionalPointOnSegment) {
			// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteDistRaySegment.h
			// It returns the min distance between the ray and the segment
			// defined by v0 and v1
			// It can also set two optional targets :
			// - The closest point on the ray
			// - The closest point on the segment
			_segCenter.copy(v0).add(v1).multiplyScalar(0.5);

			_segDir.copy(v1).sub(v0).normalize();

			_diff.copy(this.origin).sub(_segCenter);

			var segExtent = v0.distanceTo(v1) * 0.5;
			var a01 = -this.direction.dot(_segDir);

			var b0 = _diff.dot(this.direction);

			var b1 = -_diff.dot(_segDir);

			var c = _diff.lengthSq();

			var det = Math.abs(1 - a01 * a01);
			var s0, s1, sqrDist, extDet;

			if (det > 0) {
				// The ray and segment are not parallel.
				s0 = a01 * b1 - b0;
				s1 = a01 * b0 - b1;
				extDet = segExtent * det;

				if (s0 >= 0) {
					if (s1 >= -extDet) {
						if (s1 <= extDet) {
							// region 0
							// Minimum at interior points of ray and segment.
							var invDet = 1 / det;
							s0 *= invDet;
							s1 *= invDet;
							sqrDist = s0 * (s0 + a01 * s1 + 2 * b0) + s1 * (a01 * s0 + s1 + 2 * b1) + c;
						} else {
							// region 1
							s1 = segExtent;
							s0 = Math.max(0, -(a01 * s1 + b0));
							sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
						}
					} else {
						// region 5
						s1 = -segExtent;
						s0 = Math.max(0, -(a01 * s1 + b0));
						sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
					}
				} else {
					if (s1 <= -extDet) {
						// region 4
						s0 = Math.max(0, -(-a01 * segExtent + b0));
						s1 = s0 > 0 ? -segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
						sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
					} else if (s1 <= extDet) {
						// region 3
						s0 = 0;
						s1 = Math.min(Math.max(-segExtent, -b1), segExtent);
						sqrDist = s1 * (s1 + 2 * b1) + c;
					} else {
						// region 2
						s0 = Math.max(0, -(a01 * segExtent + b0));
						s1 = s0 > 0 ? segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
						sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
					}
				}
			} else {
				// Ray and segment are parallel.
				s1 = a01 > 0 ? -segExtent : segExtent;
				s0 = Math.max(0, -(a01 * s1 + b0));
				sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
			}

			if (optionalPointOnRay) {
				optionalPointOnRay.copy(this.direction).multiplyScalar(s0).add(this.origin);
			}

			if (optionalPointOnSegment) {
				optionalPointOnSegment.copy(_segDir).multiplyScalar(s1).add(_segCenter);
			}

			return sqrDist;
		};

		_proto.intersectSphere = function intersectSphere(sphere, target) {
			_vector$2.subVectors(sphere.center, this.origin);

			var tca = _vector$2.dot(this.direction);

			var d2 = _vector$2.dot(_vector$2) - tca * tca;
			var radius2 = sphere.radius * sphere.radius;
			if (d2 > radius2) return null;
			var thc = Math.sqrt(radius2 - d2); // t0 = first intersect point - entrance on front of sphere

			var t0 = tca - thc; // t1 = second intersect point - exit point on back of sphere

			var t1 = tca + thc; // test to see if both t0 and t1 are behind the ray - if so, return null

			if (t0 < 0 && t1 < 0) return null; // test to see if t0 is behind the ray:
			// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
			// in order to always return an intersect point that is in front of the ray.

			if (t0 < 0) return this.at(t1, target); // else t0 is in front of the ray, so return the first collision point scaled by t0

			return this.at(t0, target);
		};

		_proto.intersectsSphere = function intersectsSphere(sphere) {
			return this.distanceSqToPoint(sphere.center) <= sphere.radius * sphere.radius;
		};

		_proto.distanceToPlane = function distanceToPlane(plane) {
			var denominator = plane.normal.dot(this.direction);

			if (denominator === 0) {
				// line is coplanar, return origin
				if (plane.distanceToPoint(this.origin) === 0) {
					return 0;
				} // Null is preferable to undefined since undefined means.... it is undefined


				return null;
			}

			var t = -(this.origin.dot(plane.normal) + plane.constant) / denominator; // Return if the ray never intersects the plane

			return t >= 0 ? t : null;
		};

		_proto.intersectPlane = function intersectPlane(plane, target) {
			var t = this.distanceToPlane(plane);

			if (t === null) {
				return null;
			}

			return this.at(t, target);
		};

		_proto.intersectsPlane = function intersectsPlane(plane) {
			// check if the ray lies on the plane first
			var distToPoint = plane.distanceToPoint(this.origin);

			if (distToPoint === 0) {
				return true;
			}

			var denominator = plane.normal.dot(this.direction);

			if (denominator * distToPoint < 0) {
				return true;
			} // ray origin is behind the plane (and is pointing behind it)


			return false;
		};

		_proto.intersectBox = function intersectBox(box, target) {
			var tmin, tmax, tymin, tymax, tzmin, tzmax;
			var invdirx = 1 / this.direction.x,
					invdiry = 1 / this.direction.y,
					invdirz = 1 / this.direction.z;
			var origin = this.origin;

			if (invdirx >= 0) {
				tmin = (box.min.x - origin.x) * invdirx;
				tmax = (box.max.x - origin.x) * invdirx;
			} else {
				tmin = (box.max.x - origin.x) * invdirx;
				tmax = (box.min.x - origin.x) * invdirx;
			}

			if (invdiry >= 0) {
				tymin = (box.min.y - origin.y) * invdiry;
				tymax = (box.max.y - origin.y) * invdiry;
			} else {
				tymin = (box.max.y - origin.y) * invdiry;
				tymax = (box.min.y - origin.y) * invdiry;
			}

			if (tmin > tymax || tymin > tmax) return null; // These lines also handle the case where tmin or tmax is NaN
			// (result of 0 * Infinity). x !== x returns true if x is NaN

			if (tymin > tmin || tmin !== tmin) tmin = tymin;
			if (tymax < tmax || tmax !== tmax) tmax = tymax;

			if (invdirz >= 0) {
				tzmin = (box.min.z - origin.z) * invdirz;
				tzmax = (box.max.z - origin.z) * invdirz;
			} else {
				tzmin = (box.max.z - origin.z) * invdirz;
				tzmax = (box.min.z - origin.z) * invdirz;
			}

			if (tmin > tzmax || tzmin > tmax) return null;
			if (tzmin > tmin || tmin !== tmin) tmin = tzmin;
			if (tzmax < tmax || tmax !== tmax) tmax = tzmax; //return point closest to the ray (positive side)

			if (tmax < 0) return null;
			return this.at(tmin >= 0 ? tmin : tmax, target);
		};

		_proto.intersectsBox = function intersectsBox(box) {
			return this.intersectBox(box, _vector$2) !== null;
		};

		_proto.intersectTriangle = function intersectTriangle(a, b, c, backfaceCulling, target) {
			// Compute the offset origin, edges, and normal.
			// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h
			_edge1.subVectors(b, a);

			_edge2.subVectors(c, a);

			_normal.crossVectors(_edge1, _edge2); // Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
			// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
			//	 |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
			//	 |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
			//	 |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)


			var DdN = this.direction.dot(_normal);
			var sign;

			if (DdN > 0) {
				if (backfaceCulling) return null;
				sign = 1;
			} else if (DdN < 0) {
				sign = -1;
				DdN = -DdN;
			} else {
				return null;
			}

			_diff.subVectors(this.origin, a);

			var DdQxE2 = sign * this.direction.dot(_edge2.crossVectors(_diff, _edge2)); // b1 < 0, no intersection

			if (DdQxE2 < 0) {
				return null;
			}

			var DdE1xQ = sign * this.direction.dot(_edge1.cross(_diff)); // b2 < 0, no intersection

			if (DdE1xQ < 0) {
				return null;
			} // b1+b2 > 1, no intersection


			if (DdQxE2 + DdE1xQ > DdN) {
				return null;
			} // Line intersects triangle, check if ray does.


			var QdN = -sign * _diff.dot(_normal); // t < 0, no intersection


			if (QdN < 0) {
				return null;
			} // Ray intersects triangle.


			return this.at(QdN / DdN, target);
		};

		_proto.applyMatrix4 = function applyMatrix4(matrix4) {
			this.origin.applyMatrix4(matrix4);
			this.direction.transformDirection(matrix4);
			return this;
		};

		_proto.equals = function equals(ray) {
			return ray.origin.equals(this.origin) && ray.direction.equals(this.direction);
		};

		_proto.clone = function clone() {
			return new this.constructor().copy(this);
		};

		return Ray;
	}();

	var Matrix4 = /*#__PURE__*/function () {
		function Matrix4() {
			this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];

			if (arguments.length > 0) {
				console.error('THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.');
			}
		}

		var _proto = Matrix4.prototype;

		_proto.set = function set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
			var te = this.elements;
			te[0] = n11;
			te[4] = n12;
			te[8] = n13;
			te[12] = n14;
			te[1] = n21;
			te[5] = n22;
			te[9] = n23;
			te[13] = n24;
			te[2] = n31;
			te[6] = n32;
			te[10] = n33;
			te[14] = n34;
			te[3] = n41;
			te[7] = n42;
			te[11] = n43;
			te[15] = n44;
			return this;
		};

		_proto.identity = function identity() {
			this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
			return this;
		};

		_proto.clone = function clone() {
			return new Matrix4().fromArray(this.elements);
		};

		_proto.copy = function copy(m) {
			var te = this.elements;
			var me = m.elements;
			te[0] = me[0];
			te[1] = me[1];
			te[2] = me[2];
			te[3] = me[3];
			te[4] = me[4];
			te[5] = me[5];
			te[6] = me[6];
			te[7] = me[7];
			te[8] = me[8];
			te[9] = me[9];
			te[10] = me[10];
			te[11] = me[11];
			te[12] = me[12];
			te[13] = me[13];
			te[14] = me[14];
			te[15] = me[15];
			return this;
		};

		_proto.copyPosition = function copyPosition(m) {
			var te = this.elements,
					me = m.elements;
			te[12] = me[12];
			te[13] = me[13];
			te[14] = me[14];
			return this;
		};

		_proto.setFromMatrix3 = function setFromMatrix3(m) {
			var me = m.elements;
			this.set(me[0], me[3], me[6], 0, me[1], me[4], me[7], 0, me[2], me[5], me[8], 0, 0, 0, 0, 1);
			return this;
		};

		_proto.extractBasis = function extractBasis(xAxis, yAxis, zAxis) {
			xAxis.setFromMatrixColumn(this, 0);
			yAxis.setFromMatrixColumn(this, 1);
			zAxis.setFromMatrixColumn(this, 2);
			return this;
		};

		_proto.makeBasis = function makeBasis(xAxis, yAxis, zAxis) {
			this.set(xAxis.x, yAxis.x, zAxis.x, 0, xAxis.y, yAxis.y, zAxis.y, 0, xAxis.z, yAxis.z, zAxis.z, 0, 0, 0, 0, 1);
			return this;
		};

		_proto.extractRotation = function extractRotation(m) {
			// this method does not support reflection matrices
			var te = this.elements;
			var me = m.elements;

			var scaleX = 1 / _v1$2.setFromMatrixColumn(m, 0).length();

			var scaleY = 1 / _v1$2.setFromMatrixColumn(m, 1).length();

			var scaleZ = 1 / _v1$2.setFromMatrixColumn(m, 2).length();

			te[0] = me[0] * scaleX;
			te[1] = me[1] * scaleX;
			te[2] = me[2] * scaleX;
			te[3] = 0;
			te[4] = me[4] * scaleY;
			te[5] = me[5] * scaleY;
			te[6] = me[6] * scaleY;
			te[7] = 0;
			te[8] = me[8] * scaleZ;
			te[9] = me[9] * scaleZ;
			te[10] = me[10] * scaleZ;
			te[11] = 0;
			te[12] = 0;
			te[13] = 0;
			te[14] = 0;
			te[15] = 1;
			return this;
		};

		_proto.makeRotationFromEuler = function makeRotationFromEuler(euler) {
			if (!(euler && euler.isEuler)) {
				console.error('THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.');
			}

			var te = this.elements;
			var x = euler.x,
					y = euler.y,
					z = euler.z;
			var a = Math.cos(x),
					b = Math.sin(x);
			var c = Math.cos(y),
					d = Math.sin(y);
			var e = Math.cos(z),
					f = Math.sin(z);

			if (euler.order === 'XYZ') {
				var ae = a * e,
						af = a * f,
						be = b * e,
						bf = b * f;
				te[0] = c * e;
				te[4] = -c * f;
				te[8] = d;
				te[1] = af + be * d;
				te[5] = ae - bf * d;
				te[9] = -b * c;
				te[2] = bf - ae * d;
				te[6] = be + af * d;
				te[10] = a * c;
			} else if (euler.order === 'YXZ') {
				var ce = c * e,
						cf = c * f,
						de = d * e,
						df = d * f;
				te[0] = ce + df * b;
				te[4] = de * b - cf;
				te[8] = a * d;
				te[1] = a * f;
				te[5] = a * e;
				te[9] = -b;
				te[2] = cf * b - de;
				te[6] = df + ce * b;
				te[10] = a * c;
			} else if (euler.order === 'ZXY') {
				var _ce = c * e,
						_cf = c * f,
						_de = d * e,
						_df = d * f;

				te[0] = _ce - _df * b;
				te[4] = -a * f;
				te[8] = _de + _cf * b;
				te[1] = _cf + _de * b;
				te[5] = a * e;
				te[9] = _df - _ce * b;
				te[2] = -a * d;
				te[6] = b;
				te[10] = a * c;
			} else if (euler.order === 'ZYX') {
				var _ae = a * e,
						_af = a * f,
						_be = b * e,
						_bf = b * f;

				te[0] = c * e;
				te[4] = _be * d - _af;
				te[8] = _ae * d + _bf;
				te[1] = c * f;
				te[5] = _bf * d + _ae;
				te[9] = _af * d - _be;
				te[2] = -d;
				te[6] = b * c;
				te[10] = a * c;
			} else if (euler.order === 'YZX') {
				var ac = a * c,
						ad = a * d,
						bc = b * c,
						bd = b * d;
				te[0] = c * e;
				te[4] = bd - ac * f;
				te[8] = bc * f + ad;
				te[1] = f;
				te[5] = a * e;
				te[9] = -b * e;
				te[2] = -d * e;
				te[6] = ad * f + bc;
				te[10] = ac - bd * f;
			} else if (euler.order === 'XZY') {
				var _ac = a * c,
						_ad = a * d,
						_bc = b * c,
						_bd = b * d;

				te[0] = c * e;
				te[4] = -f;
				te[8] = d * e;
				te[1] = _ac * f + _bd;
				te[5] = a * e;
				te[9] = _ad * f - _bc;
				te[2] = _bc * f - _ad;
				te[6] = b * e;
				te[10] = _bd * f + _ac;
			} // bottom row


			te[3] = 0;
			te[7] = 0;
			te[11] = 0; // last column

			te[12] = 0;
			te[13] = 0;
			te[14] = 0;
			te[15] = 1;
			return this;
		};

		_proto.makeRotationFromQuaternion = function makeRotationFromQuaternion(q) {
			return this.compose(_zero, q, _one);
		};

		_proto.lookAt = function lookAt(eye, target, up) {
			var te = this.elements;

			_z.subVectors(eye, target);

			if (_z.lengthSq() === 0) {
				// eye and target are in the same position
				_z.z = 1;
			}

			_z.normalize();

			_x.crossVectors(up, _z);

			if (_x.lengthSq() === 0) {
				// up and z are parallel
				if (Math.abs(up.z) === 1) {
					_z.x += 0.0001;
				} else {
					_z.z += 0.0001;
				}

				_z.normalize();

				_x.crossVectors(up, _z);
			}

			_x.normalize();

			_y.crossVectors(_z, _x);

			te[0] = _x.x;
			te[4] = _y.x;
			te[8] = _z.x;
			te[1] = _x.y;
			te[5] = _y.y;
			te[9] = _z.y;
			te[2] = _x.z;
			te[6] = _y.z;
			te[10] = _z.z;
			return this;
		};

		_proto.multiply = function multiply(m, n) {
			if (n !== undefined) {
				console.warn('THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.');
				return this.multiplyMatrices(m, n);
			}

			return this.multiplyMatrices(this, m);
		};

		_proto.premultiply = function premultiply(m) {
			return this.multiplyMatrices(m, this);
		};

		_proto.multiplyMatrices = function multiplyMatrices(a, b) {
			var ae = a.elements;
			var be = b.elements;
			var te = this.elements;
			var a11 = ae[0],
					a12 = ae[4],
					a13 = ae[8],
					a14 = ae[12];
			var a21 = ae[1],
					a22 = ae[5],
					a23 = ae[9],
					a24 = ae[13];
			var a31 = ae[2],
					a32 = ae[6],
					a33 = ae[10],
					a34 = ae[14];
			var a41 = ae[3],
					a42 = ae[7],
					a43 = ae[11],
					a44 = ae[15];
			var b11 = be[0],
					b12 = be[4],
					b13 = be[8],
					b14 = be[12];
			var b21 = be[1],
					b22 = be[5],
					b23 = be[9],
					b24 = be[13];
			var b31 = be[2],
					b32 = be[6],
					b33 = be[10],
					b34 = be[14];
			var b41 = be[3],
					b42 = be[7],
					b43 = be[11],
					b44 = be[15];
			te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
			te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
			te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
			te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
			te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
			te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
			te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
			te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
			te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
			te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
			te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
			te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
			te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
			te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
			te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
			te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
			return this;
		};

		_proto.multiplyScalar = function multiplyScalar(s) {
			var te = this.elements;
			te[0] *= s;
			te[4] *= s;
			te[8] *= s;
			te[12] *= s;
			te[1] *= s;
			te[5] *= s;
			te[9] *= s;
			te[13] *= s;
			te[2] *= s;
			te[6] *= s;
			te[10] *= s;
			te[14] *= s;
			te[3] *= s;
			te[7] *= s;
			te[11] *= s;
			te[15] *= s;
			return this;
		};

		_proto.determinant = function determinant() {
			var te = this.elements;
			var n11 = te[0],
					n12 = te[4],
					n13 = te[8],
					n14 = te[12];
			var n21 = te[1],
					n22 = te[5],
					n23 = te[9],
					n24 = te[13];
			var n31 = te[2],
					n32 = te[6],
					n33 = te[10],
					n34 = te[14];
			var n41 = te[3],
					n42 = te[7],
					n43 = te[11],
					n44 = te[15]; //TODO: make this more efficient
			//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )

			return n41 * (+n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34) + n42 * (+n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31) + n43 * (+n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31) + n44 * (-n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31);
		};

		_proto.transpose = function transpose() {
			var te = this.elements;
			var tmp;
			tmp = te[1];
			te[1] = te[4];
			te[4] = tmp;
			tmp = te[2];
			te[2] = te[8];
			te[8] = tmp;
			tmp = te[6];
			te[6] = te[9];
			te[9] = tmp;
			tmp = te[3];
			te[3] = te[12];
			te[12] = tmp;
			tmp = te[7];
			te[7] = te[13];
			te[13] = tmp;
			tmp = te[11];
			te[11] = te[14];
			te[14] = tmp;
			return this;
		};

		_proto.setPosition = function setPosition(x, y, z) {
			var te = this.elements;

			if (x.isVector3) {
				te[12] = x.x;
				te[13] = x.y;
				te[14] = x.z;
			} else {
				te[12] = x;
				te[13] = y;
				te[14] = z;
			}

			return this;
		};

		_proto.invert = function invert() {
			// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
			var te = this.elements,
					n11 = te[0],
					n21 = te[1],
					n31 = te[2],
					n41 = te[3],
					n12 = te[4],
					n22 = te[5],
					n32 = te[6],
					n42 = te[7],
					n13 = te[8],
					n23 = te[9],
					n33 = te[10],
					n43 = te[11],
					n14 = te[12],
					n24 = te[13],
					n34 = te[14],
					n44 = te[15],
					t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,
					t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,
					t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,
					t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
			var det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;
			if (det === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
			var detInv = 1 / det;
			te[0] = t11 * detInv;
			te[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;
			te[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;
			te[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;
			te[4] = t12 * detInv;
			te[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;
			te[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;
			te[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;
			te[8] = t13 * detInv;
			te[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;
			te[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;
			te[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;
			te[12] = t14 * detInv;
			te[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;
			te[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;
			te[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;
			return this;
		};

		_proto.scale = function scale(v) {
			var te = this.elements;
			var x = v.x,
					y = v.y,
					z = v.z;
			te[0] *= x;
			te[4] *= y;
			te[8] *= z;
			te[1] *= x;
			te[5] *= y;
			te[9] *= z;
			te[2] *= x;
			te[6] *= y;
			te[10] *= z;
			te[3] *= x;
			te[7] *= y;
			te[11] *= z;
			return this;
		};

		_proto.getMaxScaleOnAxis = function getMaxScaleOnAxis() {
			var te = this.elements;
			var scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];
			var scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];
			var scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];
			return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
		};

		_proto.makeTranslation = function makeTranslation(x, y, z) {
			this.set(1, 0, 0, x, 0, 1, 0, y, 0, 0, 1, z, 0, 0, 0, 1);
			return this;
		};

		_proto.makeRotationX = function makeRotationX(theta) {
			var c = Math.cos(theta),
					s = Math.sin(theta);
			this.set(1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1);
			return this;
		};

		_proto.makeRotationY = function makeRotationY(theta) {
			var c = Math.cos(theta),
					s = Math.sin(theta);
			this.set(c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1);
			return this;
		};

		_proto.makeRotationZ = function makeRotationZ(theta) {
			var c = Math.cos(theta),
					s = Math.sin(theta);
			this.set(c, -s, 0, 0, s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
			return this;
		};

		_proto.makeRotationAxis = function makeRotationAxis(axis, angle) {
			// Based on http://www.gamedev.net/reference/articles/article1199.asp
			var c = Math.cos(angle);
			var s = Math.sin(angle);
			var t = 1 - c;
			var x = axis.x,
					y = axis.y,
					z = axis.z;
			var tx = t * x,
					ty = t * y;
			this.set(tx * x + c, tx * y - s * z, tx * z + s * y, 0, tx * y + s * z, ty * y + c, ty * z - s * x, 0, tx * z - s * y, ty * z + s * x, t * z * z + c, 0, 0, 0, 0, 1);
			return this;
		};

		_proto.makeScale = function makeScale(x, y, z) {
			this.set(x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0, 0, 0, 0, 1);
			return this;
		};

		_proto.makeShear = function makeShear(xy, xz, yx, yz, zx, zy) {
			this.set(1, yx, zx, 0, xy, 1, zy, 0, xz, yz, 1, 0, 0, 0, 0, 1);
			return this;
		};

		_proto.compose = function compose(position, quaternion, scale) {
			var te = this.elements;
			var x = quaternion._x,
					y = quaternion._y,
					z = quaternion._z,
					w = quaternion._w;
			var x2 = x + x,
					y2 = y + y,
					z2 = z + z;
			var xx = x * x2,
					xy = x * y2,
					xz = x * z2;
			var yy = y * y2,
					yz = y * z2,
					zz = z * z2;
			var wx = w * x2,
					wy = w * y2,
					wz = w * z2;
			var sx = scale.x,
					sy = scale.y,
					sz = scale.z;
			te[0] = (1 - (yy + zz)) * sx;
			te[1] = (xy + wz) * sx;
			te[2] = (xz - wy) * sx;
			te[3] = 0;
			te[4] = (xy - wz) * sy;
			te[5] = (1 - (xx + zz)) * sy;
			te[6] = (yz + wx) * sy;
			te[7] = 0;
			te[8] = (xz + wy) * sz;
			te[9] = (yz - wx) * sz;
			te[10] = (1 - (xx + yy)) * sz;
			te[11] = 0;
			te[12] = position.x;
			te[13] = position.y;
			te[14] = position.z;
			te[15] = 1;
			return this;
		};

		_proto.decompose = function decompose(position, quaternion, scale) {
			var te = this.elements;

			var sx = _v1$2.set(te[0], te[1], te[2]).length();

			var sy = _v1$2.set(te[4], te[5], te[6]).length();

			var sz = _v1$2.set(te[8], te[9], te[10]).length(); // if determine is negative, we need to invert one scale


			var det = this.determinant();
			if (det < 0) sx = -sx;
			position.x = te[12];
			position.y = te[13];
			position.z = te[14]; // scale the rotation part

			_m1.copy(this);

			var invSX = 1 / sx;
			var invSY = 1 / sy;
			var invSZ = 1 / sz;
			_m1.elements[0] *= invSX;
			_m1.elements[1] *= invSX;
			_m1.elements[2] *= invSX;
			_m1.elements[4] *= invSY;
			_m1.elements[5] *= invSY;
			_m1.elements[6] *= invSY;
			_m1.elements[8] *= invSZ;
			_m1.elements[9] *= invSZ;
			_m1.elements[10] *= invSZ;
			quaternion.setFromRotationMatrix(_m1);
			scale.x = sx;
			scale.y = sy;
			scale.z = sz;
			return this;
		};

		_proto.makePerspective = function makePerspective(left, right, top, bottom, near, far) {
			if (far === undefined) {
				console.warn('THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.');
			}

			var te = this.elements;
			var x = 2 * near / (right - left);
			var y = 2 * near / (top - bottom);
			var a = (right + left) / (right - left);
			var b = (top + bottom) / (top - bottom);
			var c = -(far + near) / (far - near);
			var d = -2 * far * near / (far - near);
			te[0] = x;
			te[4] = 0;
			te[8] = a;
			te[12] = 0;
			te[1] = 0;
			te[5] = y;
			te[9] = b;
			te[13] = 0;
			te[2] = 0;
			te[6] = 0;
			te[10] = c;
			te[14] = d;
			te[3] = 0;
			te[7] = 0;
			te[11] = -1;
			te[15] = 0;
			return this;
		};

		_proto.makeOrthographic = function makeOrthographic(left, right, top, bottom, near, far) {
			var te = this.elements;
			var w = 1.0 / (right - left);
			var h = 1.0 / (top - bottom);
			var p = 1.0 / (far - near);
			var x = (right + left) * w;
			var y = (top + bottom) * h;
			var z = (far + near) * p;
			te[0] = 2 * w;
			te[4] = 0;
			te[8] = 0;
			te[12] = -x;
			te[1] = 0;
			te[5] = 2 * h;
			te[9] = 0;
			te[13] = -y;
			te[2] = 0;
			te[6] = 0;
			te[10] = -2 * p;
			te[14] = -z;
			te[3] = 0;
			te[7] = 0;
			te[11] = 0;
			te[15] = 1;
			return this;
		};

		_proto.equals = function equals(matrix) {
			var te = this.elements;
			var me = matrix.elements;

			for (var i = 0; i < 16; i++) {
				if (te[i] !== me[i]) return false;
			}

			return true;
		};

		_proto.fromArray = function fromArray(array, offset) {
			if (offset === void 0) {
				offset = 0;
			}

			for (var i = 0; i < 16; i++) {
				this.elements[i] = array[i + offset];
			}

			return this;
		};

		_proto.toArray = function toArray(array, offset) {
			if (array === void 0) {
				array = [];
			}

			if (offset === void 0) {
				offset = 0;
			}

			var te = this.elements;
			array[offset] = te[0];
			array[offset + 1] = te[1];
			array[offset + 2] = te[2];
			array[offset + 3] = te[3];
			array[offset + 4] = te[4];
			array[offset + 5] = te[5];
			array[offset + 6] = te[6];
			array[offset + 7] = te[7];
			array[offset + 8] = te[8];
			array[offset + 9] = te[9];
			array[offset + 10] = te[10];
			array[offset + 11] = te[11];
			array[offset + 12] = te[12];
			array[offset + 13] = te[13];
			array[offset + 14] = te[14];
			array[offset + 15] = te[15];
			return array;
		};

		return Matrix4;
	}();

	Matrix4.prototype.isMatrix4 = true;

	var _v1$2 = /*@__PURE__*/new Vector3();

	var _m1 = /*@__PURE__*/new Matrix4();

	var _zero = /*@__PURE__*/new Vector3(0, 0, 0);

	var _one = /*@__PURE__*/new Vector3(1, 1, 1);

	var _x = /*@__PURE__*/new Vector3();

	var _y = /*@__PURE__*/new Vector3();

	var _z = /*@__PURE__*/new Vector3();

	var _matrix = /*@__PURE__*/new Matrix4();

	var _quaternion$1 = /*@__PURE__*/new Quaternion();

	var Euler = /*#__PURE__*/function () {
		function Euler(x, y, z, order) {
			if (x === void 0) {
				x = 0;
			}

			if (y === void 0) {
				y = 0;
			}

			if (z === void 0) {
				z = 0;
			}

			if (order === void 0) {
				order = Euler.DefaultOrder;
			}

			this._x = x;
			this._y = y;
			this._z = z;
			this._order = order;
		}

		var _proto = Euler.prototype;

		_proto.set = function set(x, y, z, order) {
			if (order === void 0) {
				order = this._order;
			}

			this._x = x;
			this._y = y;
			this._z = z;
			this._order = order;

			this._onChangeCallback();

			return this;
		};

		_proto.clone = function clone() {
			return new this.constructor(this._x, this._y, this._z, this._order);
		};

		_proto.copy = function copy(euler) {
			this._x = euler._x;
			this._y = euler._y;
			this._z = euler._z;
			this._order = euler._order;

			this._onChangeCallback();

			return this;
		};

		_proto.setFromRotationMatrix = function setFromRotationMatrix(m, order, update) {
			if (order === void 0) {
				order = this._order;
			}

			if (update === void 0) {
				update = true;
			}

			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
			var te = m.elements;
			var m11 = te[0],
					m12 = te[4],
					m13 = te[8];
			var m21 = te[1],
					m22 = te[5],
					m23 = te[9];
			var m31 = te[2],
					m32 = te[6],
					m33 = te[10];

			switch (order) {
				case 'XYZ':
					this._y = Math.asin(clamp(m13, -1, 1));

					if (Math.abs(m13) < 0.9999999) {
						this._x = Math.atan2(-m23, m33);
						this._z = Math.atan2(-m12, m11);
					} else {
						this._x = Math.atan2(m32, m22);
						this._z = 0;
					}

					break;

				case 'YXZ':
					this._x = Math.asin(-clamp(m23, -1, 1));

					if (Math.abs(m23) < 0.9999999) {
						this._y = Math.atan2(m13, m33);
						this._z = Math.atan2(m21, m22);
					} else {
						this._y = Math.atan2(-m31, m11);
						this._z = 0;
					}

					break;

				case 'ZXY':
					this._x = Math.asin(clamp(m32, -1, 1));

					if (Math.abs(m32) < 0.9999999) {
						this._y = Math.atan2(-m31, m33);
						this._z = Math.atan2(-m12, m22);
					} else {
						this._y = 0;
						this._z = Math.atan2(m21, m11);
					}

					break;

				case 'ZYX':
					this._y = Math.asin(-clamp(m31, -1, 1));

					if (Math.abs(m31) < 0.9999999) {
						this._x = Math.atan2(m32, m33);
						this._z = Math.atan2(m21, m11);
					} else {
						this._x = 0;
						this._z = Math.atan2(-m12, m22);
					}

					break;

				case 'YZX':
					this._z = Math.asin(clamp(m21, -1, 1));

					if (Math.abs(m21) < 0.9999999) {
						this._x = Math.atan2(-m23, m22);
						this._y = Math.atan2(-m31, m11);
					} else {
						this._x = 0;
						this._y = Math.atan2(m13, m33);
					}

					break;

				case 'XZY':
					this._z = Math.asin(-clamp(m12, -1, 1));

					if (Math.abs(m12) < 0.9999999) {
						this._x = Math.atan2(m32, m22);
						this._y = Math.atan2(m13, m11);
					} else {
						this._x = Math.atan2(-m23, m33);
						this._y = 0;
					}

					break;

				default:
					console.warn('THREE.Euler: .setFromRotationMatrix() encountered an unknown order: ' + order);
			}

			this._order = order;
			if (update === true) this._onChangeCallback();
			return this;
		};

		_proto.setFromQuaternion = function setFromQuaternion(q, order, update) {
			_matrix.makeRotationFromQuaternion(q);

			return this.setFromRotationMatrix(_matrix, order, update);
		};

		_proto.setFromVector3 = function setFromVector3(v, order) {
			if (order === void 0) {
				order = this._order;
			}

			return this.set(v.x, v.y, v.z, order);
		};

		_proto.reorder = function reorder(newOrder) {
			// WARNING: this discards revolution information -bhouston
			_quaternion$1.setFromEuler(this);

			return this.setFromQuaternion(_quaternion$1, newOrder);
		};

		_proto.equals = function equals(euler) {
			return euler._x === this._x && euler._y === this._y && euler._z === this._z && euler._order === this._order;
		};

		_proto.fromArray = function fromArray(array) {
			this._x = array[0];
			this._y = array[1];
			this._z = array[2];
			if (array[3] !== undefined) this._order = array[3];

			this._onChangeCallback();

			return this;
		};

		_proto.toArray = function toArray(array, offset) {
			if (array === void 0) {
				array = [];
			}

			if (offset === void 0) {
				offset = 0;
			}

			array[offset] = this._x;
			array[offset + 1] = this._y;
			array[offset + 2] = this._z;
			array[offset + 3] = this._order;
			return array;
		};

		_proto.toVector3 = function toVector3(optionalResult) {
			if (optionalResult) {
				return optionalResult.set(this._x, this._y, this._z);
			} else {
				return new Vector3(this._x, this._y, this._z);
			}
		};

		_proto._onChange = function _onChange(callback) {
			this._onChangeCallback = callback;
			return this;
		};

		_proto._onChangeCallback = function _onChangeCallback() {};

		_createClass(Euler, [{
			key: "x",
			get: function get() {
				return this._x;
			},
			set: function set(value) {
				this._x = value;

				this._onChangeCallback();
			}
		}, {
			key: "y",
			get: function get() {
				return this._y;
			},
			set: function set(value) {
				this._y = value;

				this._onChangeCallback();
			}
		}, {
			key: "z",
			get: function get() {
				return this._z;
			},
			set: function set(value) {
				this._z = value;

				this._onChangeCallback();
			}
		}, {
			key: "order",
			get: function get() {
				return this._order;
			},
			set: function set(value) {
				this._order = value;

				this._onChangeCallback();
			}
		}]);

		return Euler;
	}();

	Euler.prototype.isEuler = true;
	Euler.DefaultOrder = 'XYZ';
	Euler.RotationOrders = ['XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX'];

	var Layers = /*#__PURE__*/function () {
		function Layers() {
			this.mask = 1 | 0;
		}

		var _proto = Layers.prototype;

		_proto.set = function set(channel) {
			this.mask = 1 << channel | 0;
		};

		_proto.enable = function enable(channel) {
			this.mask |= 1 << channel | 0;
		};

		_proto.enableAll = function enableAll() {
			this.mask = 0xffffffff | 0;
		};

		_proto.toggle = function toggle(channel) {
			this.mask ^= 1 << channel | 0;
		};

		_proto.disable = function disable(channel) {
			this.mask &= ~(1 << channel | 0);
		};

		_proto.disableAll = function disableAll() {
			this.mask = 0;
		};

		_proto.test = function test(layers) {
			return (this.mask & layers.mask) !== 0;
		};

		return Layers;
	}();

	var _object3DId = 0;

	var _v1$3 = /*@__PURE__*/new Vector3();

	var _q1 = /*@__PURE__*/new Quaternion();

	var _m1$1 = /*@__PURE__*/new Matrix4();

	var _target = /*@__PURE__*/new Vector3();

	var _position = /*@__PURE__*/new Vector3();

	var _scale = /*@__PURE__*/new Vector3();

	var _quaternion$2 = /*@__PURE__*/new Quaternion();

	var _xAxis = /*@__PURE__*/new Vector3(1, 0, 0);

	var _yAxis = /*@__PURE__*/new Vector3(0, 1, 0);

	var _zAxis = /*@__PURE__*/new Vector3(0, 0, 1);

	var _addedEvent = {
		type: 'added'
	};
	var _removedEvent = {
		type: 'removed'
	};

	var Object3D = /*#__PURE__*/function (_EventDispatcher) {
		_inheritsLoose(Object3D, _EventDispatcher);

		function Object3D() {
			var _this;

			_this = _EventDispatcher.call(this) || this;
			Object.defineProperty(_assertThisInitialized(_this), 'id', {
				value: _object3DId++
			});
			_this.uuid = generateUUID();
			_this.name = '';
			_this.type = 'Object3D';
			_this.parent = null;
			_this.children = [];
			_this.up = Object3D.DefaultUp.clone();
			var position = new Vector3();
			var rotation = new Euler();
			var quaternion = new Quaternion();
			var scale = new Vector3(1, 1, 1);

			function onRotationChange() {
				quaternion.setFromEuler(rotation, false);
			}

			function onQuaternionChange() {
				rotation.setFromQuaternion(quaternion, undefined, false);
			}

			rotation._onChange(onRotationChange);

			quaternion._onChange(onQuaternionChange);

			Object.defineProperties(_assertThisInitialized(_this), {
				position: {
					configurable: true,
					enumerable: true,
					value: position
				},
				rotation: {
					configurable: true,
					enumerable: true,
					value: rotation
				},
				quaternion: {
					configurable: true,
					enumerable: true,
					value: quaternion
				},
				scale: {
					configurable: true,
					enumerable: true,
					value: scale
				},
				modelViewMatrix: {
					value: new Matrix4()
				},
				normalMatrix: {
					value: new Matrix3()
				}
			});
			_this.matrix = new Matrix4();
			_this.matrixWorld = new Matrix4();
			_this.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;
			_this.matrixWorldNeedsUpdate = false;
			_this.layers = new Layers();
			_this.visible = true;
			_this.castShadow = false;
			_this.receiveShadow = false;
			_this.frustumCulled = true;
			_this.renderOrder = 0;
			_this.animations = [];
			_this.userData = {};
			return _this;
		}

		var _proto = Object3D.prototype;

		_proto.onBeforeRender = function onBeforeRender()
		/* renderer, scene, camera, geometry, material, group */
		{};

		_proto.onAfterRender = function onAfterRender()
		/* renderer, scene, camera, geometry, material, group */
		{};

		_proto.applyMatrix4 = function applyMatrix4(matrix) {
			if (this.matrixAutoUpdate) this.updateMatrix();
			this.matrix.premultiply(matrix);
			this.matrix.decompose(this.position, this.quaternion, this.scale);
		};

		_proto.applyQuaternion = function applyQuaternion(q) {
			this.quaternion.premultiply(q);
			return this;
		};

		_proto.setRotationFromAxisAngle = function setRotationFromAxisAngle(axis, angle) {
			// assumes axis is normalized
			this.quaternion.setFromAxisAngle(axis, angle);
		};

		_proto.setRotationFromEuler = function setRotationFromEuler(euler) {
			this.quaternion.setFromEuler(euler, true);
		};

		_proto.setRotationFromMatrix = function setRotationFromMatrix(m) {
			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
			this.quaternion.setFromRotationMatrix(m);
		};

		_proto.setRotationFromQuaternion = function setRotationFromQuaternion(q) {
			// assumes q is normalized
			this.quaternion.copy(q);
		};

		_proto.rotateOnAxis = function rotateOnAxis(axis, angle) {
			// rotate object on axis in object space
			// axis is assumed to be normalized
			_q1.setFromAxisAngle(axis, angle);

			this.quaternion.multiply(_q1);
			return this;
		};

		_proto.rotateOnWorldAxis = function rotateOnWorldAxis(axis, angle) {
			// rotate object on axis in world space
			// axis is assumed to be normalized
			// method assumes no rotated parent
			_q1.setFromAxisAngle(axis, angle);

			this.quaternion.premultiply(_q1);
			return this;
		};

		_proto.rotateX = function rotateX(angle) {
			return this.rotateOnAxis(_xAxis, angle);
		};

		_proto.rotateY = function rotateY(angle) {
			return this.rotateOnAxis(_yAxis, angle);
		};

		_proto.rotateZ = function rotateZ(angle) {
			return this.rotateOnAxis(_zAxis, angle);
		};

		_proto.translateOnAxis = function translateOnAxis(axis, distance) {
			// translate object by distance along axis in object space
			// axis is assumed to be normalized
			_v1$3.copy(axis).applyQuaternion(this.quaternion);

			this.position.add(_v1$3.multiplyScalar(distance));
			return this;
		};

		_proto.translateX = function translateX(distance) {
			return this.translateOnAxis(_xAxis, distance);
		};

		_proto.translateY = function translateY(distance) {
			return this.translateOnAxis(_yAxis, distance);
		};

		_proto.translateZ = function translateZ(distance) {
			return this.translateOnAxis(_zAxis, distance);
		};

		_proto.localToWorld = function localToWorld(vector) {
			return vector.applyMatrix4(this.matrixWorld);
		};

		_proto.worldToLocal = function worldToLocal(vector) {
			return vector.applyMatrix4(_m1$1.copy(this.matrixWorld).invert());
		};

		_proto.lookAt = function lookAt(x, y, z) {
			// This method does not support objects having non-uniformly-scaled parent(s)
			if (x.isVector3) {
				_target.copy(x);
			} else {
				_target.set(x, y, z);
			}

			var parent = this.parent;
			this.updateWorldMatrix(true, false);

			_position.setFromMatrixPosition(this.matrixWorld);

			if (this.isCamera || this.isLight) {
				_m1$1.lookAt(_position, _target, this.up);
			} else {
				_m1$1.lookAt(_target, _position, this.up);
			}

			this.quaternion.setFromRotationMatrix(_m1$1);

			if (parent) {
				_m1$1.extractRotation(parent.matrixWorld);

				_q1.setFromRotationMatrix(_m1$1);

				this.quaternion.premultiply(_q1.invert());
			}
		};

		_proto.add = function add(object) {
			if (arguments.length > 1) {
				for (var i = 0; i < arguments.length; i++) {
					this.add(arguments[i]);
				}

				return this;
			}

			if (object === this) {
				console.error('THREE.Object3D.add: object can\'t be added as a child of itself.', object);
				return this;
			}

			if (object && object.isObject3D) {
				if (object.parent !== null) {
					object.parent.remove(object);
				}

				object.parent = this;
				this.children.push(object);
				object.dispatchEvent(_addedEvent);
			} else {
				console.error('THREE.Object3D.add: object not an instance of THREE.Object3D.', object);
			}

			return this;
		};

		_proto.remove = function remove(object) {
			if (arguments.length > 1) {
				for (var i = 0; i < arguments.length; i++) {
					this.remove(arguments[i]);
				}

				return this;
			}

			var index = this.children.indexOf(object);

			if (index !== -1) {
				object.parent = null;
				this.children.splice(index, 1);
				object.dispatchEvent(_removedEvent);
			}

			return this;
		};

		_proto.removeFromParent = function removeFromParent() {
			var parent = this.parent;

			if (parent !== null) {
				parent.remove(this);
			}

			return this;
		};

		_proto.clear = function clear() {
			for (var i = 0; i < this.children.length; i++) {
				var object = this.children[i];
				object.parent = null;
				object.dispatchEvent(_removedEvent);
			}

			this.children.length = 0;
			return this;
		};

		_proto.attach = function attach(object) {
			// adds object as a child of this, while maintaining the object's world transform
			this.updateWorldMatrix(true, false);

			_m1$1.copy(this.matrixWorld).invert();

			if (object.parent !== null) {
				object.parent.updateWorldMatrix(true, false);

				_m1$1.multiply(object.parent.matrixWorld);
			}

			object.applyMatrix4(_m1$1);
			this.add(object);
			object.updateWorldMatrix(false, true);
			return this;
		};

		_proto.getObjectById = function getObjectById(id) {
			return this.getObjectByProperty('id', id);
		};

		_proto.getObjectByName = function getObjectByName(name) {
			return this.getObjectByProperty('name', name);
		};

		_proto.getObjectByProperty = function getObjectByProperty(name, value) {
			if (this[name] === value) return this;

			for (var i = 0, l = this.children.length; i < l; i++) {
				var child = this.children[i];
				var object = child.getObjectByProperty(name, value);

				if (object !== undefined) {
					return object;
				}
			}

			return undefined;
		};

		_proto.getWorldPosition = function getWorldPosition(target) {
			this.updateWorldMatrix(true, false);
			return target.setFromMatrixPosition(this.matrixWorld);
		};

		_proto.getWorldQuaternion = function getWorldQuaternion(target) {
			this.updateWorldMatrix(true, false);
			this.matrixWorld.decompose(_position, target, _scale);
			return target;
		};

		_proto.getWorldScale = function getWorldScale(target) {
			this.updateWorldMatrix(true, false);
			this.matrixWorld.decompose(_position, _quaternion$2, target);
			return target;
		};

		_proto.getWorldDirection = function getWorldDirection(target) {
			this.updateWorldMatrix(true, false);
			var e = this.matrixWorld.elements;
			return target.set(e[8], e[9], e[10]).normalize();
		};

		_proto.raycast = function raycast() {};

		_proto.traverse = function traverse(callback) {
			callback(this);
			var children = this.children;

			for (var i = 0, l = children.length; i < l; i++) {
				children[i].traverse(callback);
			}
		};

		_proto.traverseVisible = function traverseVisible(callback) {
			if (this.visible === false) return;
			callback(this);
			var children = this.children;

			for (var i = 0, l = children.length; i < l; i++) {
				children[i].traverseVisible(callback);
			}
		};

		_proto.traverseAncestors = function traverseAncestors(callback) {
			var parent = this.parent;

			if (parent !== null) {
				callback(parent);
				parent.traverseAncestors(callback);
			}
		};

		_proto.updateMatrix = function updateMatrix() {
			this.matrix.compose(this.position, this.quaternion, this.scale);
			this.matrixWorldNeedsUpdate = true;
		};

		_proto.updateMatrixWorld = function updateMatrixWorld(force) {
			if (this.matrixAutoUpdate) this.updateMatrix();

			if (this.matrixWorldNeedsUpdate || force) {
				if (this.parent === null) {
					this.matrixWorld.copy(this.matrix);
				} else {
					this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
				}

				this.matrixWorldNeedsUpdate = false;
				force = true;
			} // update children


			var children = this.children;

			for (var i = 0, l = children.length; i < l; i++) {
				children[i].updateMatrixWorld(force);
			}
		};

		_proto.updateWorldMatrix = function updateWorldMatrix(updateParents, updateChildren) {
			var parent = this.parent;

			if (updateParents === true && parent !== null) {
				parent.updateWorldMatrix(true, false);
			}

			if (this.matrixAutoUpdate) this.updateMatrix();

			if (this.parent === null) {
				this.matrixWorld.copy(this.matrix);
			} else {
				this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
			} // update children


			if (updateChildren === true) {
				var children = this.children;

				for (var i = 0, l = children.length; i < l; i++) {
					children[i].updateWorldMatrix(false, true);
				}
			}
		};

		_proto.toJSON = function toJSON(meta) {
			// meta is a string when called from JSON.stringify
			var isRootObject = meta === undefined || typeof meta === 'string';
			var output = {}; // meta is a hash used to collect geometries, materials.
			// not providing it implies that this is the root object
			// being serialized.

			if (isRootObject) {
				// initialize meta obj
				meta = {
					geometries: {},
					materials: {},
					textures: {},
					images: {},
					shapes: {},
					skeletons: {},
					animations: {}
				};
				output.metadata = {
					version: 4.5,
					type: 'Object',
					generator: 'Object3D.toJSON'
				};
			} // standard Object3D serialization


			var object = {};
			object.uuid = this.uuid;
			object.type = this.type;
			if (this.name !== '') object.name = this.name;
			if (this.castShadow === true) object.castShadow = true;
			if (this.receiveShadow === true) object.receiveShadow = true;
			if (this.visible === false) object.visible = false;
			if (this.frustumCulled === false) object.frustumCulled = false;
			if (this.renderOrder !== 0) object.renderOrder = this.renderOrder;
			if (JSON.stringify(this.userData) !== '{}') object.userData = this.userData;
			object.layers = this.layers.mask;
			object.matrix = this.matrix.toArray();
			if (this.matrixAutoUpdate === false) object.matrixAutoUpdate = false; // object specific properties

			if (this.isInstancedMesh) {
				object.type = 'InstancedMesh';
				object.count = this.count;
				object.instanceMatrix = this.instanceMatrix.toJSON();
				if (this.instanceColor !== null) object.instanceColor = this.instanceColor.toJSON();
			} //


			function serialize(library, element) {
				if (library[element.uuid] === undefined) {
					library[element.uuid] = element.toJSON(meta);
				}

				return element.uuid;
			}

			if (this.isScene) {
				if (this.background) {
					if (this.background.isColor) {
						object.background = this.background.toJSON();
					} else if (this.background.isTexture) {
						object.background = this.background.toJSON(meta).uuid;
					}
				}

				if (this.environment && this.environment.isTexture) {
					object.environment = this.environment.toJSON(meta).uuid;
				}
			} else if (this.isMesh || this.isLine || this.isPoints) {
				object.geometry = serialize(meta.geometries, this.geometry);
				var parameters = this.geometry.parameters;

				if (parameters !== undefined && parameters.shapes !== undefined) {
					var shapes = parameters.shapes;

					if (Array.isArray(shapes)) {
						for (var i = 0, l = shapes.length; i < l; i++) {
							var shape = shapes[i];
							serialize(meta.shapes, shape);
						}
					} else {
						serialize(meta.shapes, shapes);
					}
				}
			}

			if (this.isSkinnedMesh) {
				object.bindMode = this.bindMode;
				object.bindMatrix = this.bindMatrix.toArray();

				if (this.skeleton !== undefined) {
					serialize(meta.skeletons, this.skeleton);
					object.skeleton = this.skeleton.uuid;
				}
			}

			if (this.material !== undefined) {
				if (Array.isArray(this.material)) {
					var uuids = [];

					for (var _i = 0, _l = this.material.length; _i < _l; _i++) {
						uuids.push(serialize(meta.materials, this.material[_i]));
					}

					object.material = uuids;
				} else {
					object.material = serialize(meta.materials, this.material);
				}
			} //


			if (this.children.length > 0) {
				object.children = [];

				for (var _i2 = 0; _i2 < this.children.length; _i2++) {
					object.children.push(this.children[_i2].toJSON(meta).object);
				}
			} //


			if (this.animations.length > 0) {
				object.animations = [];

				for (var _i3 = 0; _i3 < this.animations.length; _i3++) {
					var animation = this.animations[_i3];
					object.animations.push(serialize(meta.animations, animation));
				}
			}

			if (isRootObject) {
				var geometries = extractFromCache(meta.geometries);
				var materials = extractFromCache(meta.materials);
				var textures = extractFromCache(meta.textures);
				var images = extractFromCache(meta.images);

				var _shapes = extractFromCache(meta.shapes);

				var skeletons = extractFromCache(meta.skeletons);
				var animations = extractFromCache(meta.animations);
				if (geometries.length > 0) output.geometries = geometries;
				if (materials.length > 0) output.materials = materials;
				if (textures.length > 0) output.textures = textures;
				if (images.length > 0) output.images = images;
				if (_shapes.length > 0) output.shapes = _shapes;
				if (skeletons.length > 0) output.skeletons = skeletons;
				if (animations.length > 0) output.animations = animations;
			}

			output.object = object;
			return output; // extract data from the cache hash
			// remove metadata on each item
			// and return as array

			function extractFromCache(cache) {
				var values = [];

				for (var key in cache) {
					var data = cache[key];
					delete data.metadata;
					values.push(data);
				}

				return values;
			}
		};

		_proto.clone = function clone(recursive) {
			return new this.constructor().copy(this, recursive);
		};

		_proto.copy = function copy(source, recursive) {
			if (recursive === void 0) {
				recursive = true;
			}

			this.name = source.name;
			this.up.copy(source.up);
			this.position.copy(source.position);
			this.rotation.order = source.rotation.order;
			this.quaternion.copy(source.quaternion);
			this.scale.copy(source.scale);
			this.matrix.copy(source.matrix);
			this.matrixWorld.copy(source.matrixWorld);
			this.matrixAutoUpdate = source.matrixAutoUpdate;
			this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;
			this.layers.mask = source.layers.mask;
			this.visible = source.visible;
			this.castShadow = source.castShadow;
			this.receiveShadow = source.receiveShadow;
			this.frustumCulled = source.frustumCulled;
			this.renderOrder = source.renderOrder;
			this.userData = JSON.parse(JSON.stringify(source.userData));

			if (recursive === true) {
				for (var i = 0; i < source.children.length; i++) {
					var child = source.children[i];
					this.add(child.clone());
				}
			}

			return this;
		};

		return Object3D;
	}(EventDispatcher);

	Object3D.DefaultUp = new Vector3(0, 1, 0);
	Object3D.DefaultMatrixAutoUpdate = true;
	Object3D.prototype.isObject3D = true;

	var _v0$1 = /*@__PURE__*/new Vector3();

	var _v1$4 = /*@__PURE__*/new Vector3();

	var _v2$1 = /*@__PURE__*/new Vector3();

	var _v3 = /*@__PURE__*/new Vector3();

	var _vab = /*@__PURE__*/new Vector3();

	var _vac = /*@__PURE__*/new Vector3();

	var _vbc = /*@__PURE__*/new Vector3();

	var _vap = /*@__PURE__*/new Vector3();

	var _vbp = /*@__PURE__*/new Vector3();

	var _vcp = /*@__PURE__*/new Vector3();

	var Triangle = /*#__PURE__*/function () {
		function Triangle(a, b, c) {
			if (a === void 0) {
				a = new Vector3();
			}

			if (b === void 0) {
				b = new Vector3();
			}

			if (c === void 0) {
				c = new Vector3();
			}

			this.a = a;
			this.b = b;
			this.c = c;
		}

		Triangle.getNormal = function getNormal(a, b, c, target) {
			target.subVectors(c, b);

			_v0$1.subVectors(a, b);

			target.cross(_v0$1);
			var targetLengthSq = target.lengthSq();

			if (targetLengthSq > 0) {
				return target.multiplyScalar(1 / Math.sqrt(targetLengthSq));
			}

			return target.set(0, 0, 0);
		} // static/instance method to calculate barycentric coordinates
		// based on: http://www.blackpawn.com/texts/pointinpoly/default.html
		;

		Triangle.getBarycoord = function getBarycoord(point, a, b, c, target) {
			_v0$1.subVectors(c, a);

			_v1$4.subVectors(b, a);

			_v2$1.subVectors(point, a);

			var dot00 = _v0$1.dot(_v0$1);

			var dot01 = _v0$1.dot(_v1$4);

			var dot02 = _v0$1.dot(_v2$1);

			var dot11 = _v1$4.dot(_v1$4);

			var dot12 = _v1$4.dot(_v2$1);

			var denom = dot00 * dot11 - dot01 * dot01; // collinear or singular triangle

			if (denom === 0) {
				// arbitrary location outside of triangle?
				// not sure if this is the best idea, maybe should be returning undefined
				return target.set(-2, -1, -1);
			}

			var invDenom = 1 / denom;
			var u = (dot11 * dot02 - dot01 * dot12) * invDenom;
			var v = (dot00 * dot12 - dot01 * dot02) * invDenom; // barycentric coordinates must always sum to 1

			return target.set(1 - u - v, v, u);
		};

		Triangle.containsPoint = function containsPoint(point, a, b, c) {
			this.getBarycoord(point, a, b, c, _v3);
			return _v3.x >= 0 && _v3.y >= 0 && _v3.x + _v3.y <= 1;
		};

		Triangle.getUV = function getUV(point, p1, p2, p3, uv1, uv2, uv3, target) {
			this.getBarycoord(point, p1, p2, p3, _v3);
			target.set(0, 0);
			target.addScaledVector(uv1, _v3.x);
			target.addScaledVector(uv2, _v3.y);
			target.addScaledVector(uv3, _v3.z);
			return target;
		};

		Triangle.isFrontFacing = function isFrontFacing(a, b, c, direction) {
			_v0$1.subVectors(c, b);

			_v1$4.subVectors(a, b); // strictly front facing


			return _v0$1.cross(_v1$4).dot(direction) < 0 ? true : false;
		};

		var _proto = Triangle.prototype;

		_proto.set = function set(a, b, c) {
			this.a.copy(a);
			this.b.copy(b);
			this.c.copy(c);
			return this;
		};

		_proto.setFromPointsAndIndices = function setFromPointsAndIndices(points, i0, i1, i2) {
			this.a.copy(points[i0]);
			this.b.copy(points[i1]);
			this.c.copy(points[i2]);
			return this;
		};

		_proto.setFromAttributeAndIndices = function setFromAttributeAndIndices(attribute, i0, i1, i2) {
			this.a.fromBufferAttribute(attribute, i0);
			this.b.fromBufferAttribute(attribute, i1);
			this.c.fromBufferAttribute(attribute, i2);
			return this;
		};

		_proto.clone = function clone() {
			return new this.constructor().copy(this);
		};

		_proto.copy = function copy(triangle) {
			this.a.copy(triangle.a);
			this.b.copy(triangle.b);
			this.c.copy(triangle.c);
			return this;
		};

		_proto.getArea = function getArea() {
			_v0$1.subVectors(this.c, this.b);

			_v1$4.subVectors(this.a, this.b);

			return _v0$1.cross(_v1$4).length() * 0.5;
		};

		_proto.getMidpoint = function getMidpoint(target) {
			return target.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
		};

		_proto.getNormal = function getNormal(target) {
			return Triangle.getNormal(this.a, this.b, this.c, target);
		};

		_proto.getPlane = function getPlane(target) {
			return target.setFromCoplanarPoints(this.a, this.b, this.c);
		};

		_proto.getBarycoord = function getBarycoord(point, target) {
			return Triangle.getBarycoord(point, this.a, this.b, this.c, target);
		};

		_proto.getUV = function getUV(point, uv1, uv2, uv3, target) {
			return Triangle.getUV(point, this.a, this.b, this.c, uv1, uv2, uv3, target);
		};

		_proto.containsPoint = function containsPoint(point) {
			return Triangle.containsPoint(point, this.a, this.b, this.c);
		};

		_proto.isFrontFacing = function isFrontFacing(direction) {
			return Triangle.isFrontFacing(this.a, this.b, this.c, direction);
		};

		_proto.intersectsBox = function intersectsBox(box) {
			return box.intersectsTriangle(this);
		};

		_proto.closestPointToPoint = function closestPointToPoint(p, target) {
			var a = this.a,
					b = this.b,
					c = this.c;
			var v, w; // algorithm thanks to Real-Time Collision Detection by Christer Ericson,
			// published by Morgan Kaufmann Publishers, (c) 2005 Elsevier Inc.,
			// under the accompanying license; see chapter 5.1.5 for detailed explanation.
			// basically, we're distinguishing which of the voronoi regions of the triangle
			// the point lies in with the minimum amount of redundant computation.

			_vab.subVectors(b, a);

			_vac.subVectors(c, a);

			_vap.subVectors(p, a);

			var d1 = _vab.dot(_vap);

			var d2 = _vac.dot(_vap);

			if (d1 <= 0 && d2 <= 0) {
				// vertex region of A; barycentric coords (1, 0, 0)
				return target.copy(a);
			}

			_vbp.subVectors(p, b);

			var d3 = _vab.dot(_vbp);

			var d4 = _vac.dot(_vbp);

			if (d3 >= 0 && d4 <= d3) {
				// vertex region of B; barycentric coords (0, 1, 0)
				return target.copy(b);
			}

			var vc = d1 * d4 - d3 * d2;

			if (vc <= 0 && d1 >= 0 && d3 <= 0) {
				v = d1 / (d1 - d3); // edge region of AB; barycentric coords (1-v, v, 0)

				return target.copy(a).addScaledVector(_vab, v);
			}

			_vcp.subVectors(p, c);

			var d5 = _vab.dot(_vcp);

			var d6 = _vac.dot(_vcp);

			if (d6 >= 0 && d5 <= d6) {
				// vertex region of C; barycentric coords (0, 0, 1)
				return target.copy(c);
			}

			var vb = d5 * d2 - d1 * d6;

			if (vb <= 0 && d2 >= 0 && d6 <= 0) {
				w = d2 / (d2 - d6); // edge region of AC; barycentric coords (1-w, 0, w)

				return target.copy(a).addScaledVector(_vac, w);
			}

			var va = d3 * d6 - d5 * d4;

			if (va <= 0 && d4 - d3 >= 0 && d5 - d6 >= 0) {
				_vbc.subVectors(c, b);

				w = (d4 - d3) / (d4 - d3 + (d5 - d6)); // edge region of BC; barycentric coords (0, 1-w, w)

				return target.copy(b).addScaledVector(_vbc, w); // edge region of BC
			} // face region


			var denom = 1 / (va + vb + vc); // u = va * denom

			v = vb * denom;
			w = vc * denom;
			return target.copy(a).addScaledVector(_vab, v).addScaledVector(_vac, w);
		};

		_proto.equals = function equals(triangle) {
			return triangle.a.equals(this.a) && triangle.b.equals(this.b) && triangle.c.equals(this.c);
		};

		return Triangle;
	}();

	var materialId = 0;

	var Material = /*#__PURE__*/function (_EventDispatcher) {
		_inheritsLoose(Material, _EventDispatcher);

		function Material() {
			var _this;

			_this = _EventDispatcher.call(this) || this;
			Object.defineProperty(_assertThisInitialized(_this), 'id', {
				value: materialId++
			});
			_this.uuid = generateUUID();
			_this.name = '';
			_this.type = 'Material';
			_this.fog = true;
			_this.blending = NormalBlending;
			_this.side = FrontSide;
			_this.vertexColors = false;
			_this.opacity = 1;
			_this.format = RGBAFormat;
			_this.transparent = false;
			_this.blendSrc = SrcAlphaFactor;
			_this.blendDst = OneMinusSrcAlphaFactor;
			_this.blendEquation = AddEquation;
			_this.blendSrcAlpha = null;
			_this.blendDstAlpha = null;
			_this.blendEquationAlpha = null;
			_this.depthFunc = LessEqualDepth;
			_this.depthTest = true;
			_this.depthWrite = true;
			_this.stencilWriteMask = 0xff;
			_this.stencilFunc = AlwaysStencilFunc;
			_this.stencilRef = 0;
			_this.stencilFuncMask = 0xff;
			_this.stencilFail = KeepStencilOp;
			_this.stencilZFail = KeepStencilOp;
			_this.stencilZPass = KeepStencilOp;
			_this.stencilWrite = false;
			_this.clippingPlanes = null;
			_this.clipIntersection = false;
			_this.clipShadows = false;
			_this.shadowSide = null;
			_this.colorWrite = true;
			_this.precision = null; // override the renderer's default precision for this material

			_this.polygonOffset = false;
			_this.polygonOffsetFactor = 0;
			_this.polygonOffsetUnits = 0;
			_this.dithering = false;
			_this.alphaToCoverage = false;
			_this.premultipliedAlpha = false;
			_this.visible = true;
			_this.toneMapped = true;
			_this.userData = {};
			_this.version = 0;
			_this._alphaTest = 0;
			return _this;
		}

		var _proto = Material.prototype;

		_proto.onBuild = function onBuild()
		/* shaderobject, renderer */
		{};

		_proto.onBeforeRender = function onBeforeRender()
		/* renderer, scene, camera, geometry, object, group */
		{};

		_proto.onBeforeCompile = function onBeforeCompile()
		/* shaderobject, renderer */
		{};

		_proto.customProgramCacheKey = function customProgramCacheKey() {
			return this.onBeforeCompile.toString();
		};

		_proto.setValues = function setValues(values) {
			if (values === undefined) return;

			for (var key in values) {
				var newValue = values[key];

				if (newValue === undefined) {
					console.warn('THREE.Material: \'' + key + '\' parameter is undefined.');
					continue;
				} // for backward compatability if shading is set in the constructor


				if (key === 'shading') {
					console.warn('THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.');
					this.flatShading = newValue === FlatShading ? true : false;
					continue;
				}

				var currentValue = this[key];

				if (currentValue === undefined) {
					console.warn('THREE.' + this.type + ': \'' + key + '\' is not a property of this material.');
					continue;
				}

				if (currentValue && currentValue.isColor) {
					currentValue.set(newValue);
				} else if (currentValue && currentValue.isVector3 && newValue && newValue.isVector3) {
					currentValue.copy(newValue);
				} else {
					this[key] = newValue;
				}
			}
		};

		_proto.toJSON = function toJSON(meta) {
			var isRoot = meta === undefined || typeof meta === 'string';

			if (isRoot) {
				meta = {
					textures: {},
					images: {}
				};
			}

			var data = {
				metadata: {
					version: 4.5,
					type: 'Material',
					generator: 'Material.toJSON'
				}
			}; // standard Material serialization

			data.uuid = this.uuid;
			data.type = this.type;
			if (this.name !== '') data.name = this.name;
			if (this.color && this.color.isColor) data.color = this.color.getHex();
			if (this.roughness !== undefined) data.roughness = this.roughness;
			if (this.metalness !== undefined) data.metalness = this.metalness;
			if (this.sheen !== undefined) data.sheen = this.sheen;
			if (this.sheenTint && this.sheenTint.isColor) data.sheenTint = this.sheenTint.getHex();
			if (this.sheenRoughness !== undefined) data.sheenRoughness = this.sheenRoughness;
			if (this.emissive && this.emissive.isColor) data.emissive = this.emissive.getHex();
			if (this.emissiveIntensity && this.emissiveIntensity !== 1) data.emissiveIntensity = this.emissiveIntensity;
			if (this.specular && this.specular.isColor) data.specular = this.specular.getHex();
			if (this.specularIntensity !== undefined) data.specularIntensity = this.specularIntensity;
			if (this.specularTint && this.specularTint.isColor) data.specularTint = this.specularTint.getHex();
			if (this.shininess !== undefined) data.shininess = this.shininess;
			if (this.clearcoat !== undefined) data.clearcoat = this.clearcoat;
			if (this.clearcoatRoughness !== undefined) data.clearcoatRoughness = this.clearcoatRoughness;

			if (this.clearcoatMap && this.clearcoatMap.isTexture) {
				data.clearcoatMap = this.clearcoatMap.toJSON(meta).uuid;
			}

			if (this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture) {
				data.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(meta).uuid;
			}

			if (this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture) {
				data.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(meta).uuid;
				data.clearcoatNormalScale = this.clearcoatNormalScale.toArray();
			}

			if (this.map && this.map.isTexture) data.map = this.map.toJSON(meta).uuid;
			if (this.matcap && this.matcap.isTexture) data.matcap = this.matcap.toJSON(meta).uuid;
			if (this.alphaMap && this.alphaMap.isTexture) data.alphaMap = this.alphaMap.toJSON(meta).uuid;

			if (this.lightMap && this.lightMap.isTexture) {
				data.lightMap = this.lightMap.toJSON(meta).uuid;
				data.lightMapIntensity = this.lightMapIntensity;
			}

			if (this.aoMap && this.aoMap.isTexture) {
				data.aoMap = this.aoMap.toJSON(meta).uuid;
				data.aoMapIntensity = this.aoMapIntensity;
			}

			if (this.bumpMap && this.bumpMap.isTexture) {
				data.bumpMap = this.bumpMap.toJSON(meta).uuid;
				data.bumpScale = this.bumpScale;
			}

			if (this.normalMap && this.normalMap.isTexture) {
				data.normalMap = this.normalMap.toJSON(meta).uuid;
				data.normalMapType = this.normalMapType;
				data.normalScale = this.normalScale.toArray();
			}

			if (this.displacementMap && this.displacementMap.isTexture) {
				data.displacementMap = this.displacementMap.toJSON(meta).uuid;
				data.displacementScale = this.displacementScale;
				data.displacementBias = this.displacementBias;
			}

			if (this.roughnessMap && this.roughnessMap.isTexture) data.roughnessMap = this.roughnessMap.toJSON(meta).uuid;
			if (this.metalnessMap && this.metalnessMap.isTexture) data.metalnessMap = this.metalnessMap.toJSON(meta).uuid;
			if (this.emissiveMap && this.emissiveMap.isTexture) data.emissiveMap = this.emissiveMap.toJSON(meta).uuid;
			if (this.specularMap && this.specularMap.isTexture) data.specularMap = this.specularMap.toJSON(meta).uuid;
			if (this.specularIntensityMap && this.specularIntensityMap.isTexture) data.specularIntensityMap = this.specularIntensityMap.toJSON(meta).uuid;
			if (this.specularTintMap && this.specularTintMap.isTexture) data.specularTintMap = this.specularTintMap.toJSON(meta).uuid;

			if (this.envMap && this.envMap.isTexture) {
				data.envMap = this.envMap.toJSON(meta).uuid;
				if (this.combine !== undefined) data.combine = this.combine;
			}

			if (this.envMapIntensity !== undefined) data.envMapIntensity = this.envMapIntensity;
			if (this.reflectivity !== undefined) data.reflectivity = this.reflectivity;
			if (this.refractionRatio !== undefined) data.refractionRatio = this.refractionRatio;

			if (this.gradientMap && this.gradientMap.isTexture) {
				data.gradientMap = this.gradientMap.toJSON(meta).uuid;
			}

			if (this.transmission !== undefined) data.transmission = this.transmission;
			if (this.transmissionMap && this.transmissionMap.isTexture) data.transmissionMap = this.transmissionMap.toJSON(meta).uuid;
			if (this.thickness !== undefined) data.thickness = this.thickness;
			if (this.thicknessMap && this.thicknessMap.isTexture) data.thicknessMap = this.thicknessMap.toJSON(meta).uuid;
			if (this.attenuationDistance !== undefined) data.attenuationDistance = this.attenuationDistance;
			if (this.attenuationTint !== undefined) data.attenuationTint = this.attenuationTint.getHex();
			if (this.size !== undefined) data.size = this.size;
			if (this.shadowSide !== null) data.shadowSide = this.shadowSide;
			if (this.sizeAttenuation !== undefined) data.sizeAttenuation = this.sizeAttenuation;
			if (this.blending !== NormalBlending) data.blending = this.blending;
			if (this.side !== FrontSide) data.side = this.side;
			if (this.vertexColors) data.vertexColors = true;
			if (this.opacity < 1) data.opacity = this.opacity;
			if (this.format !== RGBAFormat) data.format = this.format;
			if (this.transparent === true) data.transparent = this.transparent;
			data.depthFunc = this.depthFunc;
			data.depthTest = this.depthTest;
			data.depthWrite = this.depthWrite;
			data.colorWrite = this.colorWrite;
			data.stencilWrite = this.stencilWrite;
			data.stencilWriteMask = this.stencilWriteMask;
			data.stencilFunc = this.stencilFunc;
			data.stencilRef = this.stencilRef;
			data.stencilFuncMask = this.stencilFuncMask;
			data.stencilFail = this.stencilFail;
			data.stencilZFail = this.stencilZFail;
			data.stencilZPass = this.stencilZPass; // rotation (SpriteMaterial)

			if (this.rotation && this.rotation !== 0) data.rotation = this.rotation;
			if (this.polygonOffset === true) data.polygonOffset = true;
			if (this.polygonOffsetFactor !== 0) data.polygonOffsetFactor = this.polygonOffsetFactor;
			if (this.polygonOffsetUnits !== 0) data.polygonOffsetUnits = this.polygonOffsetUnits;
			if (this.linewidth && this.linewidth !== 1) data.linewidth = this.linewidth;
			if (this.dashSize !== undefined) data.dashSize = this.dashSize;
			if (this.gapSize !== undefined) data.gapSize = this.gapSize;
			if (this.scale !== undefined) data.scale = this.scale;
			if (this.dithering === true) data.dithering = true;
			if (this.alphaTest > 0) data.alphaTest = this.alphaTest;
			if (this.alphaToCoverage === true) data.alphaToCoverage = this.alphaToCoverage;
			if (this.premultipliedAlpha === true) data.premultipliedAlpha = this.premultipliedAlpha;
			if (this.wireframe === true) data.wireframe = this.wireframe;
			if (this.wireframeLinewidth > 1) data.wireframeLinewidth = this.wireframeLinewidth;
			if (this.wireframeLinecap !== 'round') data.wireframeLinecap = this.wireframeLinecap;
			if (this.wireframeLinejoin !== 'round') data.wireframeLinejoin = this.wireframeLinejoin;
			if (this.flatShading === true) data.flatShading = this.flatShading;
			if (this.visible === false) data.visible = false;
			if (this.toneMapped === false) data.toneMapped = false;
			if (JSON.stringify(this.userData) !== '{}') data.userData = this.userData; // TODO: Copied from Object3D.toJSON

			function extractFromCache(cache) {
				var values = [];

				for (var key in cache) {
					var _data = cache[key];
					delete _data.metadata;
					values.push(_data);
				}

				return values;
			}

			if (isRoot) {
				var textures = extractFromCache(meta.textures);
				var images = extractFromCache(meta.images);
				if (textures.length > 0) data.textures = textures;
				if (images.length > 0) data.images = images;
			}

			return data;
		};

		_proto.clone = function clone() {
			return new this.constructor().copy(this);
		};

		_proto.copy = function copy(source) {
			this.name = source.name;
			this.fog = source.fog;
			this.blending = source.blending;
			this.side = source.side;
			this.vertexColors = source.vertexColors;
			this.opacity = source.opacity;
			this.format = source.format;
			this.transparent = source.transparent;
			this.blendSrc = source.blendSrc;
			this.blendDst = source.blendDst;
			this.blendEquation = source.blendEquation;
			this.blendSrcAlpha = source.blendSrcAlpha;
			this.blendDstAlpha = source.blendDstAlpha;
			this.blendEquationAlpha = source.blendEquationAlpha;
			this.depthFunc = source.depthFunc;
			this.depthTest = source.depthTest;
			this.depthWrite = source.depthWrite;
			this.stencilWriteMask = source.stencilWriteMask;
			this.stencilFunc = source.stencilFunc;
			this.stencilRef = source.stencilRef;
			this.stencilFuncMask = source.stencilFuncMask;
			this.stencilFail = source.stencilFail;
			this.stencilZFail = source.stencilZFail;
			this.stencilZPass = source.stencilZPass;
			this.stencilWrite = source.stencilWrite;
			var srcPlanes = source.clippingPlanes;
			var dstPlanes = null;

			if (srcPlanes !== null) {
				var n = srcPlanes.length;
				dstPlanes = new Array(n);

				for (var i = 0; i !== n; ++i) {
					dstPlanes[i] = srcPlanes[i].clone();
				}
			}

			this.clippingPlanes = dstPlanes;
			this.clipIntersection = source.clipIntersection;
			this.clipShadows = source.clipShadows;
			this.shadowSide = source.shadowSide;
			this.colorWrite = source.colorWrite;
			this.precision = source.precision;
			this.polygonOffset = source.polygonOffset;
			this.polygonOffsetFactor = source.polygonOffsetFactor;
			this.polygonOffsetUnits = source.polygonOffsetUnits;
			this.dithering = source.dithering;
			this.alphaTest = source.alphaTest;
			this.alphaToCoverage = source.alphaToCoverage;
			this.premultipliedAlpha = source.premultipliedAlpha;
			this.visible = source.visible;
			this.toneMapped = source.toneMapped;
			this.userData = JSON.parse(JSON.stringify(source.userData));
			return this;
		};

		_proto.dispose = function dispose() {
			this.dispatchEvent({
				type: 'dispose'
			});
		};

		_createClass(Material, [{
			key: "alphaTest",
			get: function get() {
				return this._alphaTest;
			},
			set: function set(value) {
				if (this._alphaTest > 0 !== value > 0) {
					this.version++;
				}

				this._alphaTest = value;
			}
		}, {
			key: "needsUpdate",
			set: function set(value) {
				if (value === true) this.version++;
			}
		}]);

		return Material;
	}(EventDispatcher);

	Material.prototype.isMaterial = true;

	var _colorKeywords = {
		'aliceblue': 0xF0F8FF,
		'antiquewhite': 0xFAEBD7,
		'aqua': 0x00FFFF,
		'aquamarine': 0x7FFFD4,
		'azure': 0xF0FFFF,
		'beige': 0xF5F5DC,
		'bisque': 0xFFE4C4,
		'black': 0x000000,
		'blanchedalmond': 0xFFEBCD,
		'blue': 0x0000FF,
		'blueviolet': 0x8A2BE2,
		'brown': 0xA52A2A,
		'burlywood': 0xDEB887,
		'cadetblue': 0x5F9EA0,
		'chartreuse': 0x7FFF00,
		'chocolate': 0xD2691E,
		'coral': 0xFF7F50,
		'cornflowerblue': 0x6495ED,
		'cornsilk': 0xFFF8DC,
		'crimson': 0xDC143C,
		'cyan': 0x00FFFF,
		'darkblue': 0x00008B,
		'darkcyan': 0x008B8B,
		'darkgoldenrod': 0xB8860B,
		'darkgray': 0xA9A9A9,
		'darkgreen': 0x006400,
		'darkgrey': 0xA9A9A9,
		'darkkhaki': 0xBDB76B,
		'darkmagenta': 0x8B008B,
		'darkolivegreen': 0x556B2F,
		'darkorange': 0xFF8C00,
		'darkorchid': 0x9932CC,
		'darkred': 0x8B0000,
		'darksalmon': 0xE9967A,
		'darkseagreen': 0x8FBC8F,
		'darkslateblue': 0x483D8B,
		'darkslategray': 0x2F4F4F,
		'darkslategrey': 0x2F4F4F,
		'darkturquoise': 0x00CED1,
		'darkviolet': 0x9400D3,
		'deeppink': 0xFF1493,
		'deepskyblue': 0x00BFFF,
		'dimgray': 0x696969,
		'dimgrey': 0x696969,
		'dodgerblue': 0x1E90FF,
		'firebrick': 0xB22222,
		'floralwhite': 0xFFFAF0,
		'forestgreen': 0x228B22,
		'fuchsia': 0xFF00FF,
		'gainsboro': 0xDCDCDC,
		'ghostwhite': 0xF8F8FF,
		'gold': 0xFFD700,
		'goldenrod': 0xDAA520,
		'gray': 0x808080,
		'green': 0x008000,
		'greenyellow': 0xADFF2F,
		'grey': 0x808080,
		'honeydew': 0xF0FFF0,
		'hotpink': 0xFF69B4,
		'indianred': 0xCD5C5C,
		'indigo': 0x4B0082,
		'ivory': 0xFFFFF0,
		'khaki': 0xF0E68C,
		'lavender': 0xE6E6FA,
		'lavenderblush': 0xFFF0F5,
		'lawngreen': 0x7CFC00,
		'lemonchiffon': 0xFFFACD,
		'lightblue': 0xADD8E6,
		'lightcoral': 0xF08080,
		'lightcyan': 0xE0FFFF,
		'lightgoldenrodyellow': 0xFAFAD2,
		'lightgray': 0xD3D3D3,
		'lightgreen': 0x90EE90,
		'lightgrey': 0xD3D3D3,
		'lightpink': 0xFFB6C1,
		'lightsalmon': 0xFFA07A,
		'lightseagreen': 0x20B2AA,
		'lightskyblue': 0x87CEFA,
		'lightslategray': 0x778899,
		'lightslategrey': 0x778899,
		'lightsteelblue': 0xB0C4DE,
		'lightyellow': 0xFFFFE0,
		'lime': 0x00FF00,
		'limegreen': 0x32CD32,
		'linen': 0xFAF0E6,
		'magenta': 0xFF00FF,
		'maroon': 0x800000,
		'mediumaquamarine': 0x66CDAA,
		'mediumblue': 0x0000CD,
		'mediumorchid': 0xBA55D3,
		'mediumpurple': 0x9370DB,
		'mediumseagreen': 0x3CB371,
		'mediumslateblue': 0x7B68EE,
		'mediumspringgreen': 0x00FA9A,
		'mediumturquoise': 0x48D1CC,
		'mediumvioletred': 0xC71585,
		'midnightblue': 0x191970,
		'mintcream': 0xF5FFFA,
		'mistyrose': 0xFFE4E1,
		'moccasin': 0xFFE4B5,
		'navajowhite': 0xFFDEAD,
		'navy': 0x000080,
		'oldlace': 0xFDF5E6,
		'olive': 0x808000,
		'olivedrab': 0x6B8E23,
		'orange': 0xFFA500,
		'orangered': 0xFF4500,
		'orchid': 0xDA70D6,
		'palegoldenrod': 0xEEE8AA,
		'palegreen': 0x98FB98,
		'paleturquoise': 0xAFEEEE,
		'palevioletred': 0xDB7093,
		'papayawhip': 0xFFEFD5,
		'peachpuff': 0xFFDAB9,
		'peru': 0xCD853F,
		'pink': 0xFFC0CB,
		'plum': 0xDDA0DD,
		'powderblue': 0xB0E0E6,
		'purple': 0x800080,
		'rebeccapurple': 0x663399,
		'red': 0xFF0000,
		'rosybrown': 0xBC8F8F,
		'royalblue': 0x4169E1,
		'saddlebrown': 0x8B4513,
		'salmon': 0xFA8072,
		'sandybrown': 0xF4A460,
		'seagreen': 0x2E8B57,
		'seashell': 0xFFF5EE,
		'sienna': 0xA0522D,
		'silver': 0xC0C0C0,
		'skyblue': 0x87CEEB,
		'slateblue': 0x6A5ACD,
		'slategray': 0x708090,
		'slategrey': 0x708090,
		'snow': 0xFFFAFA,
		'springgreen': 0x00FF7F,
		'steelblue': 0x4682B4,
		'tan': 0xD2B48C,
		'teal': 0x008080,
		'thistle': 0xD8BFD8,
		'tomato': 0xFF6347,
		'turquoise': 0x40E0D0,
		'violet': 0xEE82EE,
		'wheat': 0xF5DEB3,
		'white': 0xFFFFFF,
		'whitesmoke': 0xF5F5F5,
		'yellow': 0xFFFF00,
		'yellowgreen': 0x9ACD32
	};
	var _hslA = {
		h: 0,
		s: 0,
		l: 0
	};
	var _hslB = {
		h: 0,
		s: 0,
		l: 0
	};

	function hue2rgb(p, q, t) {
		if (t < 0) t += 1;
		if (t > 1) t -= 1;
		if (t < 1 / 6) return p + (q - p) * 6 * t;
		if (t < 1 / 2) return q;
		if (t < 2 / 3) return p + (q - p) * 6 * (2 / 3 - t);
		return p;
	}

	function SRGBToLinear(c) {
		return c < 0.04045 ? c * 0.0773993808 : Math.pow(c * 0.9478672986 + 0.0521327014, 2.4);
	}

	function LinearToSRGB(c) {
		return c < 0.0031308 ? c * 12.92 : 1.055 * Math.pow(c, 0.41666) - 0.055;
	}

	var Color = /*#__PURE__*/function () {
		function Color(r, g, b) {
			if (g === undefined && b === undefined) {
				// r is THREE.Color, hex or string
				return this.set(r);
			}

			return this.setRGB(r, g, b);
		}

		var _proto = Color.prototype;

		_proto.set = function set(value) {
			if (value && value.isColor) {
				this.copy(value);
			} else if (typeof value === 'number') {
				this.setHex(value);
			} else if (typeof value === 'string') {
				this.setStyle(value);
			}

			return this;
		};

		_proto.setScalar = function setScalar(scalar) {
			this.r = scalar;
			this.g = scalar;
			this.b = scalar;
			return this;
		};

		_proto.setHex = function setHex(hex) {
			hex = Math.floor(hex);
			this.r = (hex >> 16 & 255) / 255;
			this.g = (hex >> 8 & 255) / 255;
			this.b = (hex & 255) / 255;
			return this;
		};

		_proto.setRGB = function setRGB(r, g, b) {
			this.r = r;
			this.g = g;
			this.b = b;
			return this;
		};

		_proto.setHSL = function setHSL(h, s, l) {
			// h,s,l ranges are in 0.0 - 1.0
			h = euclideanModulo(h, 1);
			s = clamp(s, 0, 1);
			l = clamp(l, 0, 1);

			if (s === 0) {
				this.r = this.g = this.b = l;
			} else {
				var p = l <= 0.5 ? l * (1 + s) : l + s - l * s;
				var q = 2 * l - p;
				this.r = hue2rgb(q, p, h + 1 / 3);
				this.g = hue2rgb(q, p, h);
				this.b = hue2rgb(q, p, h - 1 / 3);
			}

			return this;
		};

		_proto.setStyle = function setStyle(style) {
			function handleAlpha(string) {
				if (string === undefined) return;

				if (parseFloat(string) < 1) {
					console.warn('THREE.Color: Alpha component of ' + style + ' will be ignored.');
				}
			}

			var m;

			if (m = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(style)) {
				// rgb / hsl
				var color;
				var name = m[1];
				var components = m[2];

				switch (name) {
					case 'rgb':
					case 'rgba':
						if (color = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
							// rgb(255,0,0) rgba(255,0,0,0.5)
							this.r = Math.min(255, parseInt(color[1], 10)) / 255;
							this.g = Math.min(255, parseInt(color[2], 10)) / 255;
							this.b = Math.min(255, parseInt(color[3], 10)) / 255;
							handleAlpha(color[4]);
							return this;
						}

						if (color = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
							// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)
							this.r = Math.min(100, parseInt(color[1], 10)) / 100;
							this.g = Math.min(100, parseInt(color[2], 10)) / 100;
							this.b = Math.min(100, parseInt(color[3], 10)) / 100;
							handleAlpha(color[4]);
							return this;
						}

						break;

					case 'hsl':
					case 'hsla':
						if (color = /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
							// hsl(120,50%,50%) hsla(120,50%,50%,0.5)
							var h = parseFloat(color[1]) / 360;
							var s = parseInt(color[2], 10) / 100;
							var l = parseInt(color[3], 10) / 100;
							handleAlpha(color[4]);
							return this.setHSL(h, s, l);
						}

						break;
				}
			} else if (m = /^\#([A-Fa-f\d]+)$/.exec(style)) {
				// hex color
				var hex = m[1];
				var size = hex.length;

				if (size === 3) {
					// #ff0
					this.r = parseInt(hex.charAt(0) + hex.charAt(0), 16) / 255;
					this.g = parseInt(hex.charAt(1) + hex.charAt(1), 16) / 255;
					this.b = parseInt(hex.charAt(2) + hex.charAt(2), 16) / 255;
					return this;
				} else if (size === 6) {
					// #ff0000
					this.r = parseInt(hex.charAt(0) + hex.charAt(1), 16) / 255;
					this.g = parseInt(hex.charAt(2) + hex.charAt(3), 16) / 255;
					this.b = parseInt(hex.charAt(4) + hex.charAt(5), 16) / 255;
					return this;
				}
			}

			if (style && style.length > 0) {
				return this.setColorName(style);
			}

			return this;
		};

		_proto.setColorName = function setColorName(style) {
			// color keywords
			var hex = _colorKeywords[style.toLowerCase()];

			if (hex !== undefined) {
				// red
				this.setHex(hex);
			} else {
				// unknown color
				console.warn('THREE.Color: Unknown color ' + style);
			}

			return this;
		};

		_proto.clone = function clone() {
			return new this.constructor(this.r, this.g, this.b);
		};

		_proto.copy = function copy(color) {
			this.r = color.r;
			this.g = color.g;
			this.b = color.b;
			return this;
		};

		_proto.copyGammaToLinear = function copyGammaToLinear(color, gammaFactor) {
			if (gammaFactor === void 0) {
				gammaFactor = 2.0;
			}

			this.r = Math.pow(color.r, gammaFactor);
			this.g = Math.pow(color.g, gammaFactor);
			this.b = Math.pow(color.b, gammaFactor);
			return this;
		};

		_proto.copyLinearToGamma = function copyLinearToGamma(color, gammaFactor) {
			if (gammaFactor === void 0) {
				gammaFactor = 2.0;
			}

			var safeInverse = gammaFactor > 0 ? 1.0 / gammaFactor : 1.0;
			this.r = Math.pow(color.r, safeInverse);
			this.g = Math.pow(color.g, safeInverse);
			this.b = Math.pow(color.b, safeInverse);
			return this;
		};

		_proto.convertGammaToLinear = function convertGammaToLinear(gammaFactor) {
			this.copyGammaToLinear(this, gammaFactor);
			return this;
		};

		_proto.convertLinearToGamma = function convertLinearToGamma(gammaFactor) {
			this.copyLinearToGamma(this, gammaFactor);
			return this;
		};

		_proto.copySRGBToLinear = function copySRGBToLinear(color) {
			this.r = SRGBToLinear(color.r);
			this.g = SRGBToLinear(color.g);
			this.b = SRGBToLinear(color.b);
			return this;
		};

		_proto.copyLinearToSRGB = function copyLinearToSRGB(color) {
			this.r = LinearToSRGB(color.r);
			this.g = LinearToSRGB(color.g);
			this.b = LinearToSRGB(color.b);
			return this;
		};

		_proto.convertSRGBToLinear = function convertSRGBToLinear() {
			this.copySRGBToLinear(this);
			return this;
		};

		_proto.convertLinearToSRGB = function convertLinearToSRGB() {
			this.copyLinearToSRGB(this);
			return this;
		};

		_proto.getHex = function getHex() {
			return this.r * 255 << 16 ^ this.g * 255 << 8 ^ this.b * 255 << 0;
		};

		_proto.getHexString = function getHexString() {
			return ('000000' + this.getHex().toString(16)).slice(-6);
		};

		_proto.getHSL = function getHSL(target) {
			// h,s,l ranges are in 0.0 - 1.0
			var r = this.r,
					g = this.g,
					b = this.b;
			var max = Math.max(r, g, b);
			var min = Math.min(r, g, b);
			var hue, saturation;
			var lightness = (min + max) / 2.0;

			if (min === max) {
				hue = 0;
				saturation = 0;
			} else {
				var delta = max - min;
				saturation = lightness <= 0.5 ? delta / (max + min) : delta / (2 - max - min);

				switch (max) {
					case r:
						hue = (g - b) / delta + (g < b ? 6 : 0);
						break;

					case g:
						hue = (b - r) / delta + 2;
						break;

					case b:
						hue = (r - g) / delta + 4;
						break;
				}

				hue /= 6;
			}

			target.h = hue;
			target.s = saturation;
			target.l = lightness;
			return target;
		};

		_proto.getStyle = function getStyle() {
			return 'rgb(' + (this.r * 255 | 0) + ',' + (this.g * 255 | 0) + ',' + (this.b * 255 | 0) + ')';
		};

		_proto.offsetHSL = function offsetHSL(h, s, l) {
			this.getHSL(_hslA);
			_hslA.h += h;
			_hslA.s += s;
			_hslA.l += l;
			this.setHSL(_hslA.h, _hslA.s, _hslA.l);
			return this;
		};

		_proto.add = function add(color) {
			this.r += color.r;
			this.g += color.g;
			this.b += color.b;
			return this;
		};

		_proto.addColors = function addColors(color1, color2) {
			this.r = color1.r + color2.r;
			this.g = color1.g + color2.g;
			this.b = color1.b + color2.b;
			return this;
		};

		_proto.addScalar = function addScalar(s) {
			this.r += s;
			this.g += s;
			this.b += s;
			return this;
		};

		_proto.sub = function sub(color) {
			this.r = Math.max(0, this.r - color.r);
			this.g = Math.max(0, this.g - color.g);
			this.b = Math.max(0, this.b - color.b);
			return this;
		};

		_proto.multiply = function multiply(color) {
			this.r *= color.r;
			this.g *= color.g;
			this.b *= color.b;
			return this;
		};

		_proto.multiplyScalar = function multiplyScalar(s) {
			this.r *= s;
			this.g *= s;
			this.b *= s;
			return this;
		};

		_proto.lerp = function lerp(color, alpha) {
			this.r += (color.r - this.r) * alpha;
			this.g += (color.g - this.g) * alpha;
			this.b += (color.b - this.b) * alpha;
			return this;
		};

		_proto.lerpColors = function lerpColors(color1, color2, alpha) {
			this.r = color1.r + (color2.r - color1.r) * alpha;
			this.g = color1.g + (color2.g - color1.g) * alpha;
			this.b = color1.b + (color2.b - color1.b) * alpha;
			return this;
		};

		_proto.lerpHSL = function lerpHSL(color, alpha) {
			this.getHSL(_hslA);
			color.getHSL(_hslB);
			var h = lerp(_hslA.h, _hslB.h, alpha);
			var s = lerp(_hslA.s, _hslB.s, alpha);
			var l = lerp(_hslA.l, _hslB.l, alpha);
			this.setHSL(h, s, l);
			return this;
		};

		_proto.equals = function equals(c) {
			return c.r === this.r && c.g === this.g && c.b === this.b;
		};

		_proto.fromArray = function fromArray(array, offset) {
			if (offset === void 0) {
				offset = 0;
			}

			this.r = array[offset];
			this.g = array[offset + 1];
			this.b = array[offset + 2];
			return this;
		};

		_proto.toArray = function toArray(array, offset) {
			if (array === void 0) {
				array = [];
			}

			if (offset === void 0) {
				offset = 0;
			}

			array[offset] = this.r;
			array[offset + 1] = this.g;
			array[offset + 2] = this.b;
			return array;
		};

		_proto.fromBufferAttribute = function fromBufferAttribute(attribute, index) {
			this.r = attribute.getX(index);
			this.g = attribute.getY(index);
			this.b = attribute.getZ(index);

			if (attribute.normalized === true) {
				// assuming Uint8Array
				this.r /= 255;
				this.g /= 255;
				this.b /= 255;
			}

			return this;
		};

		_proto.toJSON = function toJSON() {
			return this.getHex();
		};

		return Color;
	}();

	Color.NAMES = _colorKeywords;
	Color.prototype.isColor = true;
	Color.prototype.r = 1;
	Color.prototype.g = 1;
	Color.prototype.b = 1;

	/**
	 * parameters = {
	 *	color: <hex>,
	 *	opacity: <float>,
	 *	map: new THREE.Texture( <Image> ),
	 *
	 *	lightMap: new THREE.Texture( <Image> ),
	 *	lightMapIntensity: <float>
	 *
	 *	aoMap: new THREE.Texture( <Image> ),
	 *	aoMapIntensity: <float>
	 *
	 *	specularMap: new THREE.Texture( <Image> ),
	 *
	 *	alphaMap: new THREE.Texture( <Image> ),
	 *
	 *	envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
	 *	combine: THREE.Multiply,
	 *	reflectivity: <float>,
	 *	refractionRatio: <float>,
	 *
	 *	depthTest: <bool>,
	 *	depthWrite: <bool>,
	 *
	 *	wireframe: <boolean>,
	 *	wireframeLinewidth: <float>,
	 * }
	 */

	var MeshBasicMaterial = /*#__PURE__*/function (_Material) {
		_inheritsLoose(MeshBasicMaterial, _Material);

		function MeshBasicMaterial(parameters) {
			var _this;

			_this = _Material.call(this) || this;
			_this.type = 'MeshBasicMaterial';
			_this.color = new Color(0xffffff); // emissive

			_this.map = null;
			_this.lightMap = null;
			_this.lightMapIntensity = 1.0;
			_this.aoMap = null;
			_this.aoMapIntensity = 1.0;
			_this.specularMap = null;
			_this.alphaMap = null;
			_this.envMap = null;
			_this.combine = MultiplyOperation;
			_this.reflectivity = 1;
			_this.refractionRatio = 0.98;
			_this.wireframe = false;
			_this.wireframeLinewidth = 1;
			_this.wireframeLinecap = 'round';
			_this.wireframeLinejoin = 'round';

			_this.setValues(parameters);

			return _this;
		}

		var _proto = MeshBasicMaterial.prototype;

		_proto.copy = function copy(source) {
			_Material.prototype.copy.call(this, source);

			this.color.copy(source.color);
			this.map = source.map;
			this.lightMap = source.lightMap;
			this.lightMapIntensity = source.lightMapIntensity;
			this.aoMap = source.aoMap;
			this.aoMapIntensity = source.aoMapIntensity;
			this.specularMap = source.specularMap;
			this.alphaMap = source.alphaMap;
			this.envMap = source.envMap;
			this.combine = source.combine;
			this.reflectivity = source.reflectivity;
			this.refractionRatio = source.refractionRatio;
			this.wireframe = source.wireframe;
			this.wireframeLinewidth = source.wireframeLinewidth;
			this.wireframeLinecap = source.wireframeLinecap;
			this.wireframeLinejoin = source.wireframeLinejoin;
			return this;
		};

		return MeshBasicMaterial;
	}(Material);

	MeshBasicMaterial.prototype.isMeshBasicMaterial = true;

	var _vector$3 = /*@__PURE__*/new Vector3();

	var _vector2 = /*@__PURE__*/new Vector2();

	var BufferAttribute = /*#__PURE__*/function () {
		function BufferAttribute(array, itemSize, normalized) {
			if (Array.isArray(array)) {
				throw new TypeError('THREE.BufferAttribute: array should be a Typed Array.');
			}

			this.name = '';
			this.array = array;
			this.itemSize = itemSize;
			this.count = array !== undefined ? array.length / itemSize : 0;
			this.normalized = normalized === true;
			this.usage = StaticDrawUsage;
			this.updateRange = {
				offset: 0,
				count: -1
			};
			this.version = 0;
		}

		var _proto = BufferAttribute.prototype;

		_proto.onUploadCallback = function onUploadCallback() {};

		_proto.setUsage = function setUsage(value) {
			this.usage = value;
			return this;
		};

		_proto.copy = function copy(source) {
			this.name = source.name;
			this.array = new source.array.constructor(source.array);
			this.itemSize = source.itemSize;
			this.count = source.count;
			this.normalized = source.normalized;
			this.usage = source.usage;
			return this;
		};

		_proto.copyAt = function copyAt(index1, attribute, index2) {
			index1 *= this.itemSize;
			index2 *= attribute.itemSize;

			for (var i = 0, l = this.itemSize; i < l; i++) {
				this.array[index1 + i] = attribute.array[index2 + i];
			}

			return this;
		};

		_proto.copyArray = function copyArray(array) {
			this.array.set(array);
			return this;
		};

		_proto.copyColorsArray = function copyColorsArray(colors) {
			var array = this.array;
			var offset = 0;

			for (var i = 0, l = colors.length; i < l; i++) {
				var color = colors[i];

				if (color === undefined) {
					console.warn('THREE.BufferAttribute.copyColorsArray(): color is undefined', i);
					color = new Color();
				}

				array[offset++] = color.r;
				array[offset++] = color.g;
				array[offset++] = color.b;
			}

			return this;
		};

		_proto.copyVector2sArray = function copyVector2sArray(vectors) {
			var array = this.array;
			var offset = 0;

			for (var i = 0, l = vectors.length; i < l; i++) {
				var vector = vectors[i];

				if (vector === undefined) {
					console.warn('THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i);
					vector = new Vector2();
				}

				array[offset++] = vector.x;
				array[offset++] = vector.y;
			}

			return this;
		};

		_proto.copyVector3sArray = function copyVector3sArray(vectors) {
			var array = this.array;
			var offset = 0;

			for (var i = 0, l = vectors.length; i < l; i++) {
				var vector = vectors[i];

				if (vector === undefined) {
					console.warn('THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i);
					vector = new Vector3();
				}

				array[offset++] = vector.x;
				array[offset++] = vector.y;
				array[offset++] = vector.z;
			}

			return this;
		};

		_proto.copyVector4sArray = function copyVector4sArray(vectors) {
			var array = this.array;
			var offset = 0;

			for (var i = 0, l = vectors.length; i < l; i++) {
				var vector = vectors[i];

				if (vector === undefined) {
					console.warn('THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i);
					vector = new Vector4();
				}

				array[offset++] = vector.x;
				array[offset++] = vector.y;
				array[offset++] = vector.z;
				array[offset++] = vector.w;
			}

			return this;
		};

		_proto.applyMatrix3 = function applyMatrix3(m) {
			if (this.itemSize === 2) {
				for (var i = 0, l = this.count; i < l; i++) {
					_vector2.fromBufferAttribute(this, i);

					_vector2.applyMatrix3(m);

					this.setXY(i, _vector2.x, _vector2.y);
				}
			} else if (this.itemSize === 3) {
				for (var _i = 0, _l = this.count; _i < _l; _i++) {
					_vector$3.fromBufferAttribute(this, _i);

					_vector$3.applyMatrix3(m);

					this.setXYZ(_i, _vector$3.x, _vector$3.y, _vector$3.z);
				}
			}

			return this;
		};

		_proto.applyMatrix4 = function applyMatrix4(m) {
			for (var i = 0, l = this.count; i < l; i++) {
				_vector$3.x = this.getX(i);
				_vector$3.y = this.getY(i);
				_vector$3.z = this.getZ(i);

				_vector$3.applyMatrix4(m);

				this.setXYZ(i, _vector$3.x, _vector$3.y, _vector$3.z);
			}

			return this;
		};

		_proto.applyNormalMatrix = function applyNormalMatrix(m) {
			for (var i = 0, l = this.count; i < l; i++) {
				_vector$3.x = this.getX(i);
				_vector$3.y = this.getY(i);
				_vector$3.z = this.getZ(i);

				_vector$3.applyNormalMatrix(m);

				this.setXYZ(i, _vector$3.x, _vector$3.y, _vector$3.z);
			}

			return this;
		};

		_proto.transformDirection = function transformDirection(m) {
			for (var i = 0, l = this.count; i < l; i++) {
				_vector$3.x = this.getX(i);
				_vector$3.y = this.getY(i);
				_vector$3.z = this.getZ(i);

				_vector$3.transformDirection(m);

				this.setXYZ(i, _vector$3.x, _vector$3.y, _vector$3.z);
			}

			return this;
		};

		_proto.set = function set(value, offset) {
			if (offset === void 0) {
				offset = 0;
			}

			this.array.set(value, offset);
			return this;
		};

		_proto.getX = function getX(index) {
			return this.array[index * this.itemSize];
		};

		_proto.setX = function setX(index, x) {
			this.array[index * this.itemSize] = x;
			return this;
		};

		_proto.getY = function getY(index) {
			return this.array[index * this.itemSize + 1];
		};

		_proto.setY = function setY(index, y) {
			this.array[index * this.itemSize + 1] = y;
			return this;
		};

		_proto.getZ = function getZ(index) {
			return this.array[index * this.itemSize + 2];
		};

		_proto.setZ = function setZ(index, z) {
			this.array[index * this.itemSize + 2] = z;
			return this;
		};

		_proto.getW = function getW(index) {
			return this.array[index * this.itemSize + 3];
		};

		_proto.setW = function setW(index, w) {
			this.array[index * this.itemSize + 3] = w;
			return this;
		};

		_proto.setXY = function setXY(index, x, y) {
			index *= this.itemSize;
			this.array[index + 0] = x;
			this.array[index + 1] = y;
			return this;
		};

		_proto.setXYZ = function setXYZ(index, x, y, z) {
			index *= this.itemSize;
			this.array[index + 0] = x;
			this.array[index + 1] = y;
			this.array[index + 2] = z;
			return this;
		};

		_proto.setXYZW = function setXYZW(index, x, y, z, w) {
			index *= this.itemSize;
			this.array[index + 0] = x;
			this.array[index + 1] = y;
			this.array[index + 2] = z;
			this.array[index + 3] = w;
			return this;
		};

		_proto.onUpload = function onUpload(callback) {
			this.onUploadCallback = callback;
			return this;
		};

		_proto.clone = function clone() {
			return new this.constructor(this.array, this.itemSize).copy(this);
		};

		_proto.toJSON = function toJSON() {
			var data = {
				itemSize: this.itemSize,
				type: this.array.constructor.name,
				array: Array.prototype.slice.call(this.array),
				normalized: this.normalized
			};
			if (this.name !== '') data.name = this.name;
			if (this.usage !== StaticDrawUsage) data.usage = this.usage;
			if (this.updateRange.offset !== 0 || this.updateRange.count !== -1) data.updateRange = this.updateRange;
			return data;
		};

		_createClass(BufferAttribute, [{
			key: "needsUpdate",
			set: function set(value) {
				if (value === true) this.version++;
			}
		}]);

		return BufferAttribute;
	}();

	BufferAttribute.prototype.isBufferAttribute = true; //

	var Int8BufferAttribute = /*#__PURE__*/function (_BufferAttribute) {
		_inheritsLoose(Int8BufferAttribute, _BufferAttribute);

		function Int8BufferAttribute(array, itemSize, normalized) {
			return _BufferAttribute.call(this, new Int8Array(array), itemSize, normalized) || this;
		}

		return Int8BufferAttribute;
	}(BufferAttribute);

	var Uint8BufferAttribute = /*#__PURE__*/function (_BufferAttribute2) {
		_inheritsLoose(Uint8BufferAttribute, _BufferAttribute2);

		function Uint8BufferAttribute(array, itemSize, normalized) {
			return _BufferAttribute2.call(this, new Uint8Array(array), itemSize, normalized) || this;
		}

		return Uint8BufferAttribute;
	}(BufferAttribute);

	var Uint8ClampedBufferAttribute = /*#__PURE__*/function (_BufferAttribute3) {
		_inheritsLoose(Uint8ClampedBufferAttribute, _BufferAttribute3);

		function Uint8ClampedBufferAttribute(array, itemSize, normalized) {
			return _BufferAttribute3.call(this, new Uint8ClampedArray(array), itemSize, normalized) || this;
		}

		return Uint8ClampedBufferAttribute;
	}(BufferAttribute);

	var Int16BufferAttribute = /*#__PURE__*/function (_BufferAttribute4) {
		_inheritsLoose(Int16BufferAttribute, _BufferAttribute4);

		function Int16BufferAttribute(array, itemSize, normalized) {
			return _BufferAttribute4.call(this, new Int16Array(array), itemSize, normalized) || this;
		}

		return Int16BufferAttribute;
	}(BufferAttribute);

	var Uint16BufferAttribute = /*#__PURE__*/function (_BufferAttribute5) {
		_inheritsLoose(Uint16BufferAttribute, _BufferAttribute5);

		function Uint16BufferAttribute(array, itemSize, normalized) {
			return _BufferAttribute5.call(this, new Uint16Array(array), itemSize, normalized) || this;
		}

		return Uint16BufferAttribute;
	}(BufferAttribute);

	var Int32BufferAttribute = /*#__PURE__*/function (_BufferAttribute6) {
		_inheritsLoose(Int32BufferAttribute, _BufferAttribute6);

		function Int32BufferAttribute(array, itemSize, normalized) {
			return _BufferAttribute6.call(this, new Int32Array(array), itemSize, normalized) || this;
		}

		return Int32BufferAttribute;
	}(BufferAttribute);

	var Uint32BufferAttribute = /*#__PURE__*/function (_BufferAttribute7) {
		_inheritsLoose(Uint32BufferAttribute, _BufferAttribute7);

		function Uint32BufferAttribute(array, itemSize, normalized) {
			return _BufferAttribute7.call(this, new Uint32Array(array), itemSize, normalized) || this;
		}

		return Uint32BufferAttribute;
	}(BufferAttribute);

	var Float16BufferAttribute = /*#__PURE__*/function (_BufferAttribute8) {
		_inheritsLoose(Float16BufferAttribute, _BufferAttribute8);

		function Float16BufferAttribute(array, itemSize, normalized) {
			return _BufferAttribute8.call(this, new Uint16Array(array), itemSize, normalized) || this;
		}

		return Float16BufferAttribute;
	}(BufferAttribute);

	Float16BufferAttribute.prototype.isFloat16BufferAttribute = true;

	var Float32BufferAttribute = /*#__PURE__*/function (_BufferAttribute9) {
		_inheritsLoose(Float32BufferAttribute, _BufferAttribute9);

		function Float32BufferAttribute(array, itemSize, normalized) {
			return _BufferAttribute9.call(this, new Float32Array(array), itemSize, normalized) || this;
		}

		return Float32BufferAttribute;
	}(BufferAttribute);

	var Float64BufferAttribute = /*#__PURE__*/function (_BufferAttribute10) {
		_inheritsLoose(Float64BufferAttribute, _BufferAttribute10);

		function Float64BufferAttribute(array, itemSize, normalized) {
			return _BufferAttribute10.call(this, new Float64Array(array), itemSize, normalized) || this;
		}

		return Float64BufferAttribute;
	}(BufferAttribute); //

	var _id = 0;

	var _m1$2 = /*@__PURE__*/new Matrix4();

	var _obj = /*@__PURE__*/new Object3D();

	var _offset = /*@__PURE__*/new Vector3();

	var _box$2 = /*@__PURE__*/new Box3();

	var _boxMorphTargets = /*@__PURE__*/new Box3();

	var _vector$4 = /*@__PURE__*/new Vector3();

	var BufferGeometry = /*#__PURE__*/function (_EventDispatcher) {
		_inheritsLoose(BufferGeometry, _EventDispatcher);

		function BufferGeometry() {
			var _this;

			_this = _EventDispatcher.call(this) || this;
			Object.defineProperty(_assertThisInitialized(_this), 'id', {
				value: _id++
			});
			_this.uuid = generateUUID();
			_this.name = '';
			_this.type = 'BufferGeometry';
			_this.index = null;
			_this.attributes = {};
			_this.morphAttributes = {};
			_this.morphTargetsRelative = false;
			_this.groups = [];
			_this.boundingBox = null;
			_this.boundingSphere = null;
			_this.drawRange = {
				start: 0,
				count: Infinity
			};
			_this.userData = {};
			return _this;
		}

		var _proto = BufferGeometry.prototype;

		_proto.getIndex = function getIndex() {
			return this.index;
		};

		_proto.setIndex = function setIndex(index) {
			if (Array.isArray(index)) {
				this.index = new (arrayMax(index) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute)(index, 1);
			} else {
				this.index = index;
			}

			return this;
		};

		_proto.getAttribute = function getAttribute(name) {
			return this.attributes[name];
		};

		_proto.setAttribute = function setAttribute(name, attribute) {
			this.attributes[name] = attribute;
			return this;
		};

		_proto.deleteAttribute = function deleteAttribute(name) {
			delete this.attributes[name];
			return this;
		};

		_proto.hasAttribute = function hasAttribute(name) {
			return this.attributes[name] !== undefined;
		};

		_proto.addGroup = function addGroup(start, count, materialIndex) {
			if (materialIndex === void 0) {
				materialIndex = 0;
			}

			this.groups.push({
				start: start,
				count: count,
				materialIndex: materialIndex
			});
		};

		_proto.clearGroups = function clearGroups() {
			this.groups = [];
		};

		_proto.setDrawRange = function setDrawRange(start, count) {
			this.drawRange.start = start;
			this.drawRange.count = count;
		};

		_proto.applyMatrix4 = function applyMatrix4(matrix) {
			var position = this.attributes.position;

			if (position !== undefined) {
				position.applyMatrix4(matrix);
				position.needsUpdate = true;
			}

			var normal = this.attributes.normal;

			if (normal !== undefined) {
				var normalMatrix = new Matrix3().getNormalMatrix(matrix);
				normal.applyNormalMatrix(normalMatrix);
				normal.needsUpdate = true;
			}

			var tangent = this.attributes.tangent;

			if (tangent !== undefined) {
				tangent.transformDirection(matrix);
				tangent.needsUpdate = true;
			}

			if (this.boundingBox !== null) {
				this.computeBoundingBox();
			}

			if (this.boundingSphere !== null) {
				this.computeBoundingSphere();
			}

			return this;
		};

		_proto.applyQuaternion = function applyQuaternion(q) {
			_m1$2.makeRotationFromQuaternion(q);

			this.applyMatrix4(_m1$2);
			return this;
		};

		_proto.rotateX = function rotateX(angle) {
			// rotate geometry around world x-axis
			_m1$2.makeRotationX(angle);

			this.applyMatrix4(_m1$2);
			return this;
		};

		_proto.rotateY = function rotateY(angle) {
			// rotate geometry around world y-axis
			_m1$2.makeRotationY(angle);

			this.applyMatrix4(_m1$2);
			return this;
		};

		_proto.rotateZ = function rotateZ(angle) {
			// rotate geometry around world z-axis
			_m1$2.makeRotationZ(angle);

			this.applyMatrix4(_m1$2);
			return this;
		};

		_proto.translate = function translate(x, y, z) {
			// translate geometry
			_m1$2.makeTranslation(x, y, z);

			this.applyMatrix4(_m1$2);
			return this;
		};

		_proto.scale = function scale(x, y, z) {
			// scale geometry
			_m1$2.makeScale(x, y, z);

			this.applyMatrix4(_m1$2);
			return this;
		};

		_proto.lookAt = function lookAt(vector) {
			_obj.lookAt(vector);

			_obj.updateMatrix();

			this.applyMatrix4(_obj.matrix);
			return this;
		};

		_proto.center = function center() {
			this.computeBoundingBox();
			this.boundingBox.getCenter(_offset).negate();
			this.translate(_offset.x, _offset.y, _offset.z);
			return this;
		};

		_proto.setFromPoints = function setFromPoints(points) {
			var position = [];

			for (var i = 0, l = points.length; i < l; i++) {
				var point = points[i];
				position.push(point.x, point.y, point.z || 0);
			}

			this.setAttribute('position', new Float32BufferAttribute(position, 3));
			return this;
		};

		_proto.computeBoundingBox = function computeBoundingBox() {
			if (this.boundingBox === null) {
				this.boundingBox = new Box3();
			}

			var position = this.attributes.position;
			var morphAttributesPosition = this.morphAttributes.position;

			if (position && position.isGLBufferAttribute) {
				console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this);
				this.boundingBox.set(new Vector3(-Infinity, -Infinity, -Infinity), new Vector3(+Infinity, +Infinity, +Infinity));
				return;
			}

			if (position !== undefined) {
				this.boundingBox.setFromBufferAttribute(position); // process morph attributes if present

				if (morphAttributesPosition) {
					for (var i = 0, il = morphAttributesPosition.length; i < il; i++) {
						var morphAttribute = morphAttributesPosition[i];

						_box$2.setFromBufferAttribute(morphAttribute);

						if (this.morphTargetsRelative) {
							_vector$4.addVectors(this.boundingBox.min, _box$2.min);

							this.boundingBox.expandByPoint(_vector$4);

							_vector$4.addVectors(this.boundingBox.max, _box$2.max);

							this.boundingBox.expandByPoint(_vector$4);
						} else {
							this.boundingBox.expandByPoint(_box$2.min);
							this.boundingBox.expandByPoint(_box$2.max);
						}
					}
				}
			} else {
				this.boundingBox.makeEmpty();
			}

			if (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) {
				console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
			}
		};

		_proto.computeBoundingSphere = function computeBoundingSphere() {
			if (this.boundingSphere === null) {
				this.boundingSphere = new Sphere();
			}

			var position = this.attributes.position;
			var morphAttributesPosition = this.morphAttributes.position;

			if (position && position.isGLBufferAttribute) {
				console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this);
				this.boundingSphere.set(new Vector3(), Infinity);
				return;
			}

			if (position) {
				// first, find the center of the bounding sphere
				var center = this.boundingSphere.center;

				_box$2.setFromBufferAttribute(position); // process morph attributes if present


				if (morphAttributesPosition) {
					for (var i = 0, il = morphAttributesPosition.length; i < il; i++) {
						var morphAttribute = morphAttributesPosition[i];

						_boxMorphTargets.setFromBufferAttribute(morphAttribute);

						if (this.morphTargetsRelative) {
							_vector$4.addVectors(_box$2.min, _boxMorphTargets.min);

							_box$2.expandByPoint(_vector$4);

							_vector$4.addVectors(_box$2.max, _boxMorphTargets.max);

							_box$2.expandByPoint(_vector$4);
						} else {
							_box$2.expandByPoint(_boxMorphTargets.min);

							_box$2.expandByPoint(_boxMorphTargets.max);
						}
					}
				}

				_box$2.getCenter(center); // second, try to find a boundingSphere with a radius smaller than the
				// boundingSphere of the boundingBox: sqrt(3) smaller in the best case


				var maxRadiusSq = 0;

				for (var _i = 0, _il = position.count; _i < _il; _i++) {
					_vector$4.fromBufferAttribute(position, _i);

					maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$4));
				} // process morph attributes if present


				if (morphAttributesPosition) {
					for (var _i2 = 0, _il2 = morphAttributesPosition.length; _i2 < _il2; _i2++) {
						var _morphAttribute = morphAttributesPosition[_i2];
						var morphTargetsRelative = this.morphTargetsRelative;

						for (var j = 0, jl = _morphAttribute.count; j < jl; j++) {
							_vector$4.fromBufferAttribute(_morphAttribute, j);

							if (morphTargetsRelative) {
								_offset.fromBufferAttribute(position, j);

								_vector$4.add(_offset);
							}

							maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$4));
						}
					}
				}

				this.boundingSphere.radius = Math.sqrt(maxRadiusSq);

				if (isNaN(this.boundingSphere.radius)) {
					console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
				}
			}
		};

		_proto.computeTangents = function computeTangents() {
			var index = this.index;
			var attributes = this.attributes; // based on http://www.terathon.com/code/tangent.html
			// (per vertex tangents)

			if (index === null || attributes.position === undefined || attributes.normal === undefined || attributes.uv === undefined) {
				console.error('THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)');
				return;
			}

			var indices = index.array;
			var positions = attributes.position.array;
			var normals = attributes.normal.array;
			var uvs = attributes.uv.array;
			var nVertices = positions.length / 3;

			if (attributes.tangent === undefined) {
				this.setAttribute('tangent', new BufferAttribute(new Float32Array(4 * nVertices), 4));
			}

			var tangents = attributes.tangent.array;
			var tan1 = [],
					tan2 = [];

			for (var i = 0; i < nVertices; i++) {
				tan1[i] = new Vector3();
				tan2[i] = new Vector3();
			}

			var vA = new Vector3(),
					vB = new Vector3(),
					vC = new Vector3(),
					uvA = new Vector2(),
					uvB = new Vector2(),
					uvC = new Vector2(),
					sdir = new Vector3(),
					tdir = new Vector3();

			function handleTriangle(a, b, c) {
				vA.fromArray(positions, a * 3);
				vB.fromArray(positions, b * 3);
				vC.fromArray(positions, c * 3);
				uvA.fromArray(uvs, a * 2);
				uvB.fromArray(uvs, b * 2);
				uvC.fromArray(uvs, c * 2);
				vB.sub(vA);
				vC.sub(vA);
				uvB.sub(uvA);
				uvC.sub(uvA);
				var r = 1.0 / (uvB.x * uvC.y - uvC.x * uvB.y); // silently ignore degenerate uv triangles having coincident or colinear vertices

				if (!isFinite(r)) return;
				sdir.copy(vB).multiplyScalar(uvC.y).addScaledVector(vC, -uvB.y).multiplyScalar(r);
				tdir.copy(vC).multiplyScalar(uvB.x).addScaledVector(vB, -uvC.x).multiplyScalar(r);
				tan1[a].add(sdir);
				tan1[b].add(sdir);
				tan1[c].add(sdir);
				tan2[a].add(tdir);
				tan2[b].add(tdir);
				tan2[c].add(tdir);
			}

			var groups = this.groups;

			if (groups.length === 0) {
				groups = [{
					start: 0,
					count: indices.length
				}];
			}

			for (var _i3 = 0, il = groups.length; _i3 < il; ++_i3) {
				var group = groups[_i3];
				var start = group.start;
				var count = group.count;

				for (var j = start, jl = start + count; j < jl; j += 3) {
					handleTriangle(indices[j + 0], indices[j + 1], indices[j + 2]);
				}
			}

			var tmp = new Vector3(),
					tmp2 = new Vector3();
			var n = new Vector3(),
					n2 = new Vector3();

			function handleVertex(v) {
				n.fromArray(normals, v * 3);
				n2.copy(n);
				var t = tan1[v]; // Gram-Schmidt orthogonalize

				tmp.copy(t);
				tmp.sub(n.multiplyScalar(n.dot(t))).normalize(); // Calculate handedness

				tmp2.crossVectors(n2, t);
				var test = tmp2.dot(tan2[v]);
				var w = test < 0.0 ? -1.0 : 1.0;
				tangents[v * 4] = tmp.x;
				tangents[v * 4 + 1] = tmp.y;
				tangents[v * 4 + 2] = tmp.z;
				tangents[v * 4 + 3] = w;
			}

			for (var _i4 = 0, _il3 = groups.length; _i4 < _il3; ++_i4) {
				var _group = groups[_i4];
				var _start = _group.start;
				var _count = _group.count;

				for (var _j = _start, _jl = _start + _count; _j < _jl; _j += 3) {
					handleVertex(indices[_j + 0]);
					handleVertex(indices[_j + 1]);
					handleVertex(indices[_j + 2]);
				}
			}
		};

		_proto.computeVertexNormals = function computeVertexNormals() {
			var index = this.index;
			var positionAttribute = this.getAttribute('position');

			if (positionAttribute !== undefined) {
				var normalAttribute = this.getAttribute('normal');

				if (normalAttribute === undefined) {
					normalAttribute = new BufferAttribute(new Float32Array(positionAttribute.count * 3), 3);
					this.setAttribute('normal', normalAttribute);
				} else {
					// reset existing normals to zero
					for (var i = 0, il = normalAttribute.count; i < il; i++) {
						normalAttribute.setXYZ(i, 0, 0, 0);
					}
				}

				var pA = new Vector3(),
						pB = new Vector3(),
						pC = new Vector3();
				var nA = new Vector3(),
						nB = new Vector3(),
						nC = new Vector3();
				var cb = new Vector3(),
						ab = new Vector3(); // indexed elements

				if (index) {
					for (var _i5 = 0, _il4 = index.count; _i5 < _il4; _i5 += 3) {
						var vA = index.getX(_i5 + 0);
						var vB = index.getX(_i5 + 1);
						var vC = index.getX(_i5 + 2);
						pA.fromBufferAttribute(positionAttribute, vA);
						pB.fromBufferAttribute(positionAttribute, vB);
						pC.fromBufferAttribute(positionAttribute, vC);
						cb.subVectors(pC, pB);
						ab.subVectors(pA, pB);
						cb.cross(ab);
						nA.fromBufferAttribute(normalAttribute, vA);
						nB.fromBufferAttribute(normalAttribute, vB);
						nC.fromBufferAttribute(normalAttribute, vC);
						nA.add(cb);
						nB.add(cb);
						nC.add(cb);
						normalAttribute.setXYZ(vA, nA.x, nA.y, nA.z);
						normalAttribute.setXYZ(vB, nB.x, nB.y, nB.z);
						normalAttribute.setXYZ(vC, nC.x, nC.y, nC.z);
					}
				} else {
					// non-indexed elements (unconnected triangle soup)
					for (var _i6 = 0, _il5 = positionAttribute.count; _i6 < _il5; _i6 += 3) {
						pA.fromBufferAttribute(positionAttribute, _i6 + 0);
						pB.fromBufferAttribute(positionAttribute, _i6 + 1);
						pC.fromBufferAttribute(positionAttribute, _i6 + 2);
						cb.subVectors(pC, pB);
						ab.subVectors(pA, pB);
						cb.cross(ab);
						normalAttribute.setXYZ(_i6 + 0, cb.x, cb.y, cb.z);
						normalAttribute.setXYZ(_i6 + 1, cb.x, cb.y, cb.z);
						normalAttribute.setXYZ(_i6 + 2, cb.x, cb.y, cb.z);
					}
				}

				this.normalizeNormals();
				normalAttribute.needsUpdate = true;
			}
		};

		_proto.merge = function merge(geometry, offset) {
			if (!(geometry && geometry.isBufferGeometry)) {
				console.error('THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry);
				return;
			}

			if (offset === undefined) {
				offset = 0;
				console.warn('THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. ' + 'Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.');
			}

			var attributes = this.attributes;

			for (var key in attributes) {
				if (geometry.attributes[key] === undefined) continue;
				var attribute1 = attributes[key];
				var attributeArray1 = attribute1.array;
				var attribute2 = geometry.attributes[key];
				var attributeArray2 = attribute2.array;
				var attributeOffset = attribute2.itemSize * offset;
				var length = Math.min(attributeArray2.length, attributeArray1.length - attributeOffset);

				for (var i = 0, j = attributeOffset; i < length; i++, j++) {
					attributeArray1[j] = attributeArray2[i];
				}
			}

			return this;
		};

		_proto.normalizeNormals = function normalizeNormals() {
			var normals = this.attributes.normal;

			for (var i = 0, il = normals.count; i < il; i++) {
				_vector$4.fromBufferAttribute(normals, i);

				_vector$4.normalize();

				normals.setXYZ(i, _vector$4.x, _vector$4.y, _vector$4.z);
			}
		};

		_proto.toNonIndexed = function toNonIndexed() {
			function convertBufferAttribute(attribute, indices) {
				var array = attribute.array;
				var itemSize = attribute.itemSize;
				var normalized = attribute.normalized;
				var array2 = new array.constructor(indices.length * itemSize);
				var index = 0,
						index2 = 0;

				for (var i = 0, l = indices.length; i < l; i++) {
					if (attribute.isInterleavedBufferAttribute) {
						index = indices[i] * attribute.data.stride + attribute.offset;
					} else {
						index = indices[i] * itemSize;
					}

					for (var j = 0; j < itemSize; j++) {
						array2[index2++] = array[index++];
					}
				}

				return new BufferAttribute(array2, itemSize, normalized);
			} //


			if (this.index === null) {
				console.warn('THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.');
				return this;
			}

			var geometry2 = new BufferGeometry();
			var indices = this.index.array;
			var attributes = this.attributes; // attributes

			for (var name in attributes) {
				var attribute = attributes[name];
				var newAttribute = convertBufferAttribute(attribute, indices);
				geometry2.setAttribute(name, newAttribute);
			} // morph attributes


			var morphAttributes = this.morphAttributes;

			for (var _name in morphAttributes) {
				var morphArray = [];
				var morphAttribute = morphAttributes[_name]; // morphAttribute: array of Float32BufferAttributes

				for (var i = 0, il = morphAttribute.length; i < il; i++) {
					var _attribute = morphAttribute[i];

					var _newAttribute = convertBufferAttribute(_attribute, indices);

					morphArray.push(_newAttribute);
				}

				geometry2.morphAttributes[_name] = morphArray;
			}

			geometry2.morphTargetsRelative = this.morphTargetsRelative; // groups

			var groups = this.groups;

			for (var _i7 = 0, l = groups.length; _i7 < l; _i7++) {
				var group = groups[_i7];
				geometry2.addGroup(group.start, group.count, group.materialIndex);
			}

			return geometry2;
		};

		_proto.toJSON = function toJSON() {
			var data = {
				metadata: {
					version: 4.5,
					type: 'BufferGeometry',
					generator: 'BufferGeometry.toJSON'
				}
			}; // standard BufferGeometry serialization

			data.uuid = this.uuid;
			data.type = this.type;
			if (this.name !== '') data.name = this.name;
			if (Object.keys(this.userData).length > 0) data.userData = this.userData;

			if (this.parameters !== undefined) {
				var parameters = this.parameters;

				for (var key in parameters) {
					if (parameters[key] !== undefined) data[key] = parameters[key];
				}

				return data;
			} // for simplicity the code assumes attributes are not shared across geometries, see #15811


			data.data = {
				attributes: {}
			};
			var index = this.index;

			if (index !== null) {
				data.data.index = {
					type: index.array.constructor.name,
					array: Array.prototype.slice.call(index.array)
				};
			}

			var attributes = this.attributes;

			for (var _key in attributes) {
				var attribute = attributes[_key];
				data.data.attributes[_key] = attribute.toJSON(data.data);
			}

			var morphAttributes = {};
			var hasMorphAttributes = false;

			for (var _key2 in this.morphAttributes) {
				var attributeArray = this.morphAttributes[_key2];
				var array = [];

				for (var i = 0, il = attributeArray.length; i < il; i++) {
					var _attribute2 = attributeArray[i];
					array.push(_attribute2.toJSON(data.data));
				}

				if (array.length > 0) {
					morphAttributes[_key2] = array;
					hasMorphAttributes = true;
				}
			}

			if (hasMorphAttributes) {
				data.data.morphAttributes = morphAttributes;
				data.data.morphTargetsRelative = this.morphTargetsRelative;
			}

			var groups = this.groups;

			if (groups.length > 0) {
				data.data.groups = JSON.parse(JSON.stringify(groups));
			}

			var boundingSphere = this.boundingSphere;

			if (boundingSphere !== null) {
				data.data.boundingSphere = {
					center: boundingSphere.center.toArray(),
					radius: boundingSphere.radius
				};
			}

			return data;
		};

		_proto.clone = function clone() {
			return new this.constructor().copy(this);
		};

		_proto.copy = function copy(source) {
			// reset
			this.index = null;
			this.attributes = {};
			this.morphAttributes = {};
			this.groups = [];
			this.boundingBox = null;
			this.boundingSphere = null; // used for storing cloned, shared data

			var data = {}; // name

			this.name = source.name; // index

			var index = source.index;

			if (index !== null) {
				this.setIndex(index.clone(data));
			} // attributes


			var attributes = source.attributes;

			for (var name in attributes) {
				var attribute = attributes[name];
				this.setAttribute(name, attribute.clone(data));
			} // morph attributes


			var morphAttributes = source.morphAttributes;

			for (var _name2 in morphAttributes) {
				var array = [];
				var morphAttribute = morphAttributes[_name2]; // morphAttribute: array of Float32BufferAttributes

				for (var i = 0, l = morphAttribute.length; i < l; i++) {
					array.push(morphAttribute[i].clone(data));
				}

				this.morphAttributes[_name2] = array;
			}

			this.morphTargetsRelative = source.morphTargetsRelative; // groups

			var groups = source.groups;

			for (var _i8 = 0, _l = groups.length; _i8 < _l; _i8++) {
				var group = groups[_i8];
				this.addGroup(group.start, group.count, group.materialIndex);
			} // bounding box


			var boundingBox = source.boundingBox;

			if (boundingBox !== null) {
				this.boundingBox = boundingBox.clone();
			} // bounding sphere


			var boundingSphere = source.boundingSphere;

			if (boundingSphere !== null) {
				this.boundingSphere = boundingSphere.clone();
			} // draw range


			this.drawRange.start = source.drawRange.start;
			this.drawRange.count = source.drawRange.count; // user data

			this.userData = source.userData; // geometry generator parameters

			if (source.parameters !== undefined) this.parameters = Object.assign({}, source.parameters);
			return this;
		};

		_proto.dispose = function dispose() {
			this.dispatchEvent({
				type: 'dispose'
			});
		};

		return BufferGeometry;
	}(EventDispatcher);

	BufferGeometry.prototype.isBufferGeometry = true;

	var _inverseMatrix = /*@__PURE__*/new Matrix4();

	var _ray = /*@__PURE__*/new Ray();

	var _sphere = /*@__PURE__*/new Sphere();

	var _vA = /*@__PURE__*/new Vector3();

	var _vB = /*@__PURE__*/new Vector3();

	var _vC = /*@__PURE__*/new Vector3();

	var _tempA = /*@__PURE__*/new Vector3();

	var _tempB = /*@__PURE__*/new Vector3();

	var _tempC = /*@__PURE__*/new Vector3();

	var _morphA = /*@__PURE__*/new Vector3();

	var _morphB = /*@__PURE__*/new Vector3();

	var _morphC = /*@__PURE__*/new Vector3();

	var _uvA = /*@__PURE__*/new Vector2();

	var _uvB = /*@__PURE__*/new Vector2();

	var _uvC = /*@__PURE__*/new Vector2();

	var _intersectionPoint = /*@__PURE__*/new Vector3();

	var _intersectionPointWorld = /*@__PURE__*/new Vector3();

	var Mesh = /*#__PURE__*/function (_Object3D) {
		_inheritsLoose(Mesh, _Object3D);

		function Mesh(geometry, material) {
			var _this;

			if (geometry === void 0) {
				geometry = new BufferGeometry();
			}

			if (material === void 0) {
				material = new MeshBasicMaterial();
			}

			_this = _Object3D.call(this) || this;
			_this.type = 'Mesh';
			_this.geometry = geometry;
			_this.material = material;

			_this.updateMorphTargets();

			return _this;
		}

		var _proto = Mesh.prototype;

		_proto.copy = function copy(source) {
			_Object3D.prototype.copy.call(this, source);

			if (source.morphTargetInfluences !== undefined) {
				this.morphTargetInfluences = source.morphTargetInfluences.slice();
			}

			if (source.morphTargetDictionary !== undefined) {
				this.morphTargetDictionary = Object.assign({}, source.morphTargetDictionary);
			}

			this.material = source.material;
			this.geometry = source.geometry;
			return this;
		};

		_proto.updateMorphTargets = function updateMorphTargets() {
			var geometry = this.geometry;

			if (geometry.isBufferGeometry) {
				var morphAttributes = geometry.morphAttributes;
				var keys = Object.keys(morphAttributes);

				if (keys.length > 0) {
					var morphAttribute = morphAttributes[keys[0]];

					if (morphAttribute !== undefined) {
						this.morphTargetInfluences = [];
						this.morphTargetDictionary = {};

						for (var m = 0, ml = morphAttribute.length; m < ml; m++) {
							var name = morphAttribute[m].name || String(m);
							this.morphTargetInfluences.push(0);
							this.morphTargetDictionary[name] = m;
						}
					}
				}
			} else {
				var morphTargets = geometry.morphTargets;

				if (morphTargets !== undefined && morphTargets.length > 0) {
					console.error('THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');
				}
			}
		};

		_proto.raycast = function raycast(raycaster, intersects) {
			var geometry = this.geometry;
			var material = this.material;
			var matrixWorld = this.matrixWorld;
			if (material === undefined) return; // Checking boundingSphere distance to ray

			if (geometry.boundingSphere === null) geometry.computeBoundingSphere();

			_sphere.copy(geometry.boundingSphere);

			_sphere.applyMatrix4(matrixWorld);

			if (raycaster.ray.intersectsSphere(_sphere) === false) return; //

			_inverseMatrix.copy(matrixWorld).invert();

			_ray.copy(raycaster.ray).applyMatrix4(_inverseMatrix); // Check boundingBox before continuing


			if (geometry.boundingBox !== null) {
				if (_ray.intersectsBox(geometry.boundingBox) === false) return;
			}

			var intersection;

			if (geometry.isBufferGeometry) {
				var index = geometry.index;
				var position = geometry.attributes.position;
				var morphPosition = geometry.morphAttributes.position;
				var morphTargetsRelative = geometry.morphTargetsRelative;
				var uv = geometry.attributes.uv;
				var uv2 = geometry.attributes.uv2;
				var groups = geometry.groups;
				var drawRange = geometry.drawRange;

				if (index !== null) {
					// indexed buffer geometry
					if (Array.isArray(material)) {
						for (var i = 0, il = groups.length; i < il; i++) {
							var group = groups[i];
							var groupMaterial = material[group.materialIndex];
							var start = Math.max(group.start, drawRange.start);
							var end = Math.min(index.count, Math.min(group.start + group.count, drawRange.start + drawRange.count));

							for (var j = start, jl = end; j < jl; j += 3) {
								var a = index.getX(j);
								var b = index.getX(j + 1);
								var c = index.getX(j + 2);
								intersection = checkBufferGeometryIntersection(this, groupMaterial, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);

								if (intersection) {
									intersection.faceIndex = Math.floor(j / 3); // triangle number in indexed buffer semantics

									intersection.face.materialIndex = group.materialIndex;
									intersects.push(intersection);
								}
							}
						}
					} else {
						var _start = Math.max(0, drawRange.start);

						var _end = Math.min(index.count, drawRange.start + drawRange.count);

						for (var _i = _start, _il = _end; _i < _il; _i += 3) {
							var _a = index.getX(_i);

							var _b = index.getX(_i + 1);

							var _c = index.getX(_i + 2);

							intersection = checkBufferGeometryIntersection(this, material, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, _a, _b, _c);

							if (intersection) {
								intersection.faceIndex = Math.floor(_i / 3); // triangle number in indexed buffer semantics

								intersects.push(intersection);
							}
						}
					}
				} else if (position !== undefined) {
					// non-indexed buffer geometry
					if (Array.isArray(material)) {
						for (var _i2 = 0, _il2 = groups.length; _i2 < _il2; _i2++) {
							var _group = groups[_i2];
							var _groupMaterial = material[_group.materialIndex];

							var _start2 = Math.max(_group.start, drawRange.start);

							var _end2 = Math.min(position.count, Math.min(_group.start + _group.count, drawRange.start + drawRange.count));

							for (var _j = _start2, _jl = _end2; _j < _jl; _j += 3) {
								var _a2 = _j;

								var _b2 = _j + 1;

								var _c2 = _j + 2;

								intersection = checkBufferGeometryIntersection(this, _groupMaterial, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, _a2, _b2, _c2);

								if (intersection) {
									intersection.faceIndex = Math.floor(_j / 3); // triangle number in non-indexed buffer semantics

									intersection.face.materialIndex = _group.materialIndex;
									intersects.push(intersection);
								}
							}
						}
					} else {
						var _start3 = Math.max(0, drawRange.start);

						var _end3 = Math.min(position.count, drawRange.start + drawRange.count);

						for (var _i3 = _start3, _il3 = _end3; _i3 < _il3; _i3 += 3) {
							var _a3 = _i3;

							var _b3 = _i3 + 1;

							var _c3 = _i3 + 2;

							intersection = checkBufferGeometryIntersection(this, material, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, _a3, _b3, _c3);

							if (intersection) {
								intersection.faceIndex = Math.floor(_i3 / 3); // triangle number in non-indexed buffer semantics

								intersects.push(intersection);
							}
						}
					}
				}
			} else if (geometry.isGeometry) {
				console.error('THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');
			}
		};

		return Mesh;
	}(Object3D);

	Mesh.prototype.isMesh = true;

	function checkIntersection(object, material, raycaster, ray, pA, pB, pC, point) {
		var intersect;

		if (material.side === BackSide) {
			intersect = ray.intersectTriangle(pC, pB, pA, true, point);
		} else {
			intersect = ray.intersectTriangle(pA, pB, pC, material.side !== DoubleSide, point);
		}

		if (intersect === null) return null;

		_intersectionPointWorld.copy(point);

		_intersectionPointWorld.applyMatrix4(object.matrixWorld);

		var distance = raycaster.ray.origin.distanceTo(_intersectionPointWorld);
		if (distance < raycaster.near || distance > raycaster.far) return null;
		return {
			distance: distance,
			point: _intersectionPointWorld.clone(),
			object: object
		};
	}

	function checkBufferGeometryIntersection(object, material, raycaster, ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c) {
		_vA.fromBufferAttribute(position, a);

		_vB.fromBufferAttribute(position, b);

		_vC.fromBufferAttribute(position, c);

		var morphInfluences = object.morphTargetInfluences;

		if (morphPosition && morphInfluences) {
			_morphA.set(0, 0, 0);

			_morphB.set(0, 0, 0);

			_morphC.set(0, 0, 0);

			for (var i = 0, il = morphPosition.length; i < il; i++) {
				var influence = morphInfluences[i];
				var morphAttribute = morphPosition[i];
				if (influence === 0) continue;

				_tempA.fromBufferAttribute(morphAttribute, a);

				_tempB.fromBufferAttribute(morphAttribute, b);

				_tempC.fromBufferAttribute(morphAttribute, c);

				if (morphTargetsRelative) {
					_morphA.addScaledVector(_tempA, influence);

					_morphB.addScaledVector(_tempB, influence);

					_morphC.addScaledVector(_tempC, influence);
				} else {
					_morphA.addScaledVector(_tempA.sub(_vA), influence);

					_morphB.addScaledVector(_tempB.sub(_vB), influence);

					_morphC.addScaledVector(_tempC.sub(_vC), influence);
				}
			}

			_vA.add(_morphA);

			_vB.add(_morphB);

			_vC.add(_morphC);
		}

		if (object.isSkinnedMesh) {
			object.boneTransform(a, _vA);
			object.boneTransform(b, _vB);
			object.boneTransform(c, _vC);
		}

		var intersection = checkIntersection(object, material, raycaster, ray, _vA, _vB, _vC, _intersectionPoint);

		if (intersection) {
			if (uv) {
				_uvA.fromBufferAttribute(uv, a);

				_uvB.fromBufferAttribute(uv, b);

				_uvC.fromBufferAttribute(uv, c);

				intersection.uv = Triangle.getUV(_intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2());
			}

			if (uv2) {
				_uvA.fromBufferAttribute(uv2, a);

				_uvB.fromBufferAttribute(uv2, b);

				_uvC.fromBufferAttribute(uv2, c);

				intersection.uv2 = Triangle.getUV(_intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2());
			}

			var face = {
				a: a,
				b: b,
				c: c,
				normal: new Vector3(),
				materialIndex: 0
			};
			Triangle.getNormal(_vA, _vB, _vC, face.normal);
			intersection.face = face;
		}

		return intersection;
	}

	var BoxGeometry = /*#__PURE__*/function (_BufferGeometry) {
		_inheritsLoose(BoxGeometry, _BufferGeometry);

		function BoxGeometry(width, height, depth, widthSegments, heightSegments, depthSegments) {
			var _this;

			if (width === void 0) {
				width = 1;
			}

			if (height === void 0) {
				height = 1;
			}

			if (depth === void 0) {
				depth = 1;
			}

			if (widthSegments === void 0) {
				widthSegments = 1;
			}

			if (heightSegments === void 0) {
				heightSegments = 1;
			}

			if (depthSegments === void 0) {
				depthSegments = 1;
			}

			_this = _BufferGeometry.call(this) || this;
			_this.type = 'BoxGeometry';
			_this.parameters = {
				width: width,
				height: height,
				depth: depth,
				widthSegments: widthSegments,
				heightSegments: heightSegments,
				depthSegments: depthSegments
			};

			var scope = _assertThisInitialized(_this); // segments


			widthSegments = Math.floor(widthSegments);
			heightSegments = Math.floor(heightSegments);
			depthSegments = Math.floor(depthSegments); // buffers

			var indices = [];
			var vertices = [];
			var normals = [];
			var uvs = []; // helper variables

			var numberOfVertices = 0;
			var groupStart = 0; // build each side of the box geometry

			buildPlane('z', 'y', 'x', -1, -1, depth, height, width, depthSegments, heightSegments, 0); // px

			buildPlane('z', 'y', 'x', 1, -1, depth, height, -width, depthSegments, heightSegments, 1); // nx

			buildPlane('x', 'z', 'y', 1, 1, width, depth, height, widthSegments, depthSegments, 2); // py

			buildPlane('x', 'z', 'y', 1, -1, width, depth, -height, widthSegments, depthSegments, 3); // ny

			buildPlane('x', 'y', 'z', 1, -1, width, height, depth, widthSegments, heightSegments, 4); // pz

			buildPlane('x', 'y', 'z', -1, -1, width, height, -depth, widthSegments, heightSegments, 5); // nz
			// build geometry

			_this.setIndex(indices);

			_this.setAttribute('position', new Float32BufferAttribute(vertices, 3));

			_this.setAttribute('normal', new Float32BufferAttribute(normals, 3));

			_this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));

			function buildPlane(u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex) {
				var segmentWidth = width / gridX;
				var segmentHeight = height / gridY;
				var widthHalf = width / 2;
				var heightHalf = height / 2;
				var depthHalf = depth / 2;
				var gridX1 = gridX + 1;
				var gridY1 = gridY + 1;
				var vertexCounter = 0;
				var groupCount = 0;
				var vector = new Vector3(); // generate vertices, normals and uvs

				for (var iy = 0; iy < gridY1; iy++) {
					var y = iy * segmentHeight - heightHalf;

					for (var ix = 0; ix < gridX1; ix++) {
						var x = ix * segmentWidth - widthHalf; // set values to correct vector component

						vector[u] = x * udir;
						vector[v] = y * vdir;
						vector[w] = depthHalf; // now apply vector to vertex buffer

						vertices.push(vector.x, vector.y, vector.z); // set values to correct vector component

						vector[u] = 0;
						vector[v] = 0;
						vector[w] = depth > 0 ? 1 : -1; // now apply vector to normal buffer

						normals.push(vector.x, vector.y, vector.z); // uvs

						uvs.push(ix / gridX);
						uvs.push(1 - iy / gridY); // counters

						vertexCounter += 1;
					}
				} // indices
				// 1. you need three indices to draw a single face
				// 2. a single segment consists of two faces
				// 3. so we need to generate six (2*3) indices per segment


				for (var _iy = 0; _iy < gridY; _iy++) {
					for (var _ix = 0; _ix < gridX; _ix++) {
						var a = numberOfVertices + _ix + gridX1 * _iy;
						var b = numberOfVertices + _ix + gridX1 * (_iy + 1);
						var c = numberOfVertices + (_ix + 1) + gridX1 * (_iy + 1);
						var d = numberOfVertices + (_ix + 1) + gridX1 * _iy; // faces

						indices.push(a, b, d);
						indices.push(b, c, d); // increase counter

						groupCount += 6;
					}
				} // add a group to the geometry. this will ensure multi material support


				scope.addGroup(groupStart, groupCount, materialIndex); // calculate new start value for groups

				groupStart += groupCount; // update total number of vertices

				numberOfVertices += vertexCounter;
			}

			return _this;
		}

		BoxGeometry.fromJSON = function fromJSON(data) {
			return new BoxGeometry(data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments);
		};

		return BoxGeometry;
	}(BufferGeometry);

	/**
	 * Uniform Utilities
	 */
	function cloneUniforms(src) {
		var dst = {};

		for (var u in src) {
			dst[u] = {};

			for (var p in src[u]) {
				var property = src[u][p];

				if (property && (property.isColor || property.isMatrix3 || property.isMatrix4 || property.isVector2 || property.isVector3 || property.isVector4 || property.isTexture || property.isQuaternion)) {
					dst[u][p] = property.clone();
				} else if (Array.isArray(property)) {
					dst[u][p] = property.slice();
				} else {
					dst[u][p] = property;
				}
			}
		}

		return dst;
	}
	function mergeUniforms(uniforms) {
		var merged = {};

		for (var u = 0; u < uniforms.length; u++) {
			var tmp = cloneUniforms(uniforms[u]);

			for (var p in tmp) {
				merged[p] = tmp[p];
			}
		}

		return merged;
	} // Legacy

	var UniformsUtils = {
		clone: cloneUniforms,
		merge: mergeUniforms
	};

	var default_vertex = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";

	var default_fragment = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";

	/**
	 * parameters = {
	 *	defines: { "label" : "value" },
	 *	uniforms: { "parameter1": { value: 1.0 }, "parameter2": { value2: 2 } },
	 *
	 *	fragmentShader: <string>,
	 *	vertexShader: <string>,
	 *
	 *	wireframe: <boolean>,
	 *	wireframeLinewidth: <float>,
	 *
	 *	lights: <bool>
	 * }
	 */

	var ShaderMaterial = /*#__PURE__*/function (_Material) {
		_inheritsLoose(ShaderMaterial, _Material);

		function ShaderMaterial(parameters) {
			var _this;

			_this = _Material.call(this) || this;
			_this.type = 'ShaderMaterial';
			_this.defines = {};
			_this.uniforms = {};
			_this.vertexShader = default_vertex;
			_this.fragmentShader = default_fragment;
			_this.linewidth = 1;
			_this.wireframe = false;
			_this.wireframeLinewidth = 1;
			_this.fog = false; // set to use scene fog

			_this.lights = false; // set to use scene lights

			_this.clipping = false; // set to use user-defined clipping planes

			_this.extensions = {
				derivatives: false,
				// set to use derivatives
				fragDepth: false,
				// set to use fragment depth values
				drawBuffers: false,
				// set to use draw buffers
				shaderTextureLOD: false // set to use shader texture LOD

			}; // When rendered geometry doesn't include these attributes but the material does,
			// use these default values in WebGL. This avoids errors when buffer data is missing.

			_this.defaultAttributeValues = {
				'color': [1, 1, 1],
				'uv': [0, 0],
				'uv2': [0, 0]
			};
			_this.index0AttributeName = undefined;
			_this.uniformsNeedUpdate = false;
			_this.glslVersion = null;

			if (parameters !== undefined) {
				if (parameters.attributes !== undefined) {
					console.error('THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.');
				}

				_this.setValues(parameters);
			}

			return _this;
		}

		var _proto = ShaderMaterial.prototype;

		_proto.copy = function copy(source) {
			_Material.prototype.copy.call(this, source);

			this.fragmentShader = source.fragmentShader;
			this.vertexShader = source.vertexShader;
			this.uniforms = cloneUniforms(source.uniforms);
			this.defines = Object.assign({}, source.defines);
			this.wireframe = source.wireframe;
			this.wireframeLinewidth = source.wireframeLinewidth;
			this.lights = source.lights;
			this.clipping = source.clipping;
			this.extensions = Object.assign({}, source.extensions);
			this.glslVersion = source.glslVersion;
			return this;
		};

		_proto.toJSON = function toJSON(meta) {
			var data = _Material.prototype.toJSON.call(this, meta);

			data.glslVersion = this.glslVersion;
			data.uniforms = {};

			for (var name in this.uniforms) {
				var uniform = this.uniforms[name];
				var value = uniform.value;

				if (value && value.isTexture) {
					data.uniforms[name] = {
						type: 't',
						value: value.toJSON(meta).uuid
					};
				} else if (value && value.isColor) {
					data.uniforms[name] = {
						type: 'c',
						value: value.getHex()
					};
				} else if (value && value.isVector2) {
					data.uniforms[name] = {
						type: 'v2',
						value: value.toArray()
					};
				} else if (value && value.isVector3) {
					data.uniforms[name] = {
						type: 'v3',
						value: value.toArray()
					};
				} else if (value && value.isVector4) {
					data.uniforms[name] = {
						type: 'v4',
						value: value.toArray()
					};
				} else if (value && value.isMatrix3) {
					data.uniforms[name] = {
						type: 'm3',
						value: value.toArray()
					};
				} else if (value && value.isMatrix4) {
					data.uniforms[name] = {
						type: 'm4',
						value: value.toArray()
					};
				} else {
					data.uniforms[name] = {
						value: value
					}; // note: the array variants v2v, v3v, v4v, m4v and tv are not supported so far
				}
			}

			if (Object.keys(this.defines).length > 0) data.defines = this.defines;
			data.vertexShader = this.vertexShader;
			data.fragmentShader = this.fragmentShader;
			var extensions = {};

			for (var key in this.extensions) {
				if (this.extensions[key] === true) extensions[key] = true;
			}

			if (Object.keys(extensions).length > 0) data.extensions = extensions;
			return data;
		};

		return ShaderMaterial;
	}(Material);

	ShaderMaterial.prototype.isShaderMaterial = true;

	var Camera = /*#__PURE__*/function (_Object3D) {
		_inheritsLoose(Camera, _Object3D);

		function Camera() {
			var _this;

			_this = _Object3D.call(this) || this;
			_this.type = 'Camera';
			_this.matrixWorldInverse = new Matrix4();
			_this.projectionMatrix = new Matrix4();
			_this.projectionMatrixInverse = new Matrix4();
			return _this;
		}

		var _proto = Camera.prototype;

		_proto.copy = function copy(source, recursive) {
			_Object3D.prototype.copy.call(this, source, recursive);

			this.matrixWorldInverse.copy(source.matrixWorldInverse);
			this.projectionMatrix.copy(source.projectionMatrix);
			this.projectionMatrixInverse.copy(source.projectionMatrixInverse);
			return this;
		};

		_proto.getWorldDirection = function getWorldDirection(target) {
			this.updateWorldMatrix(true, false);
			var e = this.matrixWorld.elements;
			return target.set(-e[8], -e[9], -e[10]).normalize();
		};

		_proto.updateMatrixWorld = function updateMatrixWorld(force) {
			_Object3D.prototype.updateMatrixWorld.call(this, force);

			this.matrixWorldInverse.copy(this.matrixWorld).invert();
		};

		_proto.updateWorldMatrix = function updateWorldMatrix(updateParents, updateChildren) {
			_Object3D.prototype.updateWorldMatrix.call(this, updateParents, updateChildren);

			this.matrixWorldInverse.copy(this.matrixWorld).invert();
		};

		_proto.clone = function clone() {
			return new this.constructor().copy(this);
		};

		return Camera;
	}(Object3D);

	Camera.prototype.isCamera = true;

	var PerspectiveCamera = /*#__PURE__*/function (_Camera) {
		_inheritsLoose(PerspectiveCamera, _Camera);

		function PerspectiveCamera(fov, aspect, near, far) {
			var _this;

			if (fov === void 0) {
				fov = 50;
			}

			if (aspect === void 0) {
				aspect = 1;
			}

			if (near === void 0) {
				near = 0.1;
			}

			if (far === void 0) {
				far = 2000;
			}

			_this = _Camera.call(this) || this;
			_this.type = 'PerspectiveCamera';
			_this.fov = fov;
			_this.zoom = 1;
			_this.near = near;
			_this.far = far;
			_this.focus = 10;
			_this.aspect = aspect;
			_this.view = null;
			_this.filmGauge = 35; // width of the film (default in millimeters)

			_this.filmOffset = 0; // horizontal film offset (same unit as gauge)

			_this.updateProjectionMatrix();

			return _this;
		}

		var _proto = PerspectiveCamera.prototype;

		_proto.copy = function copy(source, recursive) {
			_Camera.prototype.copy.call(this, source, recursive);

			this.fov = source.fov;
			this.zoom = source.zoom;
			this.near = source.near;
			this.far = source.far;
			this.focus = source.focus;
			this.aspect = source.aspect;
			this.view = source.view === null ? null : Object.assign({}, source.view);
			this.filmGauge = source.filmGauge;
			this.filmOffset = source.filmOffset;
			return this;
		}
		/**
		 * Sets the FOV by focal length in respect to the current .filmGauge.
		 *
		 * The default film gauge is 35, so that the focal length can be specified for
		 * a 35mm (full frame) camera.
		 *
		 * Values for focal length and film gauge must have the same unit.
		 */
		;

		_proto.setFocalLength = function setFocalLength(focalLength) {
			/** see {@link http://www.bobatkins.com/photography/technical/field_of_view.html} */
			var vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;
			this.fov = RAD2DEG * 2 * Math.atan(vExtentSlope);
			this.updateProjectionMatrix();
		}
		/**
		 * Calculates the focal length from the current .fov and .filmGauge.
		 */
		;

		_proto.getFocalLength = function getFocalLength() {
			var vExtentSlope = Math.tan(DEG2RAD * 0.5 * this.fov);
			return 0.5 * this.getFilmHeight() / vExtentSlope;
		};

		_proto.getEffectiveFOV = function getEffectiveFOV() {
			return RAD2DEG * 2 * Math.atan(Math.tan(DEG2RAD * 0.5 * this.fov) / this.zoom);
		};

		_proto.getFilmWidth = function getFilmWidth() {
			// film not completely covered in portrait format (aspect < 1)
			return this.filmGauge * Math.min(this.aspect, 1);
		};

		_proto.getFilmHeight = function getFilmHeight() {
			// film not completely covered in landscape format (aspect > 1)
			return this.filmGauge / Math.max(this.aspect, 1);
		}
		/**
		 * Sets an offset in a larger frustum. This is useful for multi-window or
		 * multi-monitor/multi-machine setups.
		 *
		 * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
		 * the monitors are in grid like this
		 *
		 *	 +---+---+---+
		 *	 | A | B | C |
		 *	 +---+---+---+
		 *	 | D | E | F |
		 *	 +---+---+---+
		 *
		 * then for each monitor you would call it like this
		 *
		 *	 const w = 1920;
		 *	 const h = 1080;
		 *	 const fullWidth = w * 3;
		 *	 const fullHeight = h * 2;
		 *
		 *	 --A--
		 *	 camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
		 *	 --B--
		 *	 camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
		 *	 --C--
		 *	 camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
		 *	 --D--
		 *	 camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
		 *	 --E--
		 *	 camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
		 *	 --F--
		 *	 camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
		 *
		 *	 Note there is no reason monitors have to be the same size or in a grid.
		 */
		;

		_proto.setViewOffset = function setViewOffset(fullWidth, fullHeight, x, y, width, height) {
			this.aspect = fullWidth / fullHeight;

			if (this.view === null) {
				this.view = {
					enabled: true,
					fullWidth: 1,
					fullHeight: 1,
					offsetX: 0,
					offsetY: 0,
					width: 1,
					height: 1
				};
			}

			this.view.enabled = true;
			this.view.fullWidth = fullWidth;
			this.view.fullHeight = fullHeight;
			this.view.offsetX = x;
			this.view.offsetY = y;
			this.view.width = width;
			this.view.height = height;
			this.updateProjectionMatrix();
		};

		_proto.clearViewOffset = function clearViewOffset() {
			if (this.view !== null) {
				this.view.enabled = false;
			}

			this.updateProjectionMatrix();
		};

		_proto.updateProjectionMatrix = function updateProjectionMatrix() {
			var near = this.near;
			var top = near * Math.tan(DEG2RAD * 0.5 * this.fov) / this.zoom;
			var height = 2 * top;
			var width = this.aspect * height;
			var left = -0.5 * width;
			var view = this.view;

			if (this.view !== null && this.view.enabled) {
				var fullWidth = view.fullWidth,
						fullHeight = view.fullHeight;
				left += view.offsetX * width / fullWidth;
				top -= view.offsetY * height / fullHeight;
				width *= view.width / fullWidth;
				height *= view.height / fullHeight;
			}

			var skew = this.filmOffset;
			if (skew !== 0) left += near * skew / this.getFilmWidth();
			this.projectionMatrix.makePerspective(left, left + width, top, top - height, near, this.far);
			this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
		};

		_proto.toJSON = function toJSON(meta) {
			var data = _Camera.prototype.toJSON.call(this, meta);

			data.object.fov = this.fov;
			data.object.zoom = this.zoom;
			data.object.near = this.near;
			data.object.far = this.far;
			data.object.focus = this.focus;
			data.object.aspect = this.aspect;
			if (this.view !== null) data.object.view = Object.assign({}, this.view);
			data.object.filmGauge = this.filmGauge;
			data.object.filmOffset = this.filmOffset;
			return data;
		};

		return PerspectiveCamera;
	}(Camera);

	PerspectiveCamera.prototype.isPerspectiveCamera = true;

	var fov = 90,
			aspect = 1;

	var CubeCamera = /*#__PURE__*/function (_Object3D) {
		_inheritsLoose(CubeCamera, _Object3D);

		function CubeCamera(near, far, renderTarget) {
			var _this;

			_this = _Object3D.call(this) || this;
			_this.type = 'CubeCamera';

			if (renderTarget.isWebGLCubeRenderTarget !== true) {
				console.error('THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.');
				return _assertThisInitialized(_this);
			}

			_this.renderTarget = renderTarget;
			var cameraPX = new PerspectiveCamera(fov, aspect, near, far);
			cameraPX.layers = _this.layers;
			cameraPX.up.set(0, -1, 0);
			cameraPX.lookAt(new Vector3(1, 0, 0));

			_this.add(cameraPX);

			var cameraNX = new PerspectiveCamera(fov, aspect, near, far);
			cameraNX.layers = _this.layers;
			cameraNX.up.set(0, -1, 0);
			cameraNX.lookAt(new Vector3(-1, 0, 0));

			_this.add(cameraNX);

			var cameraPY = new PerspectiveCamera(fov, aspect, near, far);
			cameraPY.layers = _this.layers;
			cameraPY.up.set(0, 0, 1);
			cameraPY.lookAt(new Vector3(0, 1, 0));

			_this.add(cameraPY);

			var cameraNY = new PerspectiveCamera(fov, aspect, near, far);
			cameraNY.layers = _this.layers;
			cameraNY.up.set(0, 0, -1);
			cameraNY.lookAt(new Vector3(0, -1, 0));

			_this.add(cameraNY);

			var cameraPZ = new PerspectiveCamera(fov, aspect, near, far);
			cameraPZ.layers = _this.layers;
			cameraPZ.up.set(0, -1, 0);
			cameraPZ.lookAt(new Vector3(0, 0, 1));

			_this.add(cameraPZ);

			var cameraNZ = new PerspectiveCamera(fov, aspect, near, far);
			cameraNZ.layers = _this.layers;
			cameraNZ.up.set(0, -1, 0);
			cameraNZ.lookAt(new Vector3(0, 0, -1));

			_this.add(cameraNZ);

			return _this;
		}

		var _proto = CubeCamera.prototype;

		_proto.update = function update(renderer, scene) {
			if (this.parent === null) this.updateMatrixWorld();
			var renderTarget = this.renderTarget;
			var _this$children = this.children,
					cameraPX = _this$children[0],
					cameraNX = _this$children[1],
					cameraPY = _this$children[2],
					cameraNY = _this$children[3],
					cameraPZ = _this$children[4],
					cameraNZ = _this$children[5];
			var currentXrEnabled = renderer.xr.enabled;
			var currentRenderTarget = renderer.getRenderTarget();
			renderer.xr.enabled = false;
			var generateMipmaps = renderTarget.texture.generateMipmaps;
			renderTarget.texture.generateMipmaps = false;
			renderer.setRenderTarget(renderTarget, 0);
			renderer.render(scene, cameraPX);
			renderer.setRenderTarget(renderTarget, 1);
			renderer.render(scene, cameraNX);
			renderer.setRenderTarget(renderTarget, 2);
			renderer.render(scene, cameraPY);
			renderer.setRenderTarget(renderTarget, 3);
			renderer.render(scene, cameraNY);
			renderer.setRenderTarget(renderTarget, 4);
			renderer.render(scene, cameraPZ);
			renderTarget.texture.generateMipmaps = generateMipmaps;
			renderer.setRenderTarget(renderTarget, 5);
			renderer.render(scene, cameraNZ);
			renderer.setRenderTarget(currentRenderTarget);
			renderer.xr.enabled = currentXrEnabled;
		};

		return CubeCamera;
	}(Object3D);

	var CubeTexture = /*#__PURE__*/function (_Texture) {
		_inheritsLoose(CubeTexture, _Texture);

		function CubeTexture(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding) {
			var _this;

			images = images !== undefined ? images : [];
			mapping = mapping !== undefined ? mapping : CubeReflectionMapping;
			_this = _Texture.call(this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding) || this;
			_this.flipY = false;
			return _this;
		}

		_createClass(CubeTexture, [{
			key: "images",
			get: function get() {
				return this.image;
			},
			set: function set(value) {
				this.image = value;
			}
		}]);

		return CubeTexture;
	}(Texture);

	CubeTexture.prototype.isCubeTexture = true;

	var WebGLCubeRenderTarget = /*#__PURE__*/function (_WebGLRenderTarget) {
		_inheritsLoose(WebGLCubeRenderTarget, _WebGLRenderTarget);

		function WebGLCubeRenderTarget(size, options, dummy) {
			var _this;

			if (Number.isInteger(options)) {
				console.warn('THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )');
				options = dummy;
			}

			_this = _WebGLRenderTarget.call(this, size, size, options) || this;
			options = options || {}; // By convention -- likely based on the RenderMan spec from the 1990's -- cube maps are specified by WebGL (and three.js)
			// in a coordinate system in which positive-x is to the right when looking up the positive-z axis -- in other words,
			// in a left-handed coordinate system. By continuing this convention, preexisting cube maps continued to render correctly.
			// three.js uses a right-handed coordinate system. So environment maps used in three.js appear to have px and nx swapped
			// and the flag isRenderTargetTexture controls this conversion. The flip is not required when using WebGLCubeRenderTarget.texture
			// as a cube texture (this is detected when isRenderTargetTexture is set to true for cube textures).

			_this.texture = new CubeTexture(undefined, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding);
			_this.texture.isRenderTargetTexture = true;
			_this.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : false;
			_this.texture.minFilter = options.minFilter !== undefined ? options.minFilter : LinearFilter;
			_this.texture._needsFlipEnvMap = false;
			return _this;
		}

		var _proto = WebGLCubeRenderTarget.prototype;

		_proto.fromEquirectangularTexture = function fromEquirectangularTexture(renderer, texture) {
			this.texture.type = texture.type;
			this.texture.format = RGBAFormat; // see #18859

			this.texture.encoding = texture.encoding;
			this.texture.generateMipmaps = texture.generateMipmaps;
			this.texture.minFilter = texture.minFilter;
			this.texture.magFilter = texture.magFilter;
			var shader = {
				uniforms: {
					tEquirect: {
						value: null
					}
				},
				vertexShader:
				/* glsl */
				"\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t",
				fragmentShader:
				/* glsl */
				"\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t"
			};
			var geometry = new BoxGeometry(5, 5, 5);
			var material = new ShaderMaterial({
				name: 'CubemapFromEquirect',
				uniforms: cloneUniforms(shader.uniforms),
				vertexShader: shader.vertexShader,
				fragmentShader: shader.fragmentShader,
				side: BackSide,
				blending: NoBlending
			});
			material.uniforms.tEquirect.value = texture;
			var mesh = new Mesh(geometry, material);
			var currentMinFilter = texture.minFilter; // Avoid blurred poles

			if (texture.minFilter === LinearMipmapLinearFilter) texture.minFilter = LinearFilter;
			var camera = new CubeCamera(1, 10, this);
			camera.update(renderer, mesh);
			texture.minFilter = currentMinFilter;
			mesh.geometry.dispose();
			mesh.material.dispose();
			return this;
		};

		_proto.clear = function clear(renderer, color, depth, stencil) {
			var currentRenderTarget = renderer.getRenderTarget();

			for (var i = 0; i < 6; i++) {
				renderer.setRenderTarget(this, i);
				renderer.clear(color, depth, stencil);
			}

			renderer.setRenderTarget(currentRenderTarget);
		};

		return WebGLCubeRenderTarget;
	}(WebGLRenderTarget);

	WebGLCubeRenderTarget.prototype.isWebGLCubeRenderTarget = true;

	var _vector1 = /*@__PURE__*/new Vector3();

	var _vector2$1 = /*@__PURE__*/new Vector3();

	var _normalMatrix = /*@__PURE__*/new Matrix3();

	var Plane = /*#__PURE__*/function () {
		function Plane(normal, constant) {
			if (normal === void 0) {
				normal = new Vector3(1, 0, 0);
			}

			if (constant === void 0) {
				constant = 0;
			}

			// normal is assumed to be normalized
			this.normal = normal;
			this.constant = constant;
		}

		var _proto = Plane.prototype;

		_proto.set = function set(normal, constant) {
			this.normal.copy(normal);
			this.constant = constant;
			return this;
		};

		_proto.setComponents = function setComponents(x, y, z, w) {
			this.normal.set(x, y, z);
			this.constant = w;
			return this;
		};

		_proto.setFromNormalAndCoplanarPoint = function setFromNormalAndCoplanarPoint(normal, point) {
			this.normal.copy(normal);
			this.constant = -point.dot(this.normal);
			return this;
		};

		_proto.setFromCoplanarPoints = function setFromCoplanarPoints(a, b, c) {
			var normal = _vector1.subVectors(c, b).cross(_vector2$1.subVectors(a, b)).normalize(); // Q: should an error be thrown if normal is zero (e.g. degenerate plane)?


			this.setFromNormalAndCoplanarPoint(normal, a);
			return this;
		};

		_proto.copy = function copy(plane) {
			this.normal.copy(plane.normal);
			this.constant = plane.constant;
			return this;
		};

		_proto.normalize = function normalize() {
			// Note: will lead to a divide by zero if the plane is invalid.
			var inverseNormalLength = 1.0 / this.normal.length();
			this.normal.multiplyScalar(inverseNormalLength);
			this.constant *= inverseNormalLength;
			return this;
		};

		_proto.negate = function negate() {
			this.constant *= -1;
			this.normal.negate();
			return this;
		};

		_proto.distanceToPoint = function distanceToPoint(point) {
			return this.normal.dot(point) + this.constant;
		};

		_proto.distanceToSphere = function distanceToSphere(sphere) {
			return this.distanceToPoint(sphere.center) - sphere.radius;
		};

		_proto.projectPoint = function projectPoint(point, target) {
			return target.copy(this.normal).multiplyScalar(-this.distanceToPoint(point)).add(point);
		};

		_proto.intersectLine = function intersectLine(line, target) {
			var direction = line.delta(_vector1);
			var denominator = this.normal.dot(direction);

			if (denominator === 0) {
				// line is coplanar, return origin
				if (this.distanceToPoint(line.start) === 0) {
					return target.copy(line.start);
				} // Unsure if this is the correct method to handle this case.


				return null;
			}

			var t = -(line.start.dot(this.normal) + this.constant) / denominator;

			if (t < 0 || t > 1) {
				return null;
			}

			return target.copy(direction).multiplyScalar(t).add(line.start);
		};

		_proto.intersectsLine = function intersectsLine(line) {
			// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.
			var startSign = this.distanceToPoint(line.start);
			var endSign = this.distanceToPoint(line.end);
			return startSign < 0 && endSign > 0 || endSign < 0 && startSign > 0;
		};

		_proto.intersectsBox = function intersectsBox(box) {
			return box.intersectsPlane(this);
		};

		_proto.intersectsSphere = function intersectsSphere(sphere) {
			return sphere.intersectsPlane(this);
		};

		_proto.coplanarPoint = function coplanarPoint(target) {
			return target.copy(this.normal).multiplyScalar(-this.constant);
		};

		_proto.applyMatrix4 = function applyMatrix4(matrix, optionalNormalMatrix) {
			var normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix(matrix);

			var referencePoint = this.coplanarPoint(_vector1).applyMatrix4(matrix);
			var normal = this.normal.applyMatrix3(normalMatrix).normalize();
			this.constant = -referencePoint.dot(normal);
			return this;
		};

		_proto.translate = function translate(offset) {
			this.constant -= offset.dot(this.normal);
			return this;
		};

		_proto.equals = function equals(plane) {
			return plane.normal.equals(this.normal) && plane.constant === this.constant;
		};

		_proto.clone = function clone() {
			return new this.constructor().copy(this);
		};

		return Plane;
	}();

	Plane.prototype.isPlane = true;

	var _sphere$1 = /*@__PURE__*/new Sphere();

	var _vector$5 = /*@__PURE__*/new Vector3();

	var Frustum = /*#__PURE__*/function () {
		function Frustum(p0, p1, p2, p3, p4, p5) {
			if (p0 === void 0) {
				p0 = new Plane();
			}

			if (p1 === void 0) {
				p1 = new Plane();
			}

			if (p2 === void 0) {
				p2 = new Plane();
			}

			if (p3 === void 0) {
				p3 = new Plane();
			}

			if (p4 === void 0) {
				p4 = new Plane();
			}

			if (p5 === void 0) {
				p5 = new Plane();
			}

			this.planes = [p0, p1, p2, p3, p4, p5];
		}

		var _proto = Frustum.prototype;

		_proto.set = function set(p0, p1, p2, p3, p4, p5) {
			var planes = this.planes;
			planes[0].copy(p0);
			planes[1].copy(p1);
			planes[2].copy(p2);
			planes[3].copy(p3);
			planes[4].copy(p4);
			planes[5].copy(p5);
			return this;
		};

		_proto.copy = function copy(frustum) {
			var planes = this.planes;

			for (var i = 0; i < 6; i++) {
				planes[i].copy(frustum.planes[i]);
			}

			return this;
		};

		_proto.setFromProjectionMatrix = function setFromProjectionMatrix(m) {
			var planes = this.planes;
			var me = m.elements;
			var me0 = me[0],
					me1 = me[1],
					me2 = me[2],
					me3 = me[3];
			var me4 = me[4],
					me5 = me[5],
					me6 = me[6],
					me7 = me[7];
			var me8 = me[8],
					me9 = me[9],
					me10 = me[10],
					me11 = me[11];
			var me12 = me[12],
					me13 = me[13],
					me14 = me[14],
					me15 = me[15];
			planes[0].setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12).normalize();
			planes[1].setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12).normalize();
			planes[2].setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13).normalize();
			planes[3].setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13).normalize();
			planes[4].setComponents(me3 - me2, me7 - me6, me11 - me10, me15 - me14).normalize();
			planes[5].setComponents(me3 + me2, me7 + me6, me11 + me10, me15 + me14).normalize();
			return this;
		};

		_proto.intersectsObject = function intersectsObject(object) {
			var geometry = object.geometry;
			if (geometry.boundingSphere === null) geometry.computeBoundingSphere();

			_sphere$1.copy(geometry.boundingSphere).applyMatrix4(object.matrixWorld);

			return this.intersectsSphere(_sphere$1);
		};

		_proto.intersectsSprite = function intersectsSprite(sprite) {
			_sphere$1.center.set(0, 0, 0);

			_sphere$1.radius = 0.7071067811865476;

			_sphere$1.applyMatrix4(sprite.matrixWorld);

			return this.intersectsSphere(_sphere$1);
		};

		_proto.intersectsSphere = function intersectsSphere(sphere) {
			var planes = this.planes;
			var center = sphere.center;
			var negRadius = -sphere.radius;

			for (var i = 0; i < 6; i++) {
				var distance = planes[i].distanceToPoint(center);

				if (distance < negRadius) {
					return false;
				}
			}

			return true;
		};

		_proto.intersectsBox = function intersectsBox(box) {
			var planes = this.planes;

			for (var i = 0; i < 6; i++) {
				var plane = planes[i]; // corner at max distance

				_vector$5.x = plane.normal.x > 0 ? box.max.x : box.min.x;
				_vector$5.y = plane.normal.y > 0 ? box.max.y : box.min.y;
				_vector$5.z = plane.normal.z > 0 ? box.max.z : box.min.z;

				if (plane.distanceToPoint(_vector$5) < 0) {
					return false;
				}
			}

			return true;
		};

		_proto.containsPoint = function containsPoint(point) {
			var planes = this.planes;

			for (var i = 0; i < 6; i++) {
				if (planes[i].distanceToPoint(point) < 0) {
					return false;
				}
			}

			return true;
		};

		_proto.clone = function clone() {
			return new this.constructor().copy(this);
		};

		return Frustum;
	}();

	function WebGLAnimation() {
		var context = null;
		var isAnimating = false;
		var animationLoop = null;
		var requestId = null;

		function onAnimationFrame(time, frame) {
			animationLoop(time, frame);
			requestId = context.requestAnimationFrame(onAnimationFrame);
		}

		return {
			start: function start() {
				if (isAnimating === true) return;
				if (animationLoop === null) return;
				requestId = context.requestAnimationFrame(onAnimationFrame);
				isAnimating = true;
			},
			stop: function stop() {
				context.cancelAnimationFrame(requestId);
				isAnimating = false;
			},
			setAnimationLoop: function setAnimationLoop(callback) {
				animationLoop = callback;
			},
			setContext: function setContext(value) {
				context = value;
			}
		};
	}

	function WebGLAttributes(gl, capabilities) {
		var isWebGL2 = capabilities.isWebGL2;
		var buffers = new WeakMap();

		function createBuffer(attribute, bufferType) {
			var array = attribute.array;
			var usage = attribute.usage;
			var buffer = gl.createBuffer();
			gl.bindBuffer(bufferType, buffer);
			gl.bufferData(bufferType, array, usage);
			attribute.onUploadCallback();
			var type = gl.FLOAT;

			if (array instanceof Float32Array) {
				type = gl.FLOAT;
			} else if (array instanceof Float64Array) {
				console.warn('THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.');
			} else if (array instanceof Uint16Array) {
				if (attribute.isFloat16BufferAttribute) {
					if (isWebGL2) {
						type = gl.HALF_FLOAT;
					} else {
						console.warn('THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.');
					}
				} else {
					type = gl.UNSIGNED_SHORT;
				}
			} else if (array instanceof Int16Array) {
				type = gl.SHORT;
			} else if (array instanceof Uint32Array) {
				type = gl.UNSIGNED_INT;
			} else if (array instanceof Int32Array) {
				type = gl.INT;
			} else if (array instanceof Int8Array) {
				type = gl.BYTE;
			} else if (array instanceof Uint8Array) {
				type = gl.UNSIGNED_BYTE;
			} else if (array instanceof Uint8ClampedArray) {
				type = gl.UNSIGNED_BYTE;
			}

			return {
				buffer: buffer,
				type: type,
				bytesPerElement: array.BYTES_PER_ELEMENT,
				version: attribute.version
			};
		}

		function updateBuffer(buffer, attribute, bufferType) {
			var array = attribute.array;
			var updateRange = attribute.updateRange;
			gl.bindBuffer(bufferType, buffer);

			if (updateRange.count === -1) {
				// Not using update ranges
				gl.bufferSubData(bufferType, 0, array);
			} else {
				if (isWebGL2) {
					gl.bufferSubData(bufferType, updateRange.offset * array.BYTES_PER_ELEMENT, array, updateRange.offset, updateRange.count);
				} else {
					gl.bufferSubData(bufferType, updateRange.offset * array.BYTES_PER_ELEMENT, array.subarray(updateRange.offset, updateRange.offset + updateRange.count));
				}

				updateRange.count = -1; // reset range
			}
		} //


		function get(attribute) {
			if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;
			return buffers.get(attribute);
		}

		function remove(attribute) {
			if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;
			var data = buffers.get(attribute);

			if (data) {
				gl.deleteBuffer(data.buffer);
				buffers.delete(attribute);
			}
		}

		function update(attribute, bufferType) {
			if (attribute.isGLBufferAttribute) {
				var cached = buffers.get(attribute);

				if (!cached || cached.version < attribute.version) {
					buffers.set(attribute, {
						buffer: attribute.buffer,
						type: attribute.type,
						bytesPerElement: attribute.elementSize,
						version: attribute.version
					});
				}

				return;
			}

			if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;
			var data = buffers.get(attribute);

			if (data === undefined) {
				buffers.set(attribute, createBuffer(attribute, bufferType));
			} else if (data.version < attribute.version) {
				updateBuffer(data.buffer, attribute, bufferType);
				data.version = attribute.version;
			}
		}

		return {
			get: get,
			remove: remove,
			update: update
		};
	}

	var PlaneGeometry = /*#__PURE__*/function (_BufferGeometry) {
		_inheritsLoose(PlaneGeometry, _BufferGeometry);

		function PlaneGeometry(width, height, widthSegments, heightSegments) {
			var _this;

			if (width === void 0) {
				width = 1;
			}

			if (height === void 0) {
				height = 1;
			}

			if (widthSegments === void 0) {
				widthSegments = 1;
			}

			if (heightSegments === void 0) {
				heightSegments = 1;
			}

			_this = _BufferGeometry.call(this) || this;
			_this.type = 'PlaneGeometry';
			_this.parameters = {
				width: width,
				height: height,
				widthSegments: widthSegments,
				heightSegments: heightSegments
			};
			var width_half = width / 2;
			var height_half = height / 2;
			var gridX = Math.floor(widthSegments);
			var gridY = Math.floor(heightSegments);
			var gridX1 = gridX + 1;
			var gridY1 = gridY + 1;
			var segment_width = width / gridX;
			var segment_height = height / gridY; //

			var indices = [];
			var vertices = [];
			var normals = [];
			var uvs = [];

			for (var iy = 0; iy < gridY1; iy++) {
				var y = iy * segment_height - height_half;

				for (var ix = 0; ix < gridX1; ix++) {
					var x = ix * segment_width - width_half;
					vertices.push(x, -y, 0);
					normals.push(0, 0, 1);
					uvs.push(ix / gridX);
					uvs.push(1 - iy / gridY);
				}
			}

			for (var _iy = 0; _iy < gridY; _iy++) {
				for (var _ix = 0; _ix < gridX; _ix++) {
					var a = _ix + gridX1 * _iy;
					var b = _ix + gridX1 * (_iy + 1);
					var c = _ix + 1 + gridX1 * (_iy + 1);
					var d = _ix + 1 + gridX1 * _iy;
					indices.push(a, b, d);
					indices.push(b, c, d);
				}
			}

			_this.setIndex(indices);

			_this.setAttribute('position', new Float32BufferAttribute(vertices, 3));

			_this.setAttribute('normal', new Float32BufferAttribute(normals, 3));

			_this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));

			return _this;
		}

		PlaneGeometry.fromJSON = function fromJSON(data) {
			return new PlaneGeometry(data.width, data.height, data.widthSegments, data.heightSegments);
		};

		return PlaneGeometry;
	}(BufferGeometry);

	var alphamap_fragment = "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif";

	var alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif";

	var alphatest_fragment = "#ifdef USE_ALPHATEST\n\tif ( diffuseColor.a < alphaTest ) discard;\n#endif";

	var alphatest_pars_fragment = "#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif";

	var aomap_fragment = "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif";

	var aomap_pars_fragment = "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif";

	var begin_vertex = "vec3 transformed = vec3( position );";

	var beginnormal_vertex = "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif";

	var bsdfs = "vec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenTint, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenTint * ( D * V );\n}\n#endif";

	var bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif";

	var clipping_planes_fragment = "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif";

	var clipping_planes_pars_fragment = "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif";

	var clipping_planes_pars_vertex = "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif";

	var clipping_planes_vertex = "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif";

	var color_fragment = "#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif";

	var color_pars_fragment = "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif";

	var color_pars_vertex = "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif";

	var color_vertex = "#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif";

	var common = "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}";

	var cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_maxMipLevel 8.0\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_maxTileSize 256.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tfloat texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );\n\t\tvec2 f = fract( uv );\n\t\tuv += 0.5 - f;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tif ( mipInt < cubeUV_maxMipLevel ) {\n\t\t\tuv.y += 2.0 * cubeUV_maxTileSize;\n\t\t}\n\t\tuv.y += filterInt * 2.0 * cubeUV_minTileSize;\n\t\tuv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\n\t\tuv *= texelSize;\n\t\tvec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x += texelSize;\n\t\tvec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.y += texelSize;\n\t\tvec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x -= texelSize;\n\t\tvec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tvec3 tm = mix( tl, tr, f.x );\n\t\tvec3 bm = mix( bl, br, f.x );\n\t\treturn mix( tm, bm, f.y );\n\t}\n\t#define r0 1.0\n\t#define v0 0.339\n\t#define m0 - 2.0\n\t#define r1 0.8\n\t#define v1 0.276\n\t#define m1 - 1.0\n\t#define r4 0.4\n\t#define v4 0.046\n\t#define m4 2.0\n\t#define r5 0.305\n\t#define v5 0.016\n\t#define m5 3.0\n\t#define r6 0.21\n\t#define v6 0.0038\n\t#define m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= r1 ) {\n\t\t\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n\t\t} else if ( roughness >= r4 ) {\n\t\t\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n\t\t} else if ( roughness >= r5 ) {\n\t\t\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n\t\t} else if ( roughness >= r6 ) {\n\t\t\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif";

	var defaultnormal_vertex = "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif";

	var displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif";

	var displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif";

	var emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif";

	var emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif";

	var encodings_fragment = "gl_FragColor = linearToOutputTexel( gl_FragColor );";

	var encodings_pars_fragment = "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value ) {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}";

	var envmap_fragment = "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t\tenvColor = envMapTexelToLinear( envColor );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif";

	var envmap_common_pars_fragment = "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif";

	var envmap_pars_fragment = "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif";

	var envmap_pars_vertex = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif";

	var envmap_vertex = "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif";

	var fog_vertex = "#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif";

	var fog_pars_vertex = "#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif";

	var fog_fragment = "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif";

	var fog_pars_fragment = "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif";

	var gradientmap_pars_fragment = "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn texture2D( gradientMap, coord ).rgb;\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}";

	var lightmap_fragment = "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tlightMapIrradiance *= PI;\n\t#endif\n\treflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif";

	var lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif";

	var lights_lambert_vertex = "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry.normal );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry.normal );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointLightInfo( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotLightInfo( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalLightInfo( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry.normal );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif";

	var lights_pars_begin = "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tif ( cutoffDistance > 0.0 ) {\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t}\n\t\treturn distanceFalloff;\n\t#else\n\t\tif ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\t\treturn pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t\t}\n\t\treturn 1.0;\n\t#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif";

	var envmap_physical_pars_fragment = "#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getIBLIrradiance( const in vec3 normal ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 reflectVec;\n\t\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\t\treflectVec = reflect( - viewDir, normal );\n\t\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t\t#else\n\t\t\t\treflectVec = refract( - viewDir, normal, refractionRatio );\n\t\t\t#endif\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n#endif";

	var lights_toon_fragment = "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;";

	var lights_toon_pars_fragment = "varying vec3 vViewPosition;\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)";

	var lights_phong_fragment = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;";

	var lights_phong_pars_fragment = "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)";

	var lights_physical_fragment = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n\t#ifdef SPECULAR\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularTintFactor = specularTint;\n\t\t#ifdef USE_SPECULARINTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;\n\t\t#endif\n\t\t#ifdef USE_SPECULARTINTMAP\n\t\t\tspecularTintFactor *= specularTintMapTexelToLinear( texture2D( specularTintMap, vUv ) ).rgb;\n\t\t#endif\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\t#else\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularTintFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\t#endif\n\tmaterial.specularColor = mix( min( pow2( ( ior - 1.0 ) / ( ior + 1.0 ) ) * specularTintFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenTint = sheenTint;\n\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n#endif";

	var lights_physical_pars_fragment = "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenTint;\n\t\tfloat sheenRoughness;\n\t#endif\n};\nvec3 clearcoatSpecular = vec3( 0.0 );\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\treturn fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\treturn specularColor * fab.x + specularF90 * fab.y;\n}\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\tvec3 FssEss = specularColor * fab.x + specularF90 * fab.y;\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(		0, 1,		0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\t\tclearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\treflectedLight.directSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenTint, material.sheenRoughness );\n\t#endif\n\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tcomputeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}";

	var lights_fragment_begin = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef USE_CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointLightInfo( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotLightInfo( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif";

	var lights_fragment_maps = "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometry.normal );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif";

	var lights_fragment_end = "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif";

	var logdepthbuf_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif";

	var logdepthbuf_pars_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif";

	var logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif";

	var logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif";

	var map_fragment = "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif";

	var map_pars_fragment = "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif";

	var map_particle_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif";

	var map_particle_pars_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif";

	var metalnessmap_fragment = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif";

	var metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif";

	var morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] > 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1, 2 ) * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\t#endif\n#endif";

	var morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform vec2 morphTargetsTextureSize;\n\t\tvec3 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset, const in int stride ) {\n\t\t\tfloat texelIndex = float( vertexIndex * stride + offset );\n\t\t\tfloat y = floor( texelIndex / morphTargetsTextureSize.x );\n\t\t\tfloat x = texelIndex - y * morphTargetsTextureSize.x;\n\t\t\tvec3 morphUV = vec3( ( x + 0.5 ) / morphTargetsTextureSize.x, y / morphTargetsTextureSize.y, morphTargetIndex );\n\t\t\treturn texture( morphTargetsTexture, morphUV ).xyz;\n\t\t}\n\t#else\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\t\t#else\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\t\t#endif\n\t#endif\n#endif";

	var morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\t#ifndef USE_MORPHNORMALS\n\t\t\t\tif ( morphTargetInfluences[ i ] > 0.0 ) transformed += getMorph( gl_VertexID, i, 0, 1 ) * morphTargetInfluences[ i ];\n\t\t\t#else\n\t\t\t\tif ( morphTargetInfluences[ i ] > 0.0 ) transformed += getMorph( gl_VertexID, i, 0, 2 ) * morphTargetInfluences[ i ];\n\t\t\t#endif\n\t\t}\n\t#else\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t\t#endif\n\t#endif\n#endif";

	var normal_fragment_begin = "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * faceDirection;\n\t\t\tbitangent = bitangent * faceDirection;\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;";

	var normal_fragment_maps = "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif";

	var normal_pars_fragment = "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif";

	var normal_pars_vertex = "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif";

	var normal_vertex = "#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif";

	var normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n\t\treturn normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n\t}\n#endif";

	var clearcoat_normal_fragment_begin = "#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif";

	var clearcoat_normal_fragment_maps = "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n\t#endif\n#endif";

	var clearcoat_pars_fragment = "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif";

	var output_fragment = "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= transmissionAlpha + 0.1;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );";

	var packing = "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}";

	var premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif";

	var project_vertex = "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;";

	var dithering_fragment = "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif";

	var dithering_pars_fragment = "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif";

	var roughnessmap_fragment = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif";

	var roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif";

	var shadowmap_pars_fragment = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t	texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t	f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t	texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t	f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif";

	var shadowmap_pars_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif";

	var shadowmap_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif";

	var shadowmask_pars_fragment = "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}";

	var skinbase_vertex = "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";

	var skinning_pars_vertex = "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif";

	var skinning_vertex = "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif";

	var skinnormal_vertex = "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif";

	var specularmap_fragment = "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif";

	var specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif";

	var tonemapping_fragment = "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif";

	var tonemapping_pars_fragment = "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(	1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,	1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,	1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }";

	var transmission_fragment = "#ifdef USE_TRANSMISSION\n\tfloat transmissionAlpha = 1.0;\n\tfloat transmissionFactor = transmission;\n\tfloat thicknessFactor = thickness;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\ttransmissionFactor *= texture2D( transmissionMap, vUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tthicknessFactor *= texture2D( thicknessMap, vUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tvec4 transmission = getIBLVolumeRefraction(\n\t\tn, v, roughnessFactor, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,\n\t\tattenuationTint, attenuationDistance );\n\ttotalDiffuse = mix( totalDiffuse, transmission.rgb, transmissionFactor );\n\ttransmissionAlpha = mix( transmissionAlpha, transmission.a, transmissionFactor );\n#endif";

	var transmission_pars_fragment = "#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationTint;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec3 vWorldPosition;\n\tvec3 getVolumeTransmissionRay( vec3 n, vec3 v, float thickness, float ior, mat4 modelMatrix ) {\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness( float roughness, float ior ) {\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t}\n\tvec4 getTransmissionSample( vec2 fragCoord, float roughness, float ior ) {\n\t\tfloat framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\treturn texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#else\n\t\t\treturn texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#endif\n\t}\n\tvec3 applyVolumeAttenuation( vec3 radiance, float transmissionDistance, vec3 attenuationColor, float attenuationDistance ) {\n\t\tif ( attenuationDistance == 0.0 ) {\n\t\t\treturn radiance;\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\t\t\treturn transmittance * radiance;\n\t\t}\n\t}\n\tvec4 getIBLVolumeRefraction( vec3 n, vec3 v, float roughness, vec3 diffuseColor, vec3 specularColor, float specularF90,\n\t\tvec3 position, mat4 modelMatrix, mat4 viewMatrix, mat4 projMatrix, float ior, float thickness,\n\t\tvec3 attenuationColor, float attenuationDistance ) {\n\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\trefractionCoords += 1.0;\n\t\trefractionCoords /= 2.0;\n\t\tvec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\tvec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );\n\t}\n#endif";

	var uv_pars_fragment = "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif";

	var uv_pars_vertex = "#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif";

	var uv_vertex = "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif";

	var uv2_pars_fragment = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif";

	var uv2_pars_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif";

	var uv2_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif";

	var worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif";

	var vertex = "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}";
	var fragment = "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";

	var vertex$1 = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}";
	var fragment$1 = "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";

	var vertex$2 = "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}";
	var fragment$2 = "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}";

	var vertex$3 = "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}";
	var fragment$3 = "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}";

	var vertex$4 = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}";
	var fragment$4 = "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";

	var vertex$5 = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";
	var fragment$5 = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}";

	var vertex$6 = "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}";
	var fragment$6 = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

	var vertex$7 = "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";
	var fragment$7 = "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

	var vertex$8 = "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}";
	var fragment$8 = "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

	var vertex$9 = "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}";
	var fragment$9 = "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}";

	var vertex$a = "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";
	var fragment$a = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

	var vertex$b = "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition.xyz;\n#endif\n}";
	var fragment$b = "#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularTint;\n\t#ifdef USE_SPECULARINTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n\t#ifdef USE_SPECULARTINTMAP\n\t\tuniform sampler2D specularTintMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenTint;\n\tuniform float sheenRoughness;\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight = outgoingLight * ( 1.0 - clearcoat * Fcc ) + clearcoatSpecular * clearcoat;\n\t#endif\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

	var vertex$c = "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";
	var fragment$c = "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

	var vertex$d = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}";
	var fragment$d = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}";

	var vertex$e = "#include <common>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";
	var fragment$e = "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}";

	var vertex$f = "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";
	var fragment$f = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}";

	var ShaderChunk = {
		alphamap_fragment: alphamap_fragment,
		alphamap_pars_fragment: alphamap_pars_fragment,
		alphatest_fragment: alphatest_fragment,
		alphatest_pars_fragment: alphatest_pars_fragment,
		aomap_fragment: aomap_fragment,
		aomap_pars_fragment: aomap_pars_fragment,
		begin_vertex: begin_vertex,
		beginnormal_vertex: beginnormal_vertex,
		bsdfs: bsdfs,
		bumpmap_pars_fragment: bumpmap_pars_fragment,
		clipping_planes_fragment: clipping_planes_fragment,
		clipping_planes_pars_fragment: clipping_planes_pars_fragment,
		clipping_planes_pars_vertex: clipping_planes_pars_vertex,
		clipping_planes_vertex: clipping_planes_vertex,
		color_fragment: color_fragment,
		color_pars_fragment: color_pars_fragment,
		color_pars_vertex: color_pars_vertex,
		color_vertex: color_vertex,
		common: common,
		cube_uv_reflection_fragment: cube_uv_reflection_fragment,
		defaultnormal_vertex: defaultnormal_vertex,
		displacementmap_pars_vertex: displacementmap_pars_vertex,
		displacementmap_vertex: displacementmap_vertex,
		emissivemap_fragment: emissivemap_fragment,
		emissivemap_pars_fragment: emissivemap_pars_fragment,
		encodings_fragment: encodings_fragment,
		encodings_pars_fragment: encodings_pars_fragment,
		envmap_fragment: envmap_fragment,
		envmap_common_pars_fragment: envmap_common_pars_fragment,
		envmap_pars_fragment: envmap_pars_fragment,
		envmap_pars_vertex: envmap_pars_vertex,
		envmap_physical_pars_fragment: envmap_physical_pars_fragment,
		envmap_vertex: envmap_vertex,
		fog_vertex: fog_vertex,
		fog_pars_vertex: fog_pars_vertex,
		fog_fragment: fog_fragment,
		fog_pars_fragment: fog_pars_fragment,
		gradientmap_pars_fragment: gradientmap_pars_fragment,
		lightmap_fragment: lightmap_fragment,
		lightmap_pars_fragment: lightmap_pars_fragment,
		lights_lambert_vertex: lights_lambert_vertex,
		lights_pars_begin: lights_pars_begin,
		lights_toon_fragment: lights_toon_fragment,
		lights_toon_pars_fragment: lights_toon_pars_fragment,
		lights_phong_fragment: lights_phong_fragment,
		lights_phong_pars_fragment: lights_phong_pars_fragment,
		lights_physical_fragment: lights_physical_fragment,
		lights_physical_pars_fragment: lights_physical_pars_fragment,
		lights_fragment_begin: lights_fragment_begin,
		lights_fragment_maps: lights_fragment_maps,
		lights_fragment_end: lights_fragment_end,
		logdepthbuf_fragment: logdepthbuf_fragment,
		logdepthbuf_pars_fragment: logdepthbuf_pars_fragment,
		logdepthbuf_pars_vertex: logdepthbuf_pars_vertex,
		logdepthbuf_vertex: logdepthbuf_vertex,
		map_fragment: map_fragment,
		map_pars_fragment: map_pars_fragment,
		map_particle_fragment: map_particle_fragment,
		map_particle_pars_fragment: map_particle_pars_fragment,
		metalnessmap_fragment: metalnessmap_fragment,
		metalnessmap_pars_fragment: metalnessmap_pars_fragment,
		morphnormal_vertex: morphnormal_vertex,
		morphtarget_pars_vertex: morphtarget_pars_vertex,
		morphtarget_vertex: morphtarget_vertex,
		normal_fragment_begin: normal_fragment_begin,
		normal_fragment_maps: normal_fragment_maps,
		normal_pars_fragment: normal_pars_fragment,
		normal_pars_vertex: normal_pars_vertex,
		normal_vertex: normal_vertex,
		normalmap_pars_fragment: normalmap_pars_fragment,
		clearcoat_normal_fragment_begin: clearcoat_normal_fragment_begin,
		clearcoat_normal_fragment_maps: clearcoat_normal_fragment_maps,
		clearcoat_pars_fragment: clearcoat_pars_fragment,
		output_fragment: output_fragment,
		packing: packing,
		premultiplied_alpha_fragment: premultiplied_alpha_fragment,
		project_vertex: project_vertex,
		dithering_fragment: dithering_fragment,
		dithering_pars_fragment: dithering_pars_fragment,
		roughnessmap_fragment: roughnessmap_fragment,
		roughnessmap_pars_fragment: roughnessmap_pars_fragment,
		shadowmap_pars_fragment: shadowmap_pars_fragment,
		shadowmap_pars_vertex: shadowmap_pars_vertex,
		shadowmap_vertex: shadowmap_vertex,
		shadowmask_pars_fragment: shadowmask_pars_fragment,
		skinbase_vertex: skinbase_vertex,
		skinning_pars_vertex: skinning_pars_vertex,
		skinning_vertex: skinning_vertex,
		skinnormal_vertex: skinnormal_vertex,
		specularmap_fragment: specularmap_fragment,
		specularmap_pars_fragment: specularmap_pars_fragment,
		tonemapping_fragment: tonemapping_fragment,
		tonemapping_pars_fragment: tonemapping_pars_fragment,
		transmission_fragment: transmission_fragment,
		transmission_pars_fragment: transmission_pars_fragment,
		uv_pars_fragment: uv_pars_fragment,
		uv_pars_vertex: uv_pars_vertex,
		uv_vertex: uv_vertex,
		uv2_pars_fragment: uv2_pars_fragment,
		uv2_pars_vertex: uv2_pars_vertex,
		uv2_vertex: uv2_vertex,
		worldpos_vertex: worldpos_vertex,
		background_vert: vertex,
		background_frag: fragment,
		cube_vert: vertex$1,
		cube_frag: fragment$1,
		depth_vert: vertex$2,
		depth_frag: fragment$2,
		distanceRGBA_vert: vertex$3,
		distanceRGBA_frag: fragment$3,
		equirect_vert: vertex$4,
		equirect_frag: fragment$4,
		linedashed_vert: vertex$5,
		linedashed_frag: fragment$5,
		meshbasic_vert: vertex$6,
		meshbasic_frag: fragment$6,
		meshlambert_vert: vertex$7,
		meshlambert_frag: fragment$7,
		meshmatcap_vert: vertex$8,
		meshmatcap_frag: fragment$8,
		meshnormal_vert: vertex$9,
		meshnormal_frag: fragment$9,
		meshphong_vert: vertex$a,
		meshphong_frag: fragment$a,
		meshphysical_vert: vertex$b,
		meshphysical_frag: fragment$b,
		meshtoon_vert: vertex$c,
		meshtoon_frag: fragment$c,
		points_vert: vertex$d,
		points_frag: fragment$d,
		shadow_vert: vertex$e,
		shadow_frag: fragment$e,
		sprite_vert: vertex$f,
		sprite_frag: fragment$f
	};

	/**
	 * Uniforms library for shared webgl shaders
	 */

	var UniformsLib = {
		common: {
			diffuse: {
				value: new Color(0xffffff)
			},
			opacity: {
				value: 1.0
			},
			map: {
				value: null
			},
			uvTransform: {
				value: new Matrix3()
			},
			uv2Transform: {
				value: new Matrix3()
			},
			alphaMap: {
				value: null
			},
			alphaTest: {
				value: 0
			}
		},
		specularmap: {
			specularMap: {
				value: null
			}
		},
		envmap: {
			envMap: {
				value: null
			},
			flipEnvMap: {
				value: -1
			},
			reflectivity: {
				value: 1.0
			},
			// basic, lambert, phong
			ior: {
				value: 1.5
			},
			// standard, physical
			refractionRatio: {
				value: 0.98
			},
			maxMipLevel: {
				value: 0
			}
		},
		aomap: {
			aoMap: {
				value: null
			},
			aoMapIntensity: {
				value: 1
			}
		},
		lightmap: {
			lightMap: {
				value: null
			},
			lightMapIntensity: {
				value: 1
			}
		},
		emissivemap: {
			emissiveMap: {
				value: null
			}
		},
		bumpmap: {
			bumpMap: {
				value: null
			},
			bumpScale: {
				value: 1
			}
		},
		normalmap: {
			normalMap: {
				value: null
			},
			normalScale: {
				value: new Vector2(1, 1)
			}
		},
		displacementmap: {
			displacementMap: {
				value: null
			},
			displacementScale: {
				value: 1
			},
			displacementBias: {
				value: 0
			}
		},
		roughnessmap: {
			roughnessMap: {
				value: null
			}
		},
		metalnessmap: {
			metalnessMap: {
				value: null
			}
		},
		gradientmap: {
			gradientMap: {
				value: null
			}
		},
		fog: {
			fogDensity: {
				value: 0.00025
			},
			fogNear: {
				value: 1
			},
			fogFar: {
				value: 2000
			},
			fogColor: {
				value: new Color(0xffffff)
			}
		},
		lights: {
			ambientLightColor: {
				value: []
			},
			lightProbe: {
				value: []
			},
			directionalLights: {
				value: [],
				properties: {
					direction: {},
					color: {}
				}
			},
			directionalLightShadows: {
				value: [],
				properties: {
					shadowBias: {},
					shadowNormalBias: {},
					shadowRadius: {},
					shadowMapSize: {}
				}
			},
			directionalShadowMap: {
				value: []
			},
			directionalShadowMatrix: {
				value: []
			},
			spotLights: {
				value: [],
				properties: {
					color: {},
					position: {},
					direction: {},
					distance: {},
					coneCos: {},
					penumbraCos: {},
					decay: {}
				}
			},
			spotLightShadows: {
				value: [],
				properties: {
					shadowBias: {},
					shadowNormalBias: {},
					shadowRadius: {},
					shadowMapSize: {}
				}
			},
			spotShadowMap: {
				value: []
			},
			spotShadowMatrix: {
				value: []
			},
			pointLights: {
				value: [],
				properties: {
					color: {},
					position: {},
					decay: {},
					distance: {}
				}
			},
			pointLightShadows: {
				value: [],
				properties: {
					shadowBias: {},
					shadowNormalBias: {},
					shadowRadius: {},
					shadowMapSize: {},
					shadowCameraNear: {},
					shadowCameraFar: {}
				}
			},
			pointShadowMap: {
				value: []
			},
			pointShadowMatrix: {
				value: []
			},
			hemisphereLights: {
				value: [],
				properties: {
					direction: {},
					skyColor: {},
					groundColor: {}
				}
			},
			// TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
			rectAreaLights: {
				value: [],
				properties: {
					color: {},
					position: {},
					width: {},
					height: {}
				}
			},
			ltc_1: {
				value: null
			},
			ltc_2: {
				value: null
			}
		},
		points: {
			diffuse: {
				value: new Color(0xffffff)
			},
			opacity: {
				value: 1.0
			},
			size: {
				value: 1.0
			},
			scale: {
				value: 1.0
			},
			map: {
				value: null
			},
			alphaMap: {
				value: null
			},
			alphaTest: {
				value: 0
			},
			uvTransform: {
				value: new Matrix3()
			}
		},
		sprite: {
			diffuse: {
				value: new Color(0xffffff)
			},
			opacity: {
				value: 1.0
			},
			center: {
				value: new Vector2(0.5, 0.5)
			},
			rotation: {
				value: 0.0
			},
			map: {
				value: null
			},
			alphaMap: {
				value: null
			},
			alphaTest: {
				value: 0
			},
			uvTransform: {
				value: new Matrix3()
			}
		}
	};

	var ShaderLib = {
		basic: {
			uniforms: mergeUniforms([UniformsLib.common, UniformsLib.specularmap, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.fog]),
			vertexShader: ShaderChunk.meshbasic_vert,
			fragmentShader: ShaderChunk.meshbasic_frag
		},
		lambert: {
			uniforms: mergeUniforms([UniformsLib.common, UniformsLib.specularmap, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.fog, UniformsLib.lights, {
				emissive: {
					value: new Color(0x000000)
				}
			}]),
			vertexShader: ShaderChunk.meshlambert_vert,
			fragmentShader: ShaderChunk.meshlambert_frag
		},
		phong: {
			uniforms: mergeUniforms([UniformsLib.common, UniformsLib.specularmap, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.fog, UniformsLib.lights, {
				emissive: {
					value: new Color(0x000000)
				},
				specular: {
					value: new Color(0x111111)
				},
				shininess: {
					value: 30
				}
			}]),
			vertexShader: ShaderChunk.meshphong_vert,
			fragmentShader: ShaderChunk.meshphong_frag
		},
		standard: {
			uniforms: mergeUniforms([UniformsLib.common, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.roughnessmap, UniformsLib.metalnessmap, UniformsLib.fog, UniformsLib.lights, {
				emissive: {
					value: new Color(0x000000)
				},
				roughness: {
					value: 1.0
				},
				metalness: {
					value: 0.0
				},
				envMapIntensity: {
					value: 1
				} // temporary

			}]),
			vertexShader: ShaderChunk.meshphysical_vert,
			fragmentShader: ShaderChunk.meshphysical_frag
		},
		toon: {
			uniforms: mergeUniforms([UniformsLib.common, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.gradientmap, UniformsLib.fog, UniformsLib.lights, {
				emissive: {
					value: new Color(0x000000)
				}
			}]),
			vertexShader: ShaderChunk.meshtoon_vert,
			fragmentShader: ShaderChunk.meshtoon_frag
		},
		matcap: {
			uniforms: mergeUniforms([UniformsLib.common, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.fog, {
				matcap: {
					value: null
				}
			}]),
			vertexShader: ShaderChunk.meshmatcap_vert,
			fragmentShader: ShaderChunk.meshmatcap_frag
		},
		points: {
			uniforms: mergeUniforms([UniformsLib.points, UniformsLib.fog]),
			vertexShader: ShaderChunk.points_vert,
			fragmentShader: ShaderChunk.points_frag
		},
		dashed: {
			uniforms: mergeUniforms([UniformsLib.common, UniformsLib.fog, {
				scale: {
					value: 1
				},
				dashSize: {
					value: 1
				},
				totalSize: {
					value: 2
				}
			}]),
			vertexShader: ShaderChunk.linedashed_vert,
			fragmentShader: ShaderChunk.linedashed_frag
		},
		depth: {
			uniforms: mergeUniforms([UniformsLib.common, UniformsLib.displacementmap]),
			vertexShader: ShaderChunk.depth_vert,
			fragmentShader: ShaderChunk.depth_frag
		},
		normal: {
			uniforms: mergeUniforms([UniformsLib.common, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, {
				opacity: {
					value: 1.0
				}
			}]),
			vertexShader: ShaderChunk.meshnormal_vert,
			fragmentShader: ShaderChunk.meshnormal_frag
		},
		sprite: {
			uniforms: mergeUniforms([UniformsLib.sprite, UniformsLib.fog]),
			vertexShader: ShaderChunk.sprite_vert,
			fragmentShader: ShaderChunk.sprite_frag
		},
		background: {
			uniforms: {
				uvTransform: {
					value: new Matrix3()
				},
				t2D: {
					value: null
				}
			},
			vertexShader: ShaderChunk.background_vert,
			fragmentShader: ShaderChunk.background_frag
		},

		/* -------------------------------------------------------------------------
		//	Cube map shader
		 ------------------------------------------------------------------------- */
		cube: {
			uniforms: mergeUniforms([UniformsLib.envmap, {
				opacity: {
					value: 1.0
				}
			}]),
			vertexShader: ShaderChunk.cube_vert,
			fragmentShader: ShaderChunk.cube_frag
		},
		equirect: {
			uniforms: {
				tEquirect: {
					value: null
				}
			},
			vertexShader: ShaderChunk.equirect_vert,
			fragmentShader: ShaderChunk.equirect_frag
		},
		distanceRGBA: {
			uniforms: mergeUniforms([UniformsLib.common, UniformsLib.displacementmap, {
				referencePosition: {
					value: new Vector3()
				},
				nearDistance: {
					value: 1
				},
				farDistance: {
					value: 1000
				}
			}]),
			vertexShader: ShaderChunk.distanceRGBA_vert,
			fragmentShader: ShaderChunk.distanceRGBA_frag
		},
		shadow: {
			uniforms: mergeUniforms([UniformsLib.lights, UniformsLib.fog, {
				color: {
					value: new Color(0x00000)
				},
				opacity: {
					value: 1.0
				}
			}]),
			vertexShader: ShaderChunk.shadow_vert,
			fragmentShader: ShaderChunk.shadow_frag
		}
	};
	ShaderLib.physical = {
		uniforms: mergeUniforms([ShaderLib.standard.uniforms, {
			clearcoat: {
				value: 0
			},
			clearcoatMap: {
				value: null
			},
			clearcoatRoughness: {
				value: 0
			},
			clearcoatRoughnessMap: {
				value: null
			},
			clearcoatNormalScale: {
				value: new Vector2(1, 1)
			},
			clearcoatNormalMap: {
				value: null
			},
			sheen: {
				value: 0
			},
			sheenTint: {
				value: new Color(0x000000)
			},
			sheenRoughness: {
				value: 0
			},
			transmission: {
				value: 0
			},
			transmissionMap: {
				value: null
			},
			transmissionSamplerSize: {
				value: new Vector2()
			},
			transmissionSamplerMap: {
				value: null
			},
			thickness: {
				value: 0
			},
			thicknessMap: {
				value: null
			},
			attenuationDistance: {
				value: 0
			},
			attenuationTint: {
				value: new Color(0x000000)
			},
			specularIntensity: {
				value: 0
			},
			specularIntensityMap: {
				value: null
			},
			specularTint: {
				value: new Color(1, 1, 1)
			},
			specularTintMap: {
				value: null
			}
		}]),
		vertexShader: ShaderChunk.meshphysical_vert,
		fragmentShader: ShaderChunk.meshphysical_frag
	};

	function WebGLBackground(renderer, cubemaps, state, objects, premultipliedAlpha) {
		var clearColor = new Color(0x000000);
		var clearAlpha = 0;
		var planeMesh;
		var boxMesh;
		var currentBackground = null;
		var currentBackgroundVersion = 0;
		var currentTonemapping = null;

		function render(renderList, scene) {
			var forceClear = false;
			var background = scene.isScene === true ? scene.background : null;

			if (background && background.isTexture) {
				background = cubemaps.get(background);
			} // Ignore background in AR
			// TODO: Reconsider this.


			var xr = renderer.xr;
			var session = xr.getSession && xr.getSession();

			if (session && session.environmentBlendMode === 'additive') {
				background = null;
			}

			if (background === null) {
				setClear(clearColor, clearAlpha);
			} else if (background && background.isColor) {
				setClear(background, 1);
				forceClear = true;
			}

			if (renderer.autoClear || forceClear) {
				renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil);
			}

			if (background && (background.isCubeTexture || background.mapping === CubeUVReflectionMapping)) {
				if (boxMesh === undefined) {
					boxMesh = new Mesh(new BoxGeometry(1, 1, 1), new ShaderMaterial({
						name: 'BackgroundCubeMaterial',
						uniforms: cloneUniforms(ShaderLib.cube.uniforms),
						vertexShader: ShaderLib.cube.vertexShader,
						fragmentShader: ShaderLib.cube.fragmentShader,
						side: BackSide,
						depthTest: false,
						depthWrite: false,
						fog: false
					}));
					boxMesh.geometry.deleteAttribute('normal');
					boxMesh.geometry.deleteAttribute('uv');

					boxMesh.onBeforeRender = function (renderer, scene, camera) {
						this.matrixWorld.copyPosition(camera.matrixWorld);
					}; // enable code injection for non-built-in material


					Object.defineProperty(boxMesh.material, 'envMap', {
						get: function get() {
							return this.uniforms.envMap.value;
						}
					});
					objects.update(boxMesh);
				}

				boxMesh.material.uniforms.envMap.value = background;
				boxMesh.material.uniforms.flipEnvMap.value = background.isCubeTexture && background.isRenderTargetTexture === false ? -1 : 1;

				if (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer.toneMapping) {
					boxMesh.material.needsUpdate = true;
					currentBackground = background;
					currentBackgroundVersion = background.version;
					currentTonemapping = renderer.toneMapping;
				} // push to the pre-sorted opaque render list


				renderList.unshift(boxMesh, boxMesh.geometry, boxMesh.material, 0, 0, null);
			} else if (background && background.isTexture) {
				if (planeMesh === undefined) {
					planeMesh = new Mesh(new PlaneGeometry(2, 2), new ShaderMaterial({
						name: 'BackgroundMaterial',
						uniforms: cloneUniforms(ShaderLib.background.uniforms),
						vertexShader: ShaderLib.background.vertexShader,
						fragmentShader: ShaderLib.background.fragmentShader,
						side: FrontSide,
						depthTest: false,
						depthWrite: false,
						fog: false
					}));
					planeMesh.geometry.deleteAttribute('normal'); // enable code injection for non-built-in material

					Object.defineProperty(planeMesh.material, 'map', {
						get: function get() {
							return this.uniforms.t2D.value;
						}
					});
					objects.update(planeMesh);
				}

				planeMesh.material.uniforms.t2D.value = background;

				if (background.matrixAutoUpdate === true) {
					background.updateMatrix();
				}

				planeMesh.material.uniforms.uvTransform.value.copy(background.matrix);

				if (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer.toneMapping) {
					planeMesh.material.needsUpdate = true;
					currentBackground = background;
					currentBackgroundVersion = background.version;
					currentTonemapping = renderer.toneMapping;
				} // push to the pre-sorted opaque render list


				renderList.unshift(planeMesh, planeMesh.geometry, planeMesh.material, 0, 0, null);
			}
		}

		function setClear(color, alpha) {
			state.buffers.color.setClear(color.r, color.g, color.b, alpha, premultipliedAlpha);
		}

		return {
			getClearColor: function getClearColor() {
				return clearColor;
			},
			setClearColor: function setClearColor(color, alpha) {
				if (alpha === void 0) {
					alpha = 1;
				}

				clearColor.set(color);
				clearAlpha = alpha;
				setClear(clearColor, clearAlpha);
			},
			getClearAlpha: function getClearAlpha() {
				return clearAlpha;
			},
			setClearAlpha: function setClearAlpha(alpha) {
				clearAlpha = alpha;
				setClear(clearColor, clearAlpha);
			},
			render: render
		};
	}

	function WebGLBindingStates(gl, extensions, attributes, capabilities) {
		var maxVertexAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
		var extension = capabilities.isWebGL2 ? null : extensions.get('OES_vertex_array_object');
		var vaoAvailable = capabilities.isWebGL2 || extension !== null;
		var bindingStates = {};
		var defaultState = createBindingState(null);
		var currentState = defaultState;

		function setup(object, material, program, geometry, index) {
			var updateBuffers = false;

			if (vaoAvailable) {
				var state = getBindingState(geometry, program, material);

				if (currentState !== state) {
					currentState = state;
					bindVertexArrayObject(currentState.object);
				}

				updateBuffers = needsUpdate(geometry, index);
				if (updateBuffers) saveCache(geometry, index);
			} else {
				var wireframe = material.wireframe === true;

				if (currentState.geometry !== geometry.id || currentState.program !== program.id || currentState.wireframe !== wireframe) {
					currentState.geometry = geometry.id;
					currentState.program = program.id;
					currentState.wireframe = wireframe;
					updateBuffers = true;
				}
			}

			if (object.isInstancedMesh === true) {
				updateBuffers = true;
			}

			if (index !== null) {
				attributes.update(index, gl.ELEMENT_ARRAY_BUFFER);
			}

			if (updateBuffers) {
				setupVertexAttributes(object, material, program, geometry);

				if (index !== null) {
					gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, attributes.get(index).buffer);
				}
			}
		}

		function createVertexArrayObject() {
			if (capabilities.isWebGL2) return gl.createVertexArray();
			return extension.createVertexArrayOES();
		}

		function bindVertexArrayObject(vao) {
			if (capabilities.isWebGL2) return gl.bindVertexArray(vao);
			return extension.bindVertexArrayOES(vao);
		}

		function deleteVertexArrayObject(vao) {
			if (capabilities.isWebGL2) return gl.deleteVertexArray(vao);
			return extension.deleteVertexArrayOES(vao);
		}

		function getBindingState(geometry, program, material) {
			var wireframe = material.wireframe === true;
			var programMap = bindingStates[geometry.id];

			if (programMap === undefined) {
				programMap = {};
				bindingStates[geometry.id] = programMap;
			}

			var stateMap = programMap[program.id];

			if (stateMap === undefined) {
				stateMap = {};
				programMap[program.id] = stateMap;
			}

			var state = stateMap[wireframe];

			if (state === undefined) {
				state = createBindingState(createVertexArrayObject());
				stateMap[wireframe] = state;
			}

			return state;
		}

		function createBindingState(vao) {
			var newAttributes = [];
			var enabledAttributes = [];
			var attributeDivisors = [];

			for (var i = 0; i < maxVertexAttributes; i++) {
				newAttributes[i] = 0;
				enabledAttributes[i] = 0;
				attributeDivisors[i] = 0;
			}

			return {
				// for backward compatibility on non-VAO support browser
				geometry: null,
				program: null,
				wireframe: false,
				newAttributes: newAttributes,
				enabledAttributes: enabledAttributes,
				attributeDivisors: attributeDivisors,
				object: vao,
				attributes: {},
				index: null
			};
		}

		function needsUpdate(geometry, index) {
			var cachedAttributes = currentState.attributes;
			var geometryAttributes = geometry.attributes;
			var attributesNum = 0;

			for (var key in geometryAttributes) {
				var cachedAttribute = cachedAttributes[key];
				var geometryAttribute = geometryAttributes[key];
				if (cachedAttribute === undefined) return true;
				if (cachedAttribute.attribute !== geometryAttribute) return true;
				if (cachedAttribute.data !== geometryAttribute.data) return true;
				attributesNum++;
			}

			if (currentState.attributesNum !== attributesNum) return true;
			if (currentState.index !== index) return true;
			return false;
		}

		function saveCache(geometry, index) {
			var cache = {};
			var attributes = geometry.attributes;
			var attributesNum = 0;

			for (var key in attributes) {
				var attribute = attributes[key];
				var data = {};
				data.attribute = attribute;

				if (attribute.data) {
					data.data = attribute.data;
				}

				cache[key] = data;
				attributesNum++;
			}

			currentState.attributes = cache;
			currentState.attributesNum = attributesNum;
			currentState.index = index;
		}

		function initAttributes() {
			var newAttributes = currentState.newAttributes;

			for (var i = 0, il = newAttributes.length; i < il; i++) {
				newAttributes[i] = 0;
			}
		}

		function enableAttribute(attribute) {
			enableAttributeAndDivisor(attribute, 0);
		}

		function enableAttributeAndDivisor(attribute, meshPerAttribute) {
			var newAttributes = currentState.newAttributes;
			var enabledAttributes = currentState.enabledAttributes;
			var attributeDivisors = currentState.attributeDivisors;
			newAttributes[attribute] = 1;

			if (enabledAttributes[attribute] === 0) {
				gl.enableVertexAttribArray(attribute);
				enabledAttributes[attribute] = 1;
			}

			if (attributeDivisors[attribute] !== meshPerAttribute) {
				var _extension = capabilities.isWebGL2 ? gl : extensions.get('ANGLE_instanced_arrays');

				_extension[capabilities.isWebGL2 ? 'vertexAttribDivisor' : 'vertexAttribDivisorANGLE'](attribute, meshPerAttribute);

				attributeDivisors[attribute] = meshPerAttribute;
			}
		}

		function disableUnusedAttributes() {
			var newAttributes = currentState.newAttributes;
			var enabledAttributes = currentState.enabledAttributes;

			for (var i = 0, il = enabledAttributes.length; i < il; i++) {
				if (enabledAttributes[i] !== newAttributes[i]) {
					gl.disableVertexAttribArray(i);
					enabledAttributes[i] = 0;
				}
			}
		}

		function vertexAttribPointer(index, size, type, normalized, stride, offset) {
			if (capabilities.isWebGL2 === true && (type === gl.INT || type === gl.UNSIGNED_INT)) {
				gl.vertexAttribIPointer(index, size, type, stride, offset);
			} else {
				gl.vertexAttribPointer(index, size, type, normalized, stride, offset);
			}
		}

		function setupVertexAttributes(object, material, program, geometry) {
			if (capabilities.isWebGL2 === false && (object.isInstancedMesh || geometry.isInstancedBufferGeometry)) {
				if (extensions.get('ANGLE_instanced_arrays') === null) return;
			}

			initAttributes();
			var geometryAttributes = geometry.attributes;
			var programAttributes = program.getAttributes();
			var materialDefaultAttributeValues = material.defaultAttributeValues;

			for (var name in programAttributes) {
				var programAttribute = programAttributes[name];

				if (programAttribute.location >= 0) {
					var geometryAttribute = geometryAttributes[name];

					if (geometryAttribute === undefined) {
						if (name === 'instanceMatrix' && object.instanceMatrix) geometryAttribute = object.instanceMatrix;
						if (name === 'instanceColor' && object.instanceColor) geometryAttribute = object.instanceColor;
					}

					if (geometryAttribute !== undefined) {
						var normalized = geometryAttribute.normalized;
						var size = geometryAttribute.itemSize;
						var attribute = attributes.get(geometryAttribute); // TODO Attribute may not be available on context restore

						if (attribute === undefined) continue;
						var buffer = attribute.buffer;
						var type = attribute.type;
						var bytesPerElement = attribute.bytesPerElement;

						if (geometryAttribute.isInterleavedBufferAttribute) {
							var data = geometryAttribute.data;
							var stride = data.stride;
							var offset = geometryAttribute.offset;

							if (data && data.isInstancedInterleavedBuffer) {
								for (var i = 0; i < programAttribute.locationSize; i++) {
									enableAttributeAndDivisor(programAttribute.location + i, data.meshPerAttribute);
								}

								if (object.isInstancedMesh !== true && geometry._maxInstanceCount === undefined) {
									geometry._maxInstanceCount = data.meshPerAttribute * data.count;
								}
							} else {
								for (var _i = 0; _i < programAttribute.locationSize; _i++) {
									enableAttribute(programAttribute.location + _i);
								}
							}

							gl.bindBuffer(gl.ARRAY_BUFFER, buffer);

							for (var _i2 = 0; _i2 < programAttribute.locationSize; _i2++) {
								vertexAttribPointer(programAttribute.location + _i2, size / programAttribute.locationSize, type, normalized, stride * bytesPerElement, (offset + size / programAttribute.locationSize * _i2) * bytesPerElement);
							}
						} else {
							if (geometryAttribute.isInstancedBufferAttribute) {
								for (var _i3 = 0; _i3 < programAttribute.locationSize; _i3++) {
									enableAttributeAndDivisor(programAttribute.location + _i3, geometryAttribute.meshPerAttribute);
								}

								if (object.isInstancedMesh !== true && geometry._maxInstanceCount === undefined) {
									geometry._maxInstanceCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;
								}
							} else {
								for (var _i4 = 0; _i4 < programAttribute.locationSize; _i4++) {
									enableAttribute(programAttribute.location + _i4);
								}
							}

							gl.bindBuffer(gl.ARRAY_BUFFER, buffer);

							for (var _i5 = 0; _i5 < programAttribute.locationSize; _i5++) {
								vertexAttribPointer(programAttribute.location + _i5, size / programAttribute.locationSize, type, normalized, size * bytesPerElement, size / programAttribute.locationSize * _i5 * bytesPerElement);
							}
						}
					} else if (materialDefaultAttributeValues !== undefined) {
						var value = materialDefaultAttributeValues[name];

						if (value !== undefined) {
							switch (value.length) {
								case 2:
									gl.vertexAttrib2fv(programAttribute.location, value);
									break;

								case 3:
									gl.vertexAttrib3fv(programAttribute.location, value);
									break;

								case 4:
									gl.vertexAttrib4fv(programAttribute.location, value);
									break;

								default:
									gl.vertexAttrib1fv(programAttribute.location, value);
							}
						}
					}
				}
			}

			disableUnusedAttributes();
		}

		function dispose() {
			reset();

			for (var geometryId in bindingStates) {
				var programMap = bindingStates[geometryId];

				for (var programId in programMap) {
					var stateMap = programMap[programId];

					for (var wireframe in stateMap) {
						deleteVertexArrayObject(stateMap[wireframe].object);
						delete stateMap[wireframe];
					}

					delete programMap[programId];
				}

				delete bindingStates[geometryId];
			}
		}

		function releaseStatesOfGeometry(geometry) {
			if (bindingStates[geometry.id] === undefined) return;
			var programMap = bindingStates[geometry.id];

			for (var programId in programMap) {
				var stateMap = programMap[programId];

				for (var wireframe in stateMap) {
					deleteVertexArrayObject(stateMap[wireframe].object);
					delete stateMap[wireframe];
				}

				delete programMap[programId];
			}

			delete bindingStates[geometry.id];
		}

		function releaseStatesOfProgram(program) {
			for (var geometryId in bindingStates) {
				var programMap = bindingStates[geometryId];
				if (programMap[program.id] === undefined) continue;
				var stateMap = programMap[program.id];

				for (var wireframe in stateMap) {
					deleteVertexArrayObject(stateMap[wireframe].object);
					delete stateMap[wireframe];
				}

				delete programMap[program.id];
			}
		}

		function reset() {
			resetDefaultState();
			if (currentState === defaultState) return;
			currentState = defaultState;
			bindVertexArrayObject(currentState.object);
		} // for backward-compatilibity


		function resetDefaultState() {
			defaultState.geometry = null;
			defaultState.program = null;
			defaultState.wireframe = false;
		}

		return {
			setup: setup,
			reset: reset,
			resetDefaultState: resetDefaultState,
			dispose: dispose,
			releaseStatesOfGeometry: releaseStatesOfGeometry,
			releaseStatesOfProgram: releaseStatesOfProgram,
			initAttributes: initAttributes,
			enableAttribute: enableAttribute,
			disableUnusedAttributes: disableUnusedAttributes
		};
	}

	function WebGLBufferRenderer(gl, extensions, info, capabilities) {
		var isWebGL2 = capabilities.isWebGL2;
		var mode;

		function setMode(value) {
			mode = value;
		}

		function render(start, count) {
			gl.drawArrays(mode, start, count);
			info.update(count, mode, 1);
		}

		function renderInstances(start, count, primcount) {
			if (primcount === 0) return;
			var extension, methodName;

			if (isWebGL2) {
				extension = gl;
				methodName = 'drawArraysInstanced';
			} else {
				extension = extensions.get('ANGLE_instanced_arrays');
				methodName = 'drawArraysInstancedANGLE';

				if (extension === null) {
					console.error('THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');
					return;
				}
			}

			extension[methodName](mode, start, count, primcount);
			info.update(count, mode, primcount);
		} //


		this.setMode = setMode;
		this.render = render;
		this.renderInstances = renderInstances;
	}

	function WebGLCapabilities(gl, extensions, parameters) {
		var maxAnisotropy;

		function getMaxAnisotropy() {
			if (maxAnisotropy !== undefined) return maxAnisotropy;

			if (extensions.has('EXT_texture_filter_anisotropic') === true) {
				var extension = extensions.get('EXT_texture_filter_anisotropic');
				maxAnisotropy = gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
			} else {
				maxAnisotropy = 0;
			}

			return maxAnisotropy;
		}

		function getMaxPrecision(precision) {
			if (precision === 'highp') {
				if (gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_FLOAT).precision > 0 && gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT).precision > 0) {
					return 'highp';
				}

				precision = 'mediump';
			}

			if (precision === 'mediump') {
				if (gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_FLOAT).precision > 0 && gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT).precision > 0) {
					return 'mediump';
				}
			}

			return 'lowp';
		}
		/* eslint-disable no-undef */


		var isWebGL2 = typeof WebGL2RenderingContext !== 'undefined' && gl instanceof WebGL2RenderingContext || typeof WebGL2ComputeRenderingContext !== 'undefined' && gl instanceof WebGL2ComputeRenderingContext;
		/* eslint-enable no-undef */

		var precision = parameters.precision !== undefined ? parameters.precision : 'highp';
		var maxPrecision = getMaxPrecision(precision);

		if (maxPrecision !== precision) {
			console.warn('THREE.WebGLRenderer:', precision, 'not supported, using', maxPrecision, 'instead.');
			precision = maxPrecision;
		}

		var drawBuffers = isWebGL2 || extensions.has('WEBGL_draw_buffers');
		var logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;
		var maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
		var maxVertexTextures = gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
		var maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
		var maxCubemapSize = gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE);
		var maxAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
		var maxVertexUniforms = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);
		var maxVaryings = gl.getParameter(gl.MAX_VARYING_VECTORS);
		var maxFragmentUniforms = gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS);
		var vertexTextures = maxVertexTextures > 0;
		var floatFragmentTextures = isWebGL2 || extensions.has('OES_texture_float');
		var floatVertexTextures = vertexTextures && floatFragmentTextures;
		var maxSamples = isWebGL2 ? gl.getParameter(gl.MAX_SAMPLES) : 0;
		return {
			isWebGL2: isWebGL2,
			drawBuffers: drawBuffers,
			getMaxAnisotropy: getMaxAnisotropy,
			getMaxPrecision: getMaxPrecision,
			precision: precision,
			logarithmicDepthBuffer: logarithmicDepthBuffer,
			maxTextures: maxTextures,
			maxVertexTextures: maxVertexTextures,
			maxTextureSize: maxTextureSize,
			maxCubemapSize: maxCubemapSize,
			maxAttributes: maxAttributes,
			maxVertexUniforms: maxVertexUniforms,
			maxVaryings: maxVaryings,
			maxFragmentUniforms: maxFragmentUniforms,
			vertexTextures: vertexTextures,
			floatFragmentTextures: floatFragmentTextures,
			floatVertexTextures: floatVertexTextures,
			maxSamples: maxSamples
		};
	}

	function WebGLClipping(properties) {
		var scope = this;
		var globalState = null,
				numGlobalPlanes = 0,
				localClippingEnabled = false,
				renderingShadows = false;
		var plane = new Plane(),
				viewNormalMatrix = new Matrix3(),
				uniform = {
			value: null,
			needsUpdate: false
		};
		this.uniform = uniform;
		this.numPlanes = 0;
		this.numIntersection = 0;

		this.init = function (planes, enableLocalClipping, camera) {
			var enabled = planes.length !== 0 || enableLocalClipping || // enable state of previous frame - the clipping code has to
			// run another frame in order to reset the state:
			numGlobalPlanes !== 0 || localClippingEnabled;
			localClippingEnabled = enableLocalClipping;
			globalState = projectPlanes(planes, camera, 0);
			numGlobalPlanes = planes.length;
			return enabled;
		};

		this.beginShadows = function () {
			renderingShadows = true;
			projectPlanes(null);
		};

		this.endShadows = function () {
			renderingShadows = false;
			resetGlobalState();
		};

		this.setState = function (material, camera, useCache) {
			var planes = material.clippingPlanes,
					clipIntersection = material.clipIntersection,
					clipShadows = material.clipShadows;
			var materialProperties = properties.get(material);

			if (!localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && !clipShadows) {
				// there's no local clipping
				if (renderingShadows) {
					// there's no global clipping
					projectPlanes(null);
				} else {
					resetGlobalState();
				}
			} else {
				var nGlobal = renderingShadows ? 0 : numGlobalPlanes,
						lGlobal = nGlobal * 4;
				var dstArray = materialProperties.clippingState || null;
				uniform.value = dstArray; // ensure unique state

				dstArray = projectPlanes(planes, camera, lGlobal, useCache);

				for (var i = 0; i !== lGlobal; ++i) {
					dstArray[i] = globalState[i];
				}

				materialProperties.clippingState = dstArray;
				this.numIntersection = clipIntersection ? this.numPlanes : 0;
				this.numPlanes += nGlobal;
			}
		};

		function resetGlobalState() {
			if (uniform.value !== globalState) {
				uniform.value = globalState;
				uniform.needsUpdate = numGlobalPlanes > 0;
			}

			scope.numPlanes = numGlobalPlanes;
			scope.numIntersection = 0;
		}

		function projectPlanes(planes, camera, dstOffset, skipTransform) {
			var nPlanes = planes !== null ? planes.length : 0;
			var dstArray = null;

			if (nPlanes !== 0) {
				dstArray = uniform.value;

				if (skipTransform !== true || dstArray === null) {
					var flatSize = dstOffset + nPlanes * 4,
							viewMatrix = camera.matrixWorldInverse;
					viewNormalMatrix.getNormalMatrix(viewMatrix);

					if (dstArray === null || dstArray.length < flatSize) {
						dstArray = new Float32Array(flatSize);
					}

					for (var i = 0, i4 = dstOffset; i !== nPlanes; ++i, i4 += 4) {
						plane.copy(planes[i]).applyMatrix4(viewMatrix, viewNormalMatrix);
						plane.normal.toArray(dstArray, i4);
						dstArray[i4 + 3] = plane.constant;
					}
				}

				uniform.value = dstArray;
				uniform.needsUpdate = true;
			}

			scope.numPlanes = nPlanes;
			scope.numIntersection = 0;
			return dstArray;
		}
	}

	function WebGLCubeMaps(renderer) {
		var cubemaps = new WeakMap();

		function mapTextureMapping(texture, mapping) {
			if (mapping === EquirectangularReflectionMapping) {
				texture.mapping = CubeReflectionMapping;
			} else if (mapping === EquirectangularRefractionMapping) {
				texture.mapping = CubeRefractionMapping;
			}

			return texture;
		}

		function get(texture) {
			if (texture && texture.isTexture && texture.isRenderTargetTexture === false) {
				var mapping = texture.mapping;

				if (mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping) {
					if (cubemaps.has(texture)) {
						var cubemap = cubemaps.get(texture).texture;
						return mapTextureMapping(cubemap, texture.mapping);
					} else {
						var image = texture.image;

						if (image && image.height > 0) {
							var currentRenderTarget = renderer.getRenderTarget();
							var renderTarget = new WebGLCubeRenderTarget(image.height / 2);
							renderTarget.fromEquirectangularTexture(renderer, texture);
							cubemaps.set(texture, renderTarget);
							renderer.setRenderTarget(currentRenderTarget);
							texture.addEventListener('dispose', onTextureDispose);
							return mapTextureMapping(renderTarget.texture, texture.mapping);
						} else {
							// image not yet ready. try the conversion next frame
							return null;
						}
					}
				}
			}

			return texture;
		}

		function onTextureDispose(event) {
			var texture = event.target;
			texture.removeEventListener('dispose', onTextureDispose);
			var cubemap = cubemaps.get(texture);

			if (cubemap !== undefined) {
				cubemaps.delete(texture);
				cubemap.dispose();
			}
		}

		function dispose() {
			cubemaps = new WeakMap();
		}

		return {
			get: get,
			dispose: dispose
		};
	}

	var OrthographicCamera = /*#__PURE__*/function (_Camera) {
		_inheritsLoose(OrthographicCamera, _Camera);

		function OrthographicCamera(left, right, top, bottom, near, far) {
			var _this;

			if (left === void 0) {
				left = -1;
			}

			if (right === void 0) {
				right = 1;
			}

			if (top === void 0) {
				top = 1;
			}

			if (bottom === void 0) {
				bottom = -1;
			}

			if (near === void 0) {
				near = 0.1;
			}

			if (far === void 0) {
				far = 2000;
			}

			_this = _Camera.call(this) || this;
			_this.type = 'OrthographicCamera';
			_this.zoom = 1;
			_this.view = null;
			_this.left = left;
			_this.right = right;
			_this.top = top;
			_this.bottom = bottom;
			_this.near = near;
			_this.far = far;

			_this.updateProjectionMatrix();

			return _this;
		}

		var _proto = OrthographicCamera.prototype;

		_proto.copy = function copy(source, recursive) {
			_Camera.prototype.copy.call(this, source, recursive);

			this.left = source.left;
			this.right = source.right;
			this.top = source.top;
			this.bottom = source.bottom;
			this.near = source.near;
			this.far = source.far;
			this.zoom = source.zoom;
			this.view = source.view === null ? null : Object.assign({}, source.view);
			return this;
		};

		_proto.setViewOffset = function setViewOffset(fullWidth, fullHeight, x, y, width, height) {
			if (this.view === null) {
				this.view = {
					enabled: true,
					fullWidth: 1,
					fullHeight: 1,
					offsetX: 0,
					offsetY: 0,
					width: 1,
					height: 1
				};
			}

			this.view.enabled = true;
			this.view.fullWidth = fullWidth;
			this.view.fullHeight = fullHeight;
			this.view.offsetX = x;
			this.view.offsetY = y;
			this.view.width = width;
			this.view.height = height;
			this.updateProjectionMatrix();
		};

		_proto.clearViewOffset = function clearViewOffset() {
			if (this.view !== null) {
				this.view.enabled = false;
			}

			this.updateProjectionMatrix();
		};

		_proto.updateProjectionMatrix = function updateProjectionMatrix() {
			var dx = (this.right - this.left) / (2 * this.zoom);
			var dy = (this.top - this.bottom) / (2 * this.zoom);
			var cx = (this.right + this.left) / 2;
			var cy = (this.top + this.bottom) / 2;
			var left = cx - dx;
			var right = cx + dx;
			var top = cy + dy;
			var bottom = cy - dy;

			if (this.view !== null && this.view.enabled) {
				var scaleW = (this.right - this.left) / this.view.fullWidth / this.zoom;
				var scaleH = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
				left += scaleW * this.view.offsetX;
				right = left + scaleW * this.view.width;
				top -= scaleH * this.view.offsetY;
				bottom = top - scaleH * this.view.height;
			}

			this.projectionMatrix.makeOrthographic(left, right, top, bottom, this.near, this.far);
			this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
		};

		_proto.toJSON = function toJSON(meta) {
			var data = _Camera.prototype.toJSON.call(this, meta);

			data.object.zoom = this.zoom;
			data.object.left = this.left;
			data.object.right = this.right;
			data.object.top = this.top;
			data.object.bottom = this.bottom;
			data.object.near = this.near;
			data.object.far = this.far;
			if (this.view !== null) data.object.view = Object.assign({}, this.view);
			return data;
		};

		return OrthographicCamera;
	}(Camera);

	OrthographicCamera.prototype.isOrthographicCamera = true;

	var RawShaderMaterial = /*#__PURE__*/function (_ShaderMaterial) {
		_inheritsLoose(RawShaderMaterial, _ShaderMaterial);

		function RawShaderMaterial(parameters) {
			var _this;

			_this = _ShaderMaterial.call(this, parameters) || this;
			_this.type = 'RawShaderMaterial';
			return _this;
		}

		return RawShaderMaterial;
	}(ShaderMaterial);

	RawShaderMaterial.prototype.isRawShaderMaterial = true;

	var _ENCODINGS;
	var LOD_MIN = 4;
	var LOD_MAX = 8;
	var SIZE_MAX = Math.pow(2, LOD_MAX); // The standard deviations (radians) associated with the extra mips. These are
	// chosen to approximate a Trowbridge-Reitz distribution function times the
	// geometric shadowing function. These sigma values squared must match the
	// variance #defines in cube_uv_reflection_fragment.glsl.js.

	var EXTRA_LOD_SIGMA = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582];
	var TOTAL_LODS = LOD_MAX - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length; // The maximum length of the blur for loop. Smaller sigmas will use fewer
	// samples and exit early, but not recompile the shader.

	var MAX_SAMPLES = 20;
	var ENCODINGS = (_ENCODINGS = {}, _ENCODINGS[LinearEncoding] = 0, _ENCODINGS[sRGBEncoding] = 1, _ENCODINGS[RGBEEncoding] = 2, _ENCODINGS[RGBM7Encoding] = 3, _ENCODINGS[RGBM16Encoding] = 4, _ENCODINGS[RGBDEncoding] = 5, _ENCODINGS[GammaEncoding] = 6, _ENCODINGS);

	var _flatCamera = /*@__PURE__*/new OrthographicCamera();

	var _createPlanes2 = /*@__PURE__*/_createPlanes(),
			_lodPlanes = _createPlanes2._lodPlanes,
			_sizeLods = _createPlanes2._sizeLods,
			_sigmas = _createPlanes2._sigmas;

	var _clearColor = /*@__PURE__*/new Color();

	var _oldTarget = null; // Golden Ratio

	var PHI = (1 + Math.sqrt(5)) / 2;
	var INV_PHI = 1 / PHI; // Vertices of a dodecahedron (except the opposites, which represent the
	// same axis), used as axis directions evenly spread on a sphere.

	var _axisDirections = [/*@__PURE__*/new Vector3(1, 1, 1), /*@__PURE__*/new Vector3(-1, 1, 1), /*@__PURE__*/new Vector3(1, 1, -1), /*@__PURE__*/new Vector3(-1, 1, -1), /*@__PURE__*/new Vector3(0, PHI, INV_PHI), /*@__PURE__*/new Vector3(0, PHI, -INV_PHI), /*@__PURE__*/new Vector3(INV_PHI, 0, PHI), /*@__PURE__*/new Vector3(-INV_PHI, 0, PHI), /*@__PURE__*/new Vector3(PHI, INV_PHI, 0), /*@__PURE__*/new Vector3(-PHI, INV_PHI, 0)];
	/**
	 * This class generates a Prefiltered, Mipmapped Radiance Environment Map
	 * (PMREM) from a cubeMap environment texture. This allows different levels of
	 * blur to be quickly accessed based on material roughness. It is packed into a
	 * special CubeUV format that allows us to perform custom interpolation so that
	 * we can support nonlinear formats such as RGBE. Unlike a traditional mipmap
	 * chain, it only goes down to the LOD_MIN level (above), and then creates extra
	 * even more filtered 'mips' at the same LOD_MIN resolution, associated with
	 * higher roughness levels. In this way we maintain resolution to smoothly
	 * interpolate diffuse lighting while limiting sampling computation.
	 *
	 * Paper: Fast, Accurate Image-Based Lighting
	 * https://drive.google.com/file/d/15y8r_UpKlU9SvV4ILb0C3qCPecS8pvLz/view
	*/

	var PMREMGenerator = /*#__PURE__*/function () {
		function PMREMGenerator(renderer) {
			this._renderer = renderer;
			this._pingPongRenderTarget = null;
			this._blurMaterial = _getBlurShader(MAX_SAMPLES);
			this._equirectShader = null;
			this._cubemapShader = null;

			this._compileMaterial(this._blurMaterial);
		}
		/**
		 * Generates a PMREM from a supplied Scene, which can be faster than using an
		 * image if networking bandwidth is low. Optional sigma specifies a blur radius
		 * in radians to be applied to the scene before PMREM generation. Optional near
		 * and far planes ensure the scene is rendered in its entirety (the cubeCamera
		 * is placed at the origin).
		 */


		var _proto = PMREMGenerator.prototype;

		_proto.fromScene = function fromScene(scene, sigma, near, far) {
			if (sigma === void 0) {
				sigma = 0;
			}

			if (near === void 0) {
				near = 0.1;
			}

			if (far === void 0) {
				far = 100;
			}

			_oldTarget = this._renderer.getRenderTarget();

			var cubeUVRenderTarget = this._allocateTargets();

			this._sceneToCubeUV(scene, near, far, cubeUVRenderTarget);

			if (sigma > 0) {
				this._blur(cubeUVRenderTarget, 0, 0, sigma);
			}

			this._applyPMREM(cubeUVRenderTarget);

			this._cleanup(cubeUVRenderTarget);

			return cubeUVRenderTarget;
		}
		/**
		 * Generates a PMREM from an equirectangular texture, which can be either LDR
		 * (RGBFormat) or HDR (RGBEFormat). The ideal input image size is 1k (1024 x 512),
		 * as this matches best with the 256 x 256 cubemap output.
		 */
		;

		_proto.fromEquirectangular = function fromEquirectangular(equirectangular) {
			return this._fromTexture(equirectangular);
		}
		/**
		 * Generates a PMREM from an cubemap texture, which can be either LDR
		 * (RGBFormat) or HDR (RGBEFormat). The ideal input cube size is 256 x 256,
		 * as this matches best with the 256 x 256 cubemap output.
		 */
		;

		_proto.fromCubemap = function fromCubemap(cubemap) {
			return this._fromTexture(cubemap);
		}
		/**
		 * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during
		 * your texture's network fetch for increased concurrency.
		 */
		;

		_proto.compileCubemapShader = function compileCubemapShader() {
			if (this._cubemapShader === null) {
				this._cubemapShader = _getCubemapShader();

				this._compileMaterial(this._cubemapShader);
			}
		}
		/**
		 * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during
		 * your texture's network fetch for increased concurrency.
		 */
		;

		_proto.compileEquirectangularShader = function compileEquirectangularShader() {
			if (this._equirectShader === null) {
				this._equirectShader = _getEquirectShader();

				this._compileMaterial(this._equirectShader);
			}
		}
		/**
		 * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,
		 * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on
		 * one of them will cause any others to also become unusable.
		 */
		;

		_proto.dispose = function dispose() {
			this._blurMaterial.dispose();

			if (this._cubemapShader !== null) this._cubemapShader.dispose();
			if (this._equirectShader !== null) this._equirectShader.dispose();

			for (var i = 0; i < _lodPlanes.length; i++) {
				_lodPlanes[i].dispose();
			}
		} // private interface
		;

		_proto._cleanup = function _cleanup(outputTarget) {
			this._pingPongRenderTarget.dispose();

			this._renderer.setRenderTarget(_oldTarget);

			outputTarget.scissorTest = false;

			_setViewport(outputTarget, 0, 0, outputTarget.width, outputTarget.height);
		};

		_proto._fromTexture = function _fromTexture(texture) {
			_oldTarget = this._renderer.getRenderTarget();

			var cubeUVRenderTarget = this._allocateTargets(texture);

			this._textureToCubeUV(texture, cubeUVRenderTarget);

			this._applyPMREM(cubeUVRenderTarget);

			this._cleanup(cubeUVRenderTarget);

			return cubeUVRenderTarget;
		};

		_proto._allocateTargets = function _allocateTargets(texture) {
			// warning: null texture is valid
			var params = {
				magFilter: NearestFilter,
				minFilter: NearestFilter,
				generateMipmaps: false,
				type: UnsignedByteType,
				format: RGBEFormat,
				encoding: _isLDR(texture) ? texture.encoding : RGBEEncoding,
				depthBuffer: false
			};

			var cubeUVRenderTarget = _createRenderTarget(params);

			cubeUVRenderTarget.depthBuffer = texture ? false : true;
			this._pingPongRenderTarget = _createRenderTarget(params);
			return cubeUVRenderTarget;
		};

		_proto._compileMaterial = function _compileMaterial(material) {
			var tmpMesh = new Mesh(_lodPlanes[0], material);

			this._renderer.compile(tmpMesh, _flatCamera);
		};

		_proto._sceneToCubeUV = function _sceneToCubeUV(scene, near, far, cubeUVRenderTarget) {
			var fov = 90;
			var aspect = 1;
			var cubeCamera = new PerspectiveCamera(fov, aspect, near, far);
			var upSign = [1, -1, 1, 1, 1, 1];
			var forwardSign = [1, 1, 1, -1, -1, -1];
			var renderer = this._renderer;
			var originalAutoClear = renderer.autoClear;
			var outputEncoding = renderer.outputEncoding;
			var toneMapping = renderer.toneMapping;
			renderer.getClearColor(_clearColor);
			renderer.toneMapping = NoToneMapping;
			renderer.outputEncoding = LinearEncoding;
			renderer.autoClear = false;
			var backgroundMaterial = new MeshBasicMaterial({
				name: 'PMREM.Background',
				side: BackSide,
				depthWrite: false,
				depthTest: false
			});
			var backgroundBox = new Mesh(new BoxGeometry(), backgroundMaterial);
			var useSolidColor = false;
			var background = scene.background;

			if (background) {
				if (background.isColor) {
					backgroundMaterial.color.copy(background);
					scene.background = null;
					useSolidColor = true;
				}
			} else {
				backgroundMaterial.color.copy(_clearColor);
				useSolidColor = true;
			}

			for (var i = 0; i < 6; i++) {
				var col = i % 3;

				if (col == 0) {
					cubeCamera.up.set(0, upSign[i], 0);
					cubeCamera.lookAt(forwardSign[i], 0, 0);
				} else if (col == 1) {
					cubeCamera.up.set(0, 0, upSign[i]);
					cubeCamera.lookAt(0, forwardSign[i], 0);
				} else {
					cubeCamera.up.set(0, upSign[i], 0);
					cubeCamera.lookAt(0, 0, forwardSign[i]);
				}

				_setViewport(cubeUVRenderTarget, col * SIZE_MAX, i > 2 ? SIZE_MAX : 0, SIZE_MAX, SIZE_MAX);

				renderer.setRenderTarget(cubeUVRenderTarget);

				if (useSolidColor) {
					renderer.render(backgroundBox, cubeCamera);
				}

				renderer.render(scene, cubeCamera);
			}

			backgroundBox.geometry.dispose();
			backgroundBox.material.dispose();
			renderer.toneMapping = toneMapping;
			renderer.outputEncoding = outputEncoding;
			renderer.autoClear = originalAutoClear;
			scene.background = background;
		};

		_proto._setEncoding = function _setEncoding(uniform, texture) {
			if (this._renderer.capabilities.isWebGL2 === true && texture.format === RGBAFormat && texture.type === UnsignedByteType && texture.encoding === sRGBEncoding) {
				uniform.value = ENCODINGS[LinearEncoding];
			} else {
				uniform.value = ENCODINGS[texture.encoding];
			}
		};

		_proto._textureToCubeUV = function _textureToCubeUV(texture, cubeUVRenderTarget) {
			var renderer = this._renderer;

			if (texture.isCubeTexture) {
				if (this._cubemapShader == null) {
					this._cubemapShader = _getCubemapShader();
				}
			} else {
				if (this._equirectShader == null) {
					this._equirectShader = _getEquirectShader();
				}
			}

			var material = texture.isCubeTexture ? this._cubemapShader : this._equirectShader;
			var mesh = new Mesh(_lodPlanes[0], material);
			var uniforms = material.uniforms;
			uniforms['envMap'].value = texture;

			if (!texture.isCubeTexture) {
				uniforms['texelSize'].value.set(1.0 / texture.image.width, 1.0 / texture.image.height);
			}

			this._setEncoding(uniforms['inputEncoding'], texture);

			this._setEncoding(uniforms['outputEncoding'], cubeUVRenderTarget.texture);

			_setViewport(cubeUVRenderTarget, 0, 0, 3 * SIZE_MAX, 2 * SIZE_MAX);

			renderer.setRenderTarget(cubeUVRenderTarget);
			renderer.render(mesh, _flatCamera);
		};

		_proto._applyPMREM = function _applyPMREM(cubeUVRenderTarget) {
			var renderer = this._renderer;
			var autoClear = renderer.autoClear;
			renderer.autoClear = false;

			for (var i = 1; i < TOTAL_LODS; i++) {
				var sigma = Math.sqrt(_sigmas[i] * _sigmas[i] - _sigmas[i - 1] * _sigmas[i - 1]);
				var poleAxis = _axisDirections[(i - 1) % _axisDirections.length];

				this._blur(cubeUVRenderTarget, i - 1, i, sigma, poleAxis);
			}

			renderer.autoClear = autoClear;
		}
		/**
		 * This is a two-pass Gaussian blur for a cubemap. Normally this is done
		 * vertically and horizontally, but this breaks down on a cube. Here we apply
		 * the blur latitudinally (around the poles), and then longitudinally (towards
		 * the poles) to approximate the orthogonally-separable blur. It is least
		 * accurate at the poles, but still does a decent job.
		 */
		;

		_proto._blur = function _blur(cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis) {
			var pingPongRenderTarget = this._pingPongRenderTarget;

			this._halfBlur(cubeUVRenderTarget, pingPongRenderTarget, lodIn, lodOut, sigma, 'latitudinal', poleAxis);

			this._halfBlur(pingPongRenderTarget, cubeUVRenderTarget, lodOut, lodOut, sigma, 'longitudinal', poleAxis);
		};

		_proto._halfBlur = function _halfBlur(targetIn, targetOut, lodIn, lodOut, sigmaRadians, direction, poleAxis) {
			var renderer = this._renderer;
			var blurMaterial = this._blurMaterial;

			if (direction !== 'latitudinal' && direction !== 'longitudinal') {
				console.error('blur direction must be either latitudinal or longitudinal!');
			} // Number of standard deviations at which to cut off the discrete approximation.


			var STANDARD_DEVIATIONS = 3;
			var blurMesh = new Mesh(_lodPlanes[lodOut], blurMaterial);
			var blurUniforms = blurMaterial.uniforms;
			var pixels = _sizeLods[lodIn] - 1;
			var radiansPerPixel = isFinite(sigmaRadians) ? Math.PI / (2 * pixels) : 2 * Math.PI / (2 * MAX_SAMPLES - 1);
			var sigmaPixels = sigmaRadians / radiansPerPixel;
			var samples = isFinite(sigmaRadians) ? 1 + Math.floor(STANDARD_DEVIATIONS * sigmaPixels) : MAX_SAMPLES;

			if (samples > MAX_SAMPLES) {
				console.warn("sigmaRadians, " + sigmaRadians + ", is too large and will clip, as it requested " + samples + " samples when the maximum is set to " + MAX_SAMPLES);
			}

			var weights = [];
			var sum = 0;

			for (var i = 0; i < MAX_SAMPLES; ++i) {
				var _x = i / sigmaPixels;

				var weight = Math.exp(-_x * _x / 2);
				weights.push(weight);

				if (i == 0) {
					sum += weight;
				} else if (i < samples) {
					sum += 2 * weight;
				}
			}

			for (var _i = 0; _i < weights.length; _i++) {
				weights[_i] = weights[_i] / sum;
			}

			blurUniforms['envMap'].value = targetIn.texture;
			blurUniforms['samples'].value = samples;
			blurUniforms['weights'].value = weights;
			blurUniforms['latitudinal'].value = direction === 'latitudinal';

			if (poleAxis) {
				blurUniforms['poleAxis'].value = poleAxis;
			}

			blurUniforms['dTheta'].value = radiansPerPixel;
			blurUniforms['mipInt'].value = LOD_MAX - lodIn;

			this._setEncoding(blurUniforms['inputEncoding'], targetIn.texture);

			this._setEncoding(blurUniforms['outputEncoding'], targetIn.texture);

			var outputSize = _sizeLods[lodOut];
			var x = 3 * Math.max(0, SIZE_MAX - 2 * outputSize);
			var y = (lodOut === 0 ? 0 : 2 * SIZE_MAX) + 2 * outputSize * (lodOut > LOD_MAX - LOD_MIN ? lodOut - LOD_MAX + LOD_MIN : 0);

			_setViewport(targetOut, x, y, 3 * outputSize, 2 * outputSize);

			renderer.setRenderTarget(targetOut);
			renderer.render(blurMesh, _flatCamera);
		};

		return PMREMGenerator;
	}();

	function _isLDR(texture) {
		if (texture === undefined || texture.type !== UnsignedByteType) return false;
		return texture.encoding === LinearEncoding || texture.encoding === sRGBEncoding || texture.encoding === GammaEncoding;
	}

	function _createPlanes() {
		var _lodPlanes = [];
		var _sizeLods = [];
		var _sigmas = [];
		var lod = LOD_MAX;

		for (var i = 0; i < TOTAL_LODS; i++) {
			var sizeLod = Math.pow(2, lod);

			_sizeLods.push(sizeLod);

			var sigma = 1.0 / sizeLod;

			if (i > LOD_MAX - LOD_MIN) {
				sigma = EXTRA_LOD_SIGMA[i - LOD_MAX + LOD_MIN - 1];
			} else if (i == 0) {
				sigma = 0;
			}

			_sigmas.push(sigma);

			var texelSize = 1.0 / (sizeLod - 1);
			var min = -texelSize / 2;
			var max = 1 + texelSize / 2;
			var uv1 = [min, min, max, min, max, max, min, min, max, max, min, max];
			var cubeFaces = 6;
			var vertices = 6;
			var positionSize = 3;
			var uvSize = 2;
			var faceIndexSize = 1;
			var position = new Float32Array(positionSize * vertices * cubeFaces);
			var uv = new Float32Array(uvSize * vertices * cubeFaces);
			var faceIndex = new Float32Array(faceIndexSize * vertices * cubeFaces);

			for (var face = 0; face < cubeFaces; face++) {
				var x = face % 3 * 2 / 3 - 1;
				var y = face > 2 ? 0 : -1;
				var coordinates = [x, y, 0, x + 2 / 3, y, 0, x + 2 / 3, y + 1, 0, x, y, 0, x + 2 / 3, y + 1, 0, x, y + 1, 0];
				position.set(coordinates, positionSize * vertices * face);
				uv.set(uv1, uvSize * vertices * face);
				var fill = [face, face, face, face, face, face];
				faceIndex.set(fill, faceIndexSize * vertices * face);
			}

			var planes = new BufferGeometry();
			planes.setAttribute('position', new BufferAttribute(position, positionSize));
			planes.setAttribute('uv', new BufferAttribute(uv, uvSize));
			planes.setAttribute('faceIndex', new BufferAttribute(faceIndex, faceIndexSize));

			_lodPlanes.push(planes);

			if (lod > LOD_MIN) {
				lod--;
			}
		}

		return {
			_lodPlanes: _lodPlanes,
			_sizeLods: _sizeLods,
			_sigmas: _sigmas
		};
	}

	function _createRenderTarget(params) {
		var cubeUVRenderTarget = new WebGLRenderTarget(3 * SIZE_MAX, 3 * SIZE_MAX, params);
		cubeUVRenderTarget.texture.mapping = CubeUVReflectionMapping;
		cubeUVRenderTarget.texture.name = 'PMREM.cubeUv';
		cubeUVRenderTarget.scissorTest = true;
		return cubeUVRenderTarget;
	}

	function _setViewport(target, x, y, width, height) {
		target.viewport.set(x, y, width, height);
		target.scissor.set(x, y, width, height);
	}

	function _getBlurShader(maxSamples) {
		var weights = new Float32Array(maxSamples);
		var poleAxis = new Vector3(0, 1, 0);
		var shaderMaterial = new RawShaderMaterial({
			name: 'SphericalGaussianBlur',
			defines: {
				'n': maxSamples
			},
			uniforms: {
				'envMap': {
					value: null
				},
				'samples': {
					value: 1
				},
				'weights': {
					value: weights
				},
				'latitudinal': {
					value: false
				},
				'dTheta': {
					value: 0
				},
				'mipInt': {
					value: 0
				},
				'poleAxis': {
					value: poleAxis
				},
				'inputEncoding': {
					value: ENCODINGS[LinearEncoding]
				},
				'outputEncoding': {
					value: ENCODINGS[LinearEncoding]
				}
			},
			vertexShader: _getCommonVertexShader(),
			fragmentShader:
			/* glsl */
			"\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t" + _getEncodings() + "\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t",
			blending: NoBlending,
			depthTest: false,
			depthWrite: false
		});
		return shaderMaterial;
	}

	function _getEquirectShader() {
		var texelSize = new Vector2(1, 1);
		var shaderMaterial = new RawShaderMaterial({
			name: 'EquirectangularToCubeUV',
			uniforms: {
				'envMap': {
					value: null
				},
				'texelSize': {
					value: texelSize
				},
				'inputEncoding': {
					value: ENCODINGS[LinearEncoding]
				},
				'outputEncoding': {
					value: ENCODINGS[LinearEncoding]
				}
			},
			vertexShader: _getCommonVertexShader(),
			fragmentShader:
			/* glsl */
			"\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform vec2 texelSize;\n\n\t\t\t" + _getEncodings() + "\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tvec2 f = fract( uv / texelSize - 0.5 );\n\t\t\t\tuv -= f * texelSize;\n\t\t\t\tvec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x += texelSize.x;\n\t\t\t\tvec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.y += texelSize.y;\n\t\t\t\tvec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x -= texelSize.x;\n\t\t\t\tvec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\n\t\t\t\tvec3 tm = mix( tl, tr, f.x );\n\t\t\t\tvec3 bm = mix( bl, br, f.x );\n\t\t\t\tgl_FragColor.rgb = mix( tm, bm, f.y );\n\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t",
			blending: NoBlending,
			depthTest: false,
			depthWrite: false
		});
		return shaderMaterial;
	}

	function _getCubemapShader() {
		var shaderMaterial = new RawShaderMaterial({
			name: 'CubemapToCubeUV',
			uniforms: {
				'envMap': {
					value: null
				},
				'inputEncoding': {
					value: ENCODINGS[LinearEncoding]
				},
				'outputEncoding': {
					value: ENCODINGS[LinearEncoding]
				}
			},
			vertexShader: _getCommonVertexShader(),
			fragmentShader:
			/* glsl */
			"\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\t" + _getEncodings() + "\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb = envMapTexelToLinear( textureCube( envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ) ) ).rgb;\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t",
			blending: NoBlending,
			depthTest: false,
			depthWrite: false
		});
		return shaderMaterial;
	}

	function _getCommonVertexShader() {
		return (
			/* glsl */
			"\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t"
		);
	}

	function _getEncodings() {
		return (
			/* glsl */
			"\n\n\t\tuniform int inputEncoding;\n\t\tuniform int outputEncoding;\n\n\t\t#include <encodings_pars_fragment>\n\n\t\tvec4 inputTexelToLinear( vec4 value ) {\n\n\t\t\tif ( inputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( inputEncoding == 1 ) {\n\n\t\t\t\treturn sRGBToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 2 ) {\n\n\t\t\t\treturn RGBEToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 3 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 7.0 );\n\n\t\t\t} else if ( inputEncoding == 4 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 16.0 );\n\n\t\t\t} else if ( inputEncoding == 5 ) {\n\n\t\t\t\treturn RGBDToLinear( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn GammaToLinear( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 linearToOutputTexel( vec4 value ) {\n\n\t\t\tif ( outputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( outputEncoding == 1 ) {\n\n\t\t\t\treturn LinearTosRGB( value );\n\n\t\t\t} else if ( outputEncoding == 2 ) {\n\n\t\t\t\treturn LinearToRGBE( value );\n\n\t\t\t} else if ( outputEncoding == 3 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 7.0 );\n\n\t\t\t} else if ( outputEncoding == 4 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 16.0 );\n\n\t\t\t} else if ( outputEncoding == 5 ) {\n\n\t\t\t\treturn LinearToRGBD( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn LinearToGamma( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 envMapTexelToLinear( vec4 color ) {\n\n\t\t\treturn inputTexelToLinear( color );\n\n\t\t}\n\t"
		);
	}

	function WebGLCubeUVMaps(renderer) {
		var cubeUVmaps = new WeakMap();
		var pmremGenerator = null;

		function get(texture) {
			if (texture && texture.isTexture && texture.isRenderTargetTexture === false) {
				var mapping = texture.mapping;
				var isEquirectMap = mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping;
				var isCubeMap = mapping === CubeReflectionMapping || mapping === CubeRefractionMapping;

				if (isEquirectMap || isCubeMap) {
					// equirect/cube map to cubeUV conversion
					if (cubeUVmaps.has(texture)) {
						return cubeUVmaps.get(texture).texture;
					} else {
						var image = texture.image;

						if (isEquirectMap && image && image.height > 0 || isCubeMap && image && isCubeTextureComplete(image)) {
							var currentRenderTarget = renderer.getRenderTarget();
							if (pmremGenerator === null) pmremGenerator = new PMREMGenerator(renderer);
							var renderTarget = isEquirectMap ? pmremGenerator.fromEquirectangular(texture) : pmremGenerator.fromCubemap(texture);
							cubeUVmaps.set(texture, renderTarget);
							renderer.setRenderTarget(currentRenderTarget);
							texture.addEventListener('dispose', onTextureDispose);
							return renderTarget.texture;
						} else {
							// image not yet ready. try the conversion next frame
							return null;
						}
					}
				}
			}

			return texture;
		}

		function isCubeTextureComplete(image) {
			var count = 0;
			var length = 6;

			for (var i = 0; i < length; i++) {
				if (image[i] !== undefined) count++;
			}

			return count === length;
		}

		function onTextureDispose(event) {
			var texture = event.target;
			texture.removeEventListener('dispose', onTextureDispose);
			var cubemapUV = cubeUVmaps.get(texture);

			if (cubemapUV !== undefined) {
				cubeUVmaps.delete(texture);
				cubemapUV.dispose();
			}
		}

		function dispose() {
			cubeUVmaps = new WeakMap();

			if (pmremGenerator !== null) {
				pmremGenerator.dispose();
				pmremGenerator = null;
			}
		}

		return {
			get: get,
			dispose: dispose
		};
	}

	function WebGLExtensions(gl) {
		var extensions = {};

		function getExtension(name) {
			if (extensions[name] !== undefined) {
				return extensions[name];
			}

			var extension;

			switch (name) {
				case 'WEBGL_depth_texture':
					extension = gl.getExtension('WEBGL_depth_texture') || gl.getExtension('MOZ_WEBGL_depth_texture') || gl.getExtension('WEBKIT_WEBGL_depth_texture');
					break;

				case 'EXT_texture_filter_anisotropic':
					extension = gl.getExtension('EXT_texture_filter_anisotropic') || gl.getExtension('MOZ_EXT_texture_filter_anisotropic') || gl.getExtension('WEBKIT_EXT_texture_filter_anisotropic');
					break;

				case 'WEBGL_compressed_texture_s3tc':
					extension = gl.getExtension('WEBGL_compressed_texture_s3tc') || gl.getExtension('MOZ_WEBGL_compressed_texture_s3tc') || gl.getExtension('WEBKIT_WEBGL_compressed_texture_s3tc');
					break;

				case 'WEBGL_compressed_texture_pvrtc':
					extension = gl.getExtension('WEBGL_compressed_texture_pvrtc') || gl.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc');
					break;

				default:
					extension = gl.getExtension(name);
			}

			extensions[name] = extension;
			return extension;
		}

		return {
			has: function has(name) {
				return getExtension(name) !== null;
			},
			init: function init(capabilities) {
				if (capabilities.isWebGL2) {
					getExtension('EXT_color_buffer_float');
				} else {
					getExtension('WEBGL_depth_texture');
					getExtension('OES_texture_float');
					getExtension('OES_texture_half_float');
					getExtension('OES_texture_half_float_linear');
					getExtension('OES_standard_derivatives');
					getExtension('OES_element_index_uint');
					getExtension('OES_vertex_array_object');
					getExtension('ANGLE_instanced_arrays');
				}

				getExtension('OES_texture_float_linear');
				getExtension('EXT_color_buffer_half_float');
			},
			get: function get(name) {
				var extension = getExtension(name);

				if (extension === null) {
					console.warn('THREE.WebGLRenderer: ' + name + ' extension not supported.');
				}

				return extension;
			}
		};
	}

	function WebGLGeometries(gl, attributes, info, bindingStates) {
		var geometries = {};
		var wireframeAttributes = new WeakMap();

		function onGeometryDispose(event) {
			var geometry = event.target;

			if (geometry.index !== null) {
				attributes.remove(geometry.index);
			}

			for (var name in geometry.attributes) {
				attributes.remove(geometry.attributes[name]);
			}

			geometry.removeEventListener('dispose', onGeometryDispose);
			delete geometries[geometry.id];
			var attribute = wireframeAttributes.get(geometry);

			if (attribute) {
				attributes.remove(attribute);
				wireframeAttributes.delete(geometry);
			}

			bindingStates.releaseStatesOfGeometry(geometry);

			if (geometry.isInstancedBufferGeometry === true) {
				delete geometry._maxInstanceCount;
			} //


			info.memory.geometries--;
		}

		function get(object, geometry) {
			if (geometries[geometry.id] === true) return geometry;
			geometry.addEventListener('dispose', onGeometryDispose);
			geometries[geometry.id] = true;
			info.memory.geometries++;
			return geometry;
		}

		function update(geometry) {
			var geometryAttributes = geometry.attributes; // Updating index buffer in VAO now. See WebGLBindingStates.

			for (var name in geometryAttributes) {
				attributes.update(geometryAttributes[name], gl.ARRAY_BUFFER);
			} // morph targets


			var morphAttributes = geometry.morphAttributes;

			for (var _name in morphAttributes) {
				var array = morphAttributes[_name];

				for (var i = 0, l = array.length; i < l; i++) {
					attributes.update(array[i], gl.ARRAY_BUFFER);
				}
			}
		}

		function updateWireframeAttribute(geometry) {
			var indices = [];
			var geometryIndex = geometry.index;
			var geometryPosition = geometry.attributes.position;
			var version = 0;

			if (geometryIndex !== null) {
				var array = geometryIndex.array;
				version = geometryIndex.version;

				for (var i = 0, l = array.length; i < l; i += 3) {
					var a = array[i + 0];
					var b = array[i + 1];
					var c = array[i + 2];
					indices.push(a, b, b, c, c, a);
				}
			} else {
				var _array = geometryPosition.array;
				version = geometryPosition.version;

				for (var _i = 0, _l = _array.length / 3 - 1; _i < _l; _i += 3) {
					var _a = _i + 0;

					var _b = _i + 1;

					var _c = _i + 2;

					indices.push(_a, _b, _b, _c, _c, _a);
				}
			}

			var attribute = new (arrayMax(indices) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute)(indices, 1);
			attribute.version = version; // Updating index buffer in VAO now. See WebGLBindingStates
			//

			var previousAttribute = wireframeAttributes.get(geometry);
			if (previousAttribute) attributes.remove(previousAttribute); //

			wireframeAttributes.set(geometry, attribute);
		}

		function getWireframeAttribute(geometry) {
			var currentAttribute = wireframeAttributes.get(geometry);

			if (currentAttribute) {
				var geometryIndex = geometry.index;

				if (geometryIndex !== null) {
					// if the attribute is obsolete, create a new one
					if (currentAttribute.version < geometryIndex.version) {
						updateWireframeAttribute(geometry);
					}
				}
			} else {
				updateWireframeAttribute(geometry);
			}

			return wireframeAttributes.get(geometry);
		}

		return {
			get: get,
			update: update,
			getWireframeAttribute: getWireframeAttribute
		};
	}

	function WebGLIndexedBufferRenderer(gl, extensions, info, capabilities) {
		var isWebGL2 = capabilities.isWebGL2;
		var mode;

		function setMode(value) {
			mode = value;
		}

		var type, bytesPerElement;

		function setIndex(value) {
			type = value.type;
			bytesPerElement = value.bytesPerElement;
		}

		function render(start, count) {
			gl.drawElements(mode, count, type, start * bytesPerElement);
			info.update(count, mode, 1);
		}

		function renderInstances(start, count, primcount) {
			if (primcount === 0) return;
			var extension, methodName;

			if (isWebGL2) {
				extension = gl;
				methodName = 'drawElementsInstanced';
			} else {
				extension = extensions.get('ANGLE_instanced_arrays');
				methodName = 'drawElementsInstancedANGLE';

				if (extension === null) {
					console.error('THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');
					return;
				}
			}

			extension[methodName](mode, count, type, start * bytesPerElement, primcount);
			info.update(count, mode, primcount);
		} //


		this.setMode = setMode;
		this.setIndex = setIndex;
		this.render = render;
		this.renderInstances = renderInstances;
	}

	function WebGLInfo(gl) {
		var memory = {
			geometries: 0,
			textures: 0
		};
		var render = {
			frame: 0,
			calls: 0,
			triangles: 0,
			points: 0,
			lines: 0
		};

		function update(count, mode, instanceCount) {
			render.calls++;

			switch (mode) {
				case gl.TRIANGLES:
					render.triangles += instanceCount * (count / 3);
					break;

				case gl.LINES:
					render.lines += instanceCount * (count / 2);
					break;

				case gl.LINE_STRIP:
					render.lines += instanceCount * (count - 1);
					break;

				case gl.LINE_LOOP:
					render.lines += instanceCount * count;
					break;

				case gl.POINTS:
					render.points += instanceCount * count;
					break;

				default:
					console.error('THREE.WebGLInfo: Unknown draw mode:', mode);
					break;
			}
		}

		function reset() {
			render.frame++;
			render.calls = 0;
			render.triangles = 0;
			render.points = 0;
			render.lines = 0;
		}

		return {
			memory: memory,
			render: render,
			programs: null,
			autoReset: true,
			reset: reset,
			update: update
		};
	}

	var DataTexture2DArray = /*#__PURE__*/function (_Texture) {
		_inheritsLoose(DataTexture2DArray, _Texture);

		function DataTexture2DArray(data, width, height, depth) {
			var _this;

			if (data === void 0) {
				data = null;
			}

			if (width === void 0) {
				width = 1;
			}

			if (height === void 0) {
				height = 1;
			}

			if (depth === void 0) {
				depth = 1;
			}

			_this = _Texture.call(this, null) || this;
			_this.image = {
				data: data,
				width: width,
				height: height,
				depth: depth
			};
			_this.magFilter = NearestFilter;
			_this.minFilter = NearestFilter;
			_this.wrapR = ClampToEdgeWrapping;
			_this.generateMipmaps = false;
			_this.flipY = false;
			_this.unpackAlignment = 1;
			_this.needsUpdate = true;
			return _this;
		}

		return DataTexture2DArray;
	}(Texture);

	DataTexture2DArray.prototype.isDataTexture2DArray = true;

	function numericalSort(a, b) {
		return a[0] - b[0];
	}

	function absNumericalSort(a, b) {
		return Math.abs(b[1]) - Math.abs(a[1]);
	}

	function denormalize(morph, attribute) {
		var denominator = 1;
		var array = attribute.isInterleavedBufferAttribute ? attribute.data.array : attribute.array;
		if (array instanceof Int8Array) denominator = 127;else if (array instanceof Int16Array) denominator = 32767;else if (array instanceof Int32Array) denominator = 2147483647;else console.error('THREE.WebGLMorphtargets: Unsupported morph attribute data type: ', array);
		morph.divideScalar(denominator);
	}

	function WebGLMorphtargets(gl, capabilities, textures) {
		var influencesList = {};
		var morphInfluences = new Float32Array(8);
		var morphTextures = new WeakMap();
		var morph = new Vector3();
		var workInfluences = [];

		for (var i = 0; i < 8; i++) {
			workInfluences[i] = [i, 0];
		}

		function update(object, geometry, material, program) {
			var objectInfluences = object.morphTargetInfluences;

			if (capabilities.isWebGL2 === true) {
				// instead of using attributes, the WebGL 2 code path encodes morph targets
				// into an array of data textures. Each layer represents a single morph target.
				var numberOfMorphTargets = geometry.morphAttributes.position.length;
				var entry = morphTextures.get(geometry);

				if (entry === undefined || entry.count !== numberOfMorphTargets) {
					if (entry !== undefined) entry.texture.dispose();
					var hasMorphNormals = geometry.morphAttributes.normal !== undefined;
					var morphTargets = geometry.morphAttributes.position;
					var morphNormals = geometry.morphAttributes.normal || [];
					var numberOfVertices = geometry.attributes.position.count;
					var numberOfVertexData = hasMorphNormals === true ? 2 : 1; // (v,n) vs. (v)

					var width = numberOfVertices * numberOfVertexData;
					var height = 1;

					if (width > capabilities.maxTextureSize) {
						height = Math.ceil(width / capabilities.maxTextureSize);
						width = capabilities.maxTextureSize;
					}

					var buffer = new Float32Array(width * height * 4 * numberOfMorphTargets);
					var texture = new DataTexture2DArray(buffer, width, height, numberOfMorphTargets);
					texture.format = RGBAFormat; // using RGBA since RGB might be emulated (and is thus slower)

					texture.type = FloatType; // fill buffer

					var vertexDataStride = numberOfVertexData * 4;

					for (var _i = 0; _i < numberOfMorphTargets; _i++) {
						var morphTarget = morphTargets[_i];
						var morphNormal = morphNormals[_i];
						var offset = width * height * 4 * _i;

						for (var j = 0; j < morphTarget.count; j++) {
							morph.fromBufferAttribute(morphTarget, j);
							if (morphTarget.normalized === true) denormalize(morph, morphTarget);
							var stride = j * vertexDataStride;
							buffer[offset + stride + 0] = morph.x;
							buffer[offset + stride + 1] = morph.y;
							buffer[offset + stride + 2] = morph.z;
							buffer[offset + stride + 3] = 0;

							if (hasMorphNormals === true) {
								morph.fromBufferAttribute(morphNormal, j);
								if (morphNormal.normalized === true) denormalize(morph, morphNormal);
								buffer[offset + stride + 4] = morph.x;
								buffer[offset + stride + 5] = morph.y;
								buffer[offset + stride + 6] = morph.z;
								buffer[offset + stride + 7] = 0;
							}
						}
					}

					entry = {
						count: numberOfMorphTargets,
						texture: texture,
						size: new Vector2(width, height)
					};
					morphTextures.set(geometry, entry);
				} //


				var morphInfluencesSum = 0;

				for (var _i2 = 0; _i2 < objectInfluences.length; _i2++) {
					morphInfluencesSum += objectInfluences[_i2];
				}

				var morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;
				program.getUniforms().setValue(gl, 'morphTargetBaseInfluence', morphBaseInfluence);
				program.getUniforms().setValue(gl, 'morphTargetInfluences', objectInfluences);
				program.getUniforms().setValue(gl, 'morphTargetsTexture', entry.texture, textures);
				program.getUniforms().setValue(gl, 'morphTargetsTextureSize', entry.size);
			} else {
				// When object doesn't have morph target influences defined, we treat it as a 0-length array
				// This is important to make sure we set up morphTargetBaseInfluence / morphTargetInfluences
				var length = objectInfluences === undefined ? 0 : objectInfluences.length;
				var influences = influencesList[geometry.id];

				if (influences === undefined || influences.length !== length) {
					// initialise list
					influences = [];

					for (var _i3 = 0; _i3 < length; _i3++) {
						influences[_i3] = [_i3, 0];
					}

					influencesList[geometry.id] = influences;
				} // Collect influences


				for (var _i4 = 0; _i4 < length; _i4++) {
					var influence = influences[_i4];
					influence[0] = _i4;
					influence[1] = objectInfluences[_i4];
				}

				influences.sort(absNumericalSort);

				for (var _i5 = 0; _i5 < 8; _i5++) {
					if (_i5 < length && influences[_i5][1]) {
						workInfluences[_i5][0] = influences[_i5][0];
						workInfluences[_i5][1] = influences[_i5][1];
					} else {
						workInfluences[_i5][0] = Number.MAX_SAFE_INTEGER;
						workInfluences[_i5][1] = 0;
					}
				}

				workInfluences.sort(numericalSort);
				var _morphTargets = geometry.morphAttributes.position;
				var _morphNormals = geometry.morphAttributes.normal;
				var _morphInfluencesSum = 0;

				for (var _i6 = 0; _i6 < 8; _i6++) {
					var _influence = workInfluences[_i6];
					var index = _influence[0];
					var value = _influence[1];

					if (index !== Number.MAX_SAFE_INTEGER && value) {
						if (_morphTargets && geometry.getAttribute('morphTarget' + _i6) !== _morphTargets[index]) {
							geometry.setAttribute('morphTarget' + _i6, _morphTargets[index]);
						}

						if (_morphNormals && geometry.getAttribute('morphNormal' + _i6) !== _morphNormals[index]) {
							geometry.setAttribute('morphNormal' + _i6, _morphNormals[index]);
						}

						morphInfluences[_i6] = value;
						_morphInfluencesSum += value;
					} else {
						if (_morphTargets && geometry.hasAttribute('morphTarget' + _i6) === true) {
							geometry.deleteAttribute('morphTarget' + _i6);
						}

						if (_morphNormals && geometry.hasAttribute('morphNormal' + _i6) === true) {
							geometry.deleteAttribute('morphNormal' + _i6);
						}

						morphInfluences[_i6] = 0;
					}
				} // GLSL shader uses formula baseinfluence * base + sum(target * influence)
				// This allows us to switch between absolute morphs and relative morphs without changing shader code
				// When baseinfluence = 1 - sum(influence), the above is equivalent to sum((target - base) * influence)


				var _morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - _morphInfluencesSum;

				program.getUniforms().setValue(gl, 'morphTargetBaseInfluence', _morphBaseInfluence);
				program.getUniforms().setValue(gl, 'morphTargetInfluences', morphInfluences);
			}
		}

		return {
			update: update
		};
	}

	function WebGLObjects(gl, geometries, attributes, info) {
		var updateMap = new WeakMap();

		function update(object) {
			var frame = info.render.frame;
			var geometry = object.geometry;
			var buffergeometry = geometries.get(object, geometry); // Update once per frame

			if (updateMap.get(buffergeometry) !== frame) {
				geometries.update(buffergeometry);
				updateMap.set(buffergeometry, frame);
			}

			if (object.isInstancedMesh) {
				if (object.hasEventListener('dispose', onInstancedMeshDispose) === false) {
					object.addEventListener('dispose', onInstancedMeshDispose);
				}

				attributes.update(object.instanceMatrix, gl.ARRAY_BUFFER);

				if (object.instanceColor !== null) {
					attributes.update(object.instanceColor, gl.ARRAY_BUFFER);
				}
			}

			return buffergeometry;
		}

		function dispose() {
			updateMap = new WeakMap();
		}

		function onInstancedMeshDispose(event) {
			var instancedMesh = event.target;
			instancedMesh.removeEventListener('dispose', onInstancedMeshDispose);
			attributes.remove(instancedMesh.instanceMatrix);
			if (instancedMesh.instanceColor !== null) attributes.remove(instancedMesh.instanceColor);
		}

		return {
			update: update,
			dispose: dispose
		};
	}

	var DataTexture3D = /*#__PURE__*/function (_Texture) {
		_inheritsLoose(DataTexture3D, _Texture);

		function DataTexture3D(data, width, height, depth) {
			var _this;

			if (data === void 0) {
				data = null;
			}

			if (width === void 0) {
				width = 1;
			}

			if (height === void 0) {
				height = 1;
			}

			if (depth === void 0) {
				depth = 1;
			}

			// We're going to add .setXXX() methods for setting properties later.
			// Users can still set in DataTexture3D directly.
			//
			//	const texture = new THREE.DataTexture3D( data, width, height, depth );
			// 	texture.anisotropy = 16;
			//
			// See #14839
			_this = _Texture.call(this, null) || this;
			_this.image = {
				data: data,
				width: width,
				height: height,
				depth: depth
			};
			_this.magFilter = NearestFilter;
			_this.minFilter = NearestFilter;
			_this.wrapR = ClampToEdgeWrapping;
			_this.generateMipmaps = false;
			_this.flipY = false;
			_this.unpackAlignment = 1;
			_this.needsUpdate = true;
			return _this;
		}

		return DataTexture3D;
	}(Texture);

	DataTexture3D.prototype.isDataTexture3D = true;

	/**
	 * Uniforms of a program.
	 * Those form a tree structure with a special top-level container for the root,
	 * which you get by calling 'new WebGLUniforms( gl, program )'.
	 *
	 *
	 * Properties of inner nodes including the top-level container:
	 *
	 * .seq - array of nested uniforms
	 * .map - nested uniforms by name
	 *
	 *
	 * Methods of all nodes except the top-level container:
	 *
	 * .setValue( gl, value, [textures] )
	 *
	 * 		uploads a uniform value(s)
	 *		the 'textures' parameter is needed for sampler uniforms
	 *
	 *
	 * Static methods of the top-level container (textures factorizations):
	 *
	 * .upload( gl, seq, values, textures )
	 *
	 * 		sets uniforms in 'seq' to 'values[id].value'
	 *
	 * .seqWithValue( seq, values ) : filteredSeq
	 *
	 * 		filters 'seq' entries with corresponding entry in values
	 *
	 *
	 * Methods of the top-level container (textures factorizations):
	 *
	 * .setValue( gl, name, value, textures )
	 *
	 * 		sets uniform with	name 'name' to 'value'
	 *
	 * .setOptional( gl, obj, prop )
	 *
	 * 		like .set for an optional property of the object
	 *
	 */
	var emptyTexture = new Texture();
	var emptyTexture2dArray = new DataTexture2DArray();
	var emptyTexture3d = new DataTexture3D();
	var emptyCubeTexture = new CubeTexture(); // --- Utilities ---
	// Array Caches (provide typed arrays for temporary by size)

	var arrayCacheF32 = [];
	var arrayCacheI32 = []; // Float32Array caches used for uploading Matrix uniforms

	var mat4array = new Float32Array(16);
	var mat3array = new Float32Array(9);
	var mat2array = new Float32Array(4); // Flattening for arrays of vectors and matrices

	function flatten(array, nBlocks, blockSize) {
		var firstElem = array[0];
		if (firstElem <= 0 || firstElem > 0) return array; // unoptimized: ! isNaN( firstElem )
		// see http://jacksondunstan.com/articles/983

		var n = nBlocks * blockSize;
		var r = arrayCacheF32[n];

		if (r === undefined) {
			r = new Float32Array(n);
			arrayCacheF32[n] = r;
		}

		if (nBlocks !== 0) {
			firstElem.toArray(r, 0);

			for (var i = 1, offset = 0; i !== nBlocks; ++i) {
				offset += blockSize;
				array[i].toArray(r, offset);
			}
		}

		return r;
	}

	function arraysEqual(a, b) {
		if (a.length !== b.length) return false;

		for (var i = 0, l = a.length; i < l; i++) {
			if (a[i] !== b[i]) return false;
		}

		return true;
	}

	function copyArray(a, b) {
		for (var i = 0, l = b.length; i < l; i++) {
			a[i] = b[i];
		}
	} // Texture unit allocation


	function allocTexUnits(textures, n) {
		var r = arrayCacheI32[n];

		if (r === undefined) {
			r = new Int32Array(n);
			arrayCacheI32[n] = r;
		}

		for (var i = 0; i !== n; ++i) {
			r[i] = textures.allocateTextureUnit();
		}

		return r;
	} // --- Setters ---
	// Note: Defining these methods externally, because they come in a bunch
	// and this way their names minify.
	// Single scalar


	function setValueV1f(gl, v) {
		var cache = this.cache;
		if (cache[0] === v) return;
		gl.uniform1f(this.addr, v);
		cache[0] = v;
	} // Single float vector (from flat array or THREE.VectorN)


	function setValueV2f(gl, v) {
		var cache = this.cache;

		if (v.x !== undefined) {
			if (cache[0] !== v.x || cache[1] !== v.y) {
				gl.uniform2f(this.addr, v.x, v.y);
				cache[0] = v.x;
				cache[1] = v.y;
			}
		} else {
			if (arraysEqual(cache, v)) return;
			gl.uniform2fv(this.addr, v);
			copyArray(cache, v);
		}
	}

	function setValueV3f(gl, v) {
		var cache = this.cache;

		if (v.x !== undefined) {
			if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z) {
				gl.uniform3f(this.addr, v.x, v.y, v.z);
				cache[0] = v.x;
				cache[1] = v.y;
				cache[2] = v.z;
			}
		} else if (v.r !== undefined) {
			if (cache[0] !== v.r || cache[1] !== v.g || cache[2] !== v.b) {
				gl.uniform3f(this.addr, v.r, v.g, v.b);
				cache[0] = v.r;
				cache[1] = v.g;
				cache[2] = v.b;
			}
		} else {
			if (arraysEqual(cache, v)) return;
			gl.uniform3fv(this.addr, v);
			copyArray(cache, v);
		}
	}

	function setValueV4f(gl, v) {
		var cache = this.cache;

		if (v.x !== undefined) {
			if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z || cache[3] !== v.w) {
				gl.uniform4f(this.addr, v.x, v.y, v.z, v.w);
				cache[0] = v.x;
				cache[1] = v.y;
				cache[2] = v.z;
				cache[3] = v.w;
			}
		} else {
			if (arraysEqual(cache, v)) return;
			gl.uniform4fv(this.addr, v);
			copyArray(cache, v);
		}
	} // Single matrix (from flat array or THREE.MatrixN)


	function setValueM2(gl, v) {
		var cache = this.cache;
		var elements = v.elements;

		if (elements === undefined) {
			if (arraysEqual(cache, v)) return;
			gl.uniformMatrix2fv(this.addr, false, v);
			copyArray(cache, v);
		} else {
			if (arraysEqual(cache, elements)) return;
			mat2array.set(elements);
			gl.uniformMatrix2fv(this.addr, false, mat2array);
			copyArray(cache, elements);
		}
	}

	function setValueM3(gl, v) {
		var cache = this.cache;
		var elements = v.elements;

		if (elements === undefined) {
			if (arraysEqual(cache, v)) return;
			gl.uniformMatrix3fv(this.addr, false, v);
			copyArray(cache, v);
		} else {
			if (arraysEqual(cache, elements)) return;
			mat3array.set(elements);
			gl.uniformMatrix3fv(this.addr, false, mat3array);
			copyArray(cache, elements);
		}
	}

	function setValueM4(gl, v) {
		var cache = this.cache;
		var elements = v.elements;

		if (elements === undefined) {
			if (arraysEqual(cache, v)) return;
			gl.uniformMatrix4fv(this.addr, false, v);
			copyArray(cache, v);
		} else {
			if (arraysEqual(cache, elements)) return;
			mat4array.set(elements);
			gl.uniformMatrix4fv(this.addr, false, mat4array);
			copyArray(cache, elements);
		}
	} // Single integer / boolean


	function setValueV1i(gl, v) {
		var cache = this.cache;
		if (cache[0] === v) return;
		gl.uniform1i(this.addr, v);
		cache[0] = v;
	} // Single integer / boolean vector (from flat array)


	function setValueV2i(gl, v) {
		var cache = this.cache;
		if (arraysEqual(cache, v)) return;
		gl.uniform2iv(this.addr, v);
		copyArray(cache, v);
	}

	function setValueV3i(gl, v) {
		var cache = this.cache;
		if (arraysEqual(cache, v)) return;
		gl.uniform3iv(this.addr, v);
		copyArray(cache, v);
	}

	function setValueV4i(gl, v) {
		var cache = this.cache;
		if (arraysEqual(cache, v)) return;
		gl.uniform4iv(this.addr, v);
		copyArray(cache, v);
	} // Single unsigned integer


	function setValueV1ui(gl, v) {
		var cache = this.cache;
		if (cache[0] === v) return;
		gl.uniform1ui(this.addr, v);
		cache[0] = v;
	} // Single unsigned integer vector (from flat array)


	function setValueV2ui(gl, v) {
		var cache = this.cache;
		if (arraysEqual(cache, v)) return;
		gl.uniform2uiv(this.addr, v);
		copyArray(cache, v);
	}

	function setValueV3ui(gl, v) {
		var cache = this.cache;
		if (arraysEqual(cache, v)) return;
		gl.uniform3uiv(this.addr, v);
		copyArray(cache, v);
	}

	function setValueV4ui(gl, v) {
		var cache = this.cache;
		if (arraysEqual(cache, v)) return;
		gl.uniform4uiv(this.addr, v);
		copyArray(cache, v);
	} // Single texture (2D / Cube)


	function setValueT1(gl, v, textures) {
		var cache = this.cache;
		var unit = textures.allocateTextureUnit();

		if (cache[0] !== unit) {
			gl.uniform1i(this.addr, unit);
			cache[0] = unit;
		}

		textures.safeSetTexture2D(v || emptyTexture, unit);
	}

	function setValueT3D1(gl, v, textures) {
		var cache = this.cache;
		var unit = textures.allocateTextureUnit();

		if (cache[0] !== unit) {
			gl.uniform1i(this.addr, unit);
			cache[0] = unit;
		}

		textures.setTexture3D(v || emptyTexture3d, unit);
	}

	function setValueT6(gl, v, textures) {
		var cache = this.cache;
		var unit = textures.allocateTextureUnit();

		if (cache[0] !== unit) {
			gl.uniform1i(this.addr, unit);
			cache[0] = unit;
		}

		textures.safeSetTextureCube(v || emptyCubeTexture, unit);
	}

	function setValueT2DArray1(gl, v, textures) {
		var cache = this.cache;
		var unit = textures.allocateTextureUnit();

		if (cache[0] !== unit) {
			gl.uniform1i(this.addr, unit);
			cache[0] = unit;
		}

		textures.setTexture2DArray(v || emptyTexture2dArray, unit);
	} // Helper to pick the right setter for the singular case


	function getSingularSetter(type) {
		switch (type) {
			case 0x1406:
				return setValueV1f;
			// FLOAT

			case 0x8b50:
				return setValueV2f;
			// _VEC2

			case 0x8b51:
				return setValueV3f;
			// _VEC3

			case 0x8b52:
				return setValueV4f;
			// _VEC4

			case 0x8b5a:
				return setValueM2;
			// _MAT2

			case 0x8b5b:
				return setValueM3;
			// _MAT3

			case 0x8b5c:
				return setValueM4;
			// _MAT4

			case 0x1404:
			case 0x8b56:
				return setValueV1i;
			// INT, BOOL

			case 0x8b53:
			case 0x8b57:
				return setValueV2i;
			// _VEC2

			case 0x8b54:
			case 0x8b58:
				return setValueV3i;
			// _VEC3

			case 0x8b55:
			case 0x8b59:
				return setValueV4i;
			// _VEC4

			case 0x1405:
				return setValueV1ui;
			// UINT

			case 0x8dc6:
				return setValueV2ui;
			// _VEC2

			case 0x8dc7:
				return setValueV3ui;
			// _VEC3

			case 0x8dc8:
				return setValueV4ui;
			// _VEC4

			case 0x8b5e: // SAMPLER_2D

			case 0x8d66: // SAMPLER_EXTERNAL_OES

			case 0x8dca: // INT_SAMPLER_2D

			case 0x8dd2: // UNSIGNED_INT_SAMPLER_2D

			case 0x8b62:
				// SAMPLER_2D_SHADOW
				return setValueT1;

			case 0x8b5f: // SAMPLER_3D

			case 0x8dcb: // INT_SAMPLER_3D

			case 0x8dd3:
				// UNSIGNED_INT_SAMPLER_3D
				return setValueT3D1;

			case 0x8b60: // SAMPLER_CUBE

			case 0x8dcc: // INT_SAMPLER_CUBE

			case 0x8dd4: // UNSIGNED_INT_SAMPLER_CUBE

			case 0x8dc5:
				// SAMPLER_CUBE_SHADOW
				return setValueT6;

			case 0x8dc1: // SAMPLER_2D_ARRAY

			case 0x8dcf: // INT_SAMPLER_2D_ARRAY

			case 0x8dd7: // UNSIGNED_INT_SAMPLER_2D_ARRAY

			case 0x8dc4:
				// SAMPLER_2D_ARRAY_SHADOW
				return setValueT2DArray1;
		}
	} // Array of scalars


	function setValueV1fArray(gl, v) {
		gl.uniform1fv(this.addr, v);
	} // Array of vectors (from flat array or array of THREE.VectorN)


	function setValueV2fArray(gl, v) {
		var data = flatten(v, this.size, 2);
		gl.uniform2fv(this.addr, data);
	}

	function setValueV3fArray(gl, v) {
		var data = flatten(v, this.size, 3);
		gl.uniform3fv(this.addr, data);
	}

	function setValueV4fArray(gl, v) {
		var data = flatten(v, this.size, 4);
		gl.uniform4fv(this.addr, data);
	} // Array of matrices (from flat array or array of THREE.MatrixN)


	function setValueM2Array(gl, v) {
		var data = flatten(v, this.size, 4);
		gl.uniformMatrix2fv(this.addr, false, data);
	}

	function setValueM3Array(gl, v) {
		var data = flatten(v, this.size, 9);
		gl.uniformMatrix3fv(this.addr, false, data);
	}

	function setValueM4Array(gl, v) {
		var data = flatten(v, this.size, 16);
		gl.uniformMatrix4fv(this.addr, false, data);
	} // Array of integer / boolean


	function setValueV1iArray(gl, v) {
		gl.uniform1iv(this.addr, v);
	} // Array of integer / boolean vectors (from flat array)


	function setValueV2iArray(gl, v) {
		gl.uniform2iv(this.addr, v);
	}

	function setValueV3iArray(gl, v) {
		gl.uniform3iv(this.addr, v);
	}

	function setValueV4iArray(gl, v) {
		gl.uniform4iv(this.addr, v);
	} // Array of unsigned integer


	function setValueV1uiArray(gl, v) {
		gl.uniform1uiv(this.addr, v);
	} // Array of unsigned integer vectors (from flat array)


	function setValueV2uiArray(gl, v) {
		gl.uniform2uiv(this.addr, v);
	}

	function setValueV3uiArray(gl, v) {
		gl.uniform3uiv(this.addr, v);
	}

	function setValueV4uiArray(gl, v) {
		gl.uniform4uiv(this.addr, v);
	} // Array of textures (2D / Cube)


	function setValueT1Array(gl, v, textures) {
		var n = v.length;
		var units = allocTexUnits(textures, n);
		gl.uniform1iv(this.addr, units);

		for (var i = 0; i !== n; ++i) {
			textures.safeSetTexture2D(v[i] || emptyTexture, units[i]);
		}
	}

	function setValueT6Array(gl, v, textures) {
		var n = v.length;
		var units = allocTexUnits(textures, n);
		gl.uniform1iv(this.addr, units);

		for (var i = 0; i !== n; ++i) {
			textures.safeSetTextureCube(v[i] || emptyCubeTexture, units[i]);
		}
	} // Helper to pick the right setter for a pure (bottom-level) array


	function getPureArraySetter(type) {
		switch (type) {
			case 0x1406:
				return setValueV1fArray;
			// FLOAT

			case 0x8b50:
				return setValueV2fArray;
			// _VEC2

			case 0x8b51:
				return setValueV3fArray;
			// _VEC3

			case 0x8b52:
				return setValueV4fArray;
			// _VEC4

			case 0x8b5a:
				return setValueM2Array;
			// _MAT2

			case 0x8b5b:
				return setValueM3Array;
			// _MAT3

			case 0x8b5c:
				return setValueM4Array;
			// _MAT4

			case 0x1404:
			case 0x8b56:
				return setValueV1iArray;
			// INT, BOOL

			case 0x8b53:
			case 0x8b57:
				return setValueV2iArray;
			// _VEC2

			case 0x8b54:
			case 0x8b58:
				return setValueV3iArray;
			// _VEC3

			case 0x8b55:
			case 0x8b59:
				return setValueV4iArray;
			// _VEC4

			case 0x1405:
				return setValueV1uiArray;
			// UINT

			case 0x8dc6:
				return setValueV2uiArray;
			// _VEC2

			case 0x8dc7:
				return setValueV3uiArray;
			// _VEC3

			case 0x8dc8:
				return setValueV4uiArray;
			// _VEC4

			case 0x8b5e: // SAMPLER_2D

			case 0x8d66: // SAMPLER_EXTERNAL_OES

			case 0x8dca: // INT_SAMPLER_2D

			case 0x8dd2: // UNSIGNED_INT_SAMPLER_2D

			case 0x8b62:
				// SAMPLER_2D_SHADOW
				return setValueT1Array;

			case 0x8b60: // SAMPLER_CUBE

			case 0x8dcc: // INT_SAMPLER_CUBE

			case 0x8dd4: // UNSIGNED_INT_SAMPLER_CUBE

			case 0x8dc5:
				// SAMPLER_CUBE_SHADOW
				return setValueT6Array;
		}
	} // --- Uniform Classes ---


	function SingleUniform(id, activeInfo, addr) {
		this.id = id;
		this.addr = addr;
		this.cache = [];
		this.setValue = getSingularSetter(activeInfo.type); // this.path = activeInfo.name; // DEBUG
	}

	function PureArrayUniform(id, activeInfo, addr) {
		this.id = id;
		this.addr = addr;
		this.cache = [];
		this.size = activeInfo.size;
		this.setValue = getPureArraySetter(activeInfo.type); // this.path = activeInfo.name; // DEBUG
	}

	PureArrayUniform.prototype.updateCache = function (data) {
		var cache = this.cache;

		if (data instanceof Float32Array && cache.length !== data.length) {
			this.cache = new Float32Array(data.length);
		}

		copyArray(cache, data);
	};

	function StructuredUniform(id) {
		this.id = id;
		this.seq = [];
		this.map = {};
	}

	StructuredUniform.prototype.setValue = function (gl, value, textures) {
		var seq = this.seq;

		for (var i = 0, n = seq.length; i !== n; ++i) {
			var u = seq[i];
			u.setValue(gl, value[u.id], textures);
		}
	}; // --- Top-level ---
	// Parser - builds up the property tree from the path strings


	var RePathPart = /(\w+)(\])?(\[|\.)?/g; // extracts
	// 	- the identifier (member name or array index)
	//	- followed by an optional right bracket (found when array index)
	//	- followed by an optional left bracket or dot (type of subscript)
	//
	// Note: These portions can be read in a non-overlapping fashion and
	// allow straightforward parsing of the hierarchy that WebGL encodes
	// in the uniform names.

	function addUniform(container, uniformObject) {
		container.seq.push(uniformObject);
		container.map[uniformObject.id] = uniformObject;
	}

	function parseUniform(activeInfo, addr, container) {
		var path = activeInfo.name,
				pathLength = path.length; // reset RegExp object, because of the early exit of a previous run

		RePathPart.lastIndex = 0;

		while (true) {
			var match = RePathPart.exec(path),
					matchEnd = RePathPart.lastIndex;
			var id = match[1];
			var idIsIndex = match[2] === ']',
					subscript = match[3];
			if (idIsIndex) id = id | 0; // convert to integer

			if (subscript === undefined || subscript === '[' && matchEnd + 2 === pathLength) {
				// bare name or "pure" bottom-level array "[0]" suffix
				addUniform(container, subscript === undefined ? new SingleUniform(id, activeInfo, addr) : new PureArrayUniform(id, activeInfo, addr));
				break;
			} else {
				// step into inner node / create it in case it doesn't exist
				var map = container.map;
				var next = map[id];

				if (next === undefined) {
					next = new StructuredUniform(id);
					addUniform(container, next);
				}

				container = next;
			}
		}
	} // Root Container


	function WebGLUniforms(gl, program) {
		this.seq = [];
		this.map = {};
		var n = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);

		for (var i = 0; i < n; ++i) {
			var info = gl.getActiveUniform(program, i),
					addr = gl.getUniformLocation(program, info.name);
			parseUniform(info, addr, this);
		}
	}

	WebGLUniforms.prototype.setValue = function (gl, name, value, textures) {
		var u = this.map[name];
		if (u !== undefined) u.setValue(gl, value, textures);
	};

	WebGLUniforms.prototype.setOptional = function (gl, object, name) {
		var v = object[name];
		if (v !== undefined) this.setValue(gl, name, v);
	}; // Static interface


	WebGLUniforms.upload = function (gl, seq, values, textures) {
		for (var i = 0, n = seq.length; i !== n; ++i) {
			var u = seq[i],
					v = values[u.id];

			if (v.needsUpdate !== false) {
				// note: always updating when .needsUpdate is undefined
				u.setValue(gl, v.value, textures);
			}
		}
	};

	WebGLUniforms.seqWithValue = function (seq, values) {
		var r = [];

		for (var i = 0, n = seq.length; i !== n; ++i) {
			var u = seq[i];
			if (u.id in values) r.push(u);
		}

		return r;
	};

	function WebGLShader(gl, type, string) {
		var shader = gl.createShader(type);
		gl.shaderSource(shader, string);
		gl.compileShader(shader);
		return shader;
	}

	var programIdCount = 0;

	function addLineNumbers(string) {
		var lines = string.split('\n');

		for (var i = 0; i < lines.length; i++) {
			lines[i] = i + 1 + ': ' + lines[i];
		}

		return lines.join('\n');
	}

	function getEncodingComponents(encoding) {
		switch (encoding) {
			case LinearEncoding:
				return ['Linear', '( value )'];

			case sRGBEncoding:
				return ['sRGB', '( value )'];

			case RGBEEncoding:
				return ['RGBE', '( value )'];

			case RGBM7Encoding:
				return ['RGBM', '( value, 7.0 )'];

			case RGBM16Encoding:
				return ['RGBM', '( value, 16.0 )'];

			case RGBDEncoding:
				return ['RGBD', '( value, 256.0 )'];

			case GammaEncoding:
				return ['Gamma', '( value, float( GAMMA_FACTOR ) )'];

			case LogLuvEncoding:
				return ['LogLuv', '( value )'];

			default:
				console.warn('THREE.WebGLProgram: Unsupported encoding:', encoding);
				return ['Linear', '( value )'];
		}
	}

	function getShaderErrors(gl, shader, type) {
		var status = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
		var errors = gl.getShaderInfoLog(shader).trim();
		if (status && errors === '') return ''; // --enable-privileged-webgl-extension
		// console.log( '**' + type + '**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );

		return type.toUpperCase() + '\n\n' + errors + '\n\n' + addLineNumbers(gl.getShaderSource(shader));
	}

	function getTexelDecodingFunction(functionName, encoding) {
		var components = getEncodingComponents(encoding);
		return 'vec4 ' + functionName + '( vec4 value ) { return ' + components[0] + 'ToLinear' + components[1] + '; }';
	}

	function getTexelEncodingFunction(functionName, encoding) {
		var components = getEncodingComponents(encoding);
		return 'vec4 ' + functionName + '( vec4 value ) { return LinearTo' + components[0] + components[1] + '; }';
	}

	function getToneMappingFunction(functionName, toneMapping) {
		var toneMappingName;

		switch (toneMapping) {
			case LinearToneMapping:
				toneMappingName = 'Linear';
				break;

			case ReinhardToneMapping:
				toneMappingName = 'Reinhard';
				break;

			case CineonToneMapping:
				toneMappingName = 'OptimizedCineon';
				break;

			case ACESFilmicToneMapping:
				toneMappingName = 'ACESFilmic';
				break;

			case CustomToneMapping:
				toneMappingName = 'Custom';
				break;

			default:
				console.warn('THREE.WebGLProgram: Unsupported toneMapping:', toneMapping);
				toneMappingName = 'Linear';
		}

		return 'vec3 ' + functionName + '( vec3 color ) { return ' + toneMappingName + 'ToneMapping( color ); }';
	}

	function generateExtensions(parameters) {
		var chunks = [parameters.extensionDerivatives || parameters.envMapCubeUV || parameters.bumpMap || parameters.tangentSpaceNormalMap || parameters.clearcoatNormalMap || parameters.flatShading || parameters.shaderID === 'physical' ? '#extension GL_OES_standard_derivatives : enable' : '', (parameters.extensionFragDepth || parameters.logarithmicDepthBuffer) && parameters.rendererExtensionFragDepth ? '#extension GL_EXT_frag_depth : enable' : '', parameters.extensionDrawBuffers && parameters.rendererExtensionDrawBuffers ? '#extension GL_EXT_draw_buffers : require' : '', (parameters.extensionShaderTextureLOD || parameters.envMap || parameters.transmission) && parameters.rendererExtensionShaderTextureLod ? '#extension GL_EXT_shader_texture_lod : enable' : ''];
		return chunks.filter(filterEmptyLine).join('\n');
	}

	function generateDefines(defines) {
		var chunks = [];

		for (var name in defines) {
			var value = defines[name];
			if (value === false) continue;
			chunks.push('#define ' + name + ' ' + value);
		}

		return chunks.join('\n');
	}

	function fetchAttributeLocations(gl, program) {
		var attributes = {};
		var n = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);

		for (var i = 0; i < n; i++) {
			var info = gl.getActiveAttrib(program, i);
			var name = info.name;
			var locationSize = 1;
			if (info.type === gl.FLOAT_MAT2) locationSize = 2;
			if (info.type === gl.FLOAT_MAT3) locationSize = 3;
			if (info.type === gl.FLOAT_MAT4) locationSize = 4; // console.log( 'THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:', name, i );

			attributes[name] = {
				type: info.type,
				location: gl.getAttribLocation(program, name),
				locationSize: locationSize
			};
		}

		return attributes;
	}

	function filterEmptyLine(string) {
		return string !== '';
	}

	function replaceLightNums(string, parameters) {
		return string.replace(/NUM_DIR_LIGHTS/g, parameters.numDirLights).replace(/NUM_SPOT_LIGHTS/g, parameters.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, parameters.numPointLights).replace(/NUM_HEMI_LIGHTS/g, parameters.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, parameters.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, parameters.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, parameters.numPointLightShadows);
	}

	function replaceClippingPlaneNums(string, parameters) {
		return string.replace(/NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, parameters.numClippingPlanes - parameters.numClipIntersection);
	} // Resolve Includes


	var includePattern = /^[ \t]*#include +<([\w\d./]+)>/gm;

	function resolveIncludes(string) {
		return string.replace(includePattern, includeReplacer);
	}

	function includeReplacer(match, include) {
		var string = ShaderChunk[include];

		if (string === undefined) {
			throw new Error('Can not resolve #include <' + include + '>');
		}

		return resolveIncludes(string);
	} // Unroll Loops


	var deprecatedUnrollLoopPattern = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;
	var unrollLoopPattern = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;

	function unrollLoops(string) {
		return string.replace(unrollLoopPattern, loopReplacer).replace(deprecatedUnrollLoopPattern, deprecatedLoopReplacer);
	}

	function deprecatedLoopReplacer(match, start, end, snippet) {
		console.warn('WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead.');
		return loopReplacer(match, start, end, snippet);
	}

	function loopReplacer(match, start, end, snippet) {
		var string = '';

		for (var i = parseInt(start); i < parseInt(end); i++) {
			string += snippet.replace(/\[\s*i\s*\]/g, '[ ' + i + ' ]').replace(/UNROLLED_LOOP_INDEX/g, i);
		}

		return string;
	} //


	function generatePrecision(parameters) {
		var precisionstring = 'precision ' + parameters.precision + ' float;\nprecision ' + parameters.precision + ' int;';

		if (parameters.precision === 'highp') {
			precisionstring += '\n#define HIGH_PRECISION';
		} else if (parameters.precision === 'mediump') {
			precisionstring += '\n#define MEDIUM_PRECISION';
		} else if (parameters.precision === 'lowp') {
			precisionstring += '\n#define LOW_PRECISION';
		}

		return precisionstring;
	}

	function generateShadowMapTypeDefine(parameters) {
		var shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';

		if (parameters.shadowMapType === PCFShadowMap) {
			shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';
		} else if (parameters.shadowMapType === PCFSoftShadowMap) {
			shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';
		} else if (parameters.shadowMapType === VSMShadowMap) {
			shadowMapTypeDefine = 'SHADOWMAP_TYPE_VSM';
		}

		return shadowMapTypeDefine;
	}

	function generateEnvMapTypeDefine(parameters) {
		var envMapTypeDefine = 'ENVMAP_TYPE_CUBE';

		if (parameters.envMap) {
			switch (parameters.envMapMode) {
				case CubeReflectionMapping:
				case CubeRefractionMapping:
					envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
					break;

				case CubeUVReflectionMapping:
				case CubeUVRefractionMapping:
					envMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';
					break;
			}
		}

		return envMapTypeDefine;
	}

	function generateEnvMapModeDefine(parameters) {
		var envMapModeDefine = 'ENVMAP_MODE_REFLECTION';

		if (parameters.envMap) {
			switch (parameters.envMapMode) {
				case CubeRefractionMapping:
				case CubeUVRefractionMapping:
					envMapModeDefine = 'ENVMAP_MODE_REFRACTION';
					break;
			}
		}

		return envMapModeDefine;
	}

	function generateEnvMapBlendingDefine(parameters) {
		var envMapBlendingDefine = 'ENVMAP_BLENDING_NONE';

		if (parameters.envMap) {
			switch (parameters.combine) {
				case MultiplyOperation:
					envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
					break;

				case MixOperation:
					envMapBlendingDefine = 'ENVMAP_BLENDING_MIX';
					break;

				case AddOperation:
					envMapBlendingDefine = 'ENVMAP_BLENDING_ADD';
					break;
			}
		}

		return envMapBlendingDefine;
	}

	function WebGLProgram(renderer, cacheKey, parameters, bindingStates) {
		// TODO Send this event to Three.js DevTools
		// console.log( 'WebGLProgram', cacheKey );
		var gl = renderer.getContext();
		var defines = parameters.defines;
		var vertexShader = parameters.vertexShader;
		var fragmentShader = parameters.fragmentShader;
		var shadowMapTypeDefine = generateShadowMapTypeDefine(parameters);
		var envMapTypeDefine = generateEnvMapTypeDefine(parameters);
		var envMapModeDefine = generateEnvMapModeDefine(parameters);
		var envMapBlendingDefine = generateEnvMapBlendingDefine(parameters);
		var gammaFactorDefine = renderer.gammaFactor > 0 ? renderer.gammaFactor : 1.0;
		var customExtensions = parameters.isWebGL2 ? '' : generateExtensions(parameters);
		var customDefines = generateDefines(defines);
		var program = gl.createProgram();
		var prefixVertex, prefixFragment;
		var versionString = parameters.glslVersion ? '#version ' + parameters.glslVersion + '\n' : '';

		if (parameters.isRawShaderMaterial) {
			prefixVertex = [customDefines].filter(filterEmptyLine).join('\n');

			if (prefixVertex.length > 0) {
				prefixVertex += '\n';
			}

			prefixFragment = [customExtensions, customDefines].filter(filterEmptyLine).join('\n');

			if (prefixFragment.length > 0) {
				prefixFragment += '\n';
			}
		} else {
			prefixVertex = [generatePrecision(parameters), '#define SHADER_NAME ' + parameters.shaderName, customDefines, parameters.instancing ? '#define USE_INSTANCING' : '', parameters.instancingColor ? '#define USE_INSTANCING_COLOR' : '', parameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '', '#define GAMMA_FACTOR ' + gammaFactorDefine, '#define MAX_BONES ' + parameters.maxBones, parameters.useFog && parameters.fog ? '#define USE_FOG' : '', parameters.useFog && parameters.fogExp2 ? '#define FOG_EXP2' : '', parameters.map ? '#define USE_MAP' : '', parameters.envMap ? '#define USE_ENVMAP' : '', parameters.envMap ? '#define ' + envMapModeDefine : '', parameters.lightMap ? '#define USE_LIGHTMAP' : '', parameters.aoMap ? '#define USE_AOMAP' : '', parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '', parameters.bumpMap ? '#define USE_BUMPMAP' : '', parameters.normalMap ? '#define USE_NORMALMAP' : '', parameters.normalMap && parameters.objectSpaceNormalMap ? '#define OBJECTSPACE_NORMALMAP' : '', parameters.normalMap && parameters.tangentSpaceNormalMap ? '#define TANGENTSPACE_NORMALMAP' : '', parameters.clearcoatMap ? '#define USE_CLEARCOATMAP' : '', parameters.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '', parameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '', parameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '', parameters.specularMap ? '#define USE_SPECULARMAP' : '', parameters.specularIntensityMap ? '#define USE_SPECULARINTENSITYMAP' : '', parameters.specularTintMap ? '#define USE_SPECULARTINTMAP' : '', parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '', parameters.metalnessMap ? '#define USE_METALNESSMAP' : '', parameters.alphaMap ? '#define USE_ALPHAMAP' : '', parameters.transmission ? '#define USE_TRANSMISSION' : '', parameters.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '', parameters.thicknessMap ? '#define USE_THICKNESSMAP' : '', parameters.vertexTangents ? '#define USE_TANGENT' : '', parameters.vertexColors ? '#define USE_COLOR' : '', parameters.vertexAlphas ? '#define USE_COLOR_ALPHA' : '', parameters.vertexUvs ? '#define USE_UV' : '', parameters.uvsVertexOnly ? '#define UVS_VERTEX_ONLY' : '', parameters.flatShading ? '#define FLAT_SHADED' : '', parameters.skinning ? '#define USE_SKINNING' : '', parameters.useVertexTexture ? '#define BONE_TEXTURE' : '', parameters.morphTargets ? '#define USE_MORPHTARGETS' : '', parameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '', parameters.morphTargets && parameters.isWebGL2 ? '#define MORPHTARGETS_TEXTURE' : '', parameters.morphTargets && parameters.isWebGL2 ? '#define MORPHTARGETS_COUNT ' + parameters.morphTargetsCount : '', parameters.doubleSided ? '#define DOUBLE_SIDED' : '', parameters.flipSided ? '#define FLIP_SIDED' : '', parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '', parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '', parameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '', parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '', parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ? '#define USE_LOGDEPTHBUF_EXT' : '', 'uniform mat4 modelMatrix;', 'uniform mat4 modelViewMatrix;', 'uniform mat4 projectionMatrix;', 'uniform mat4 viewMatrix;', 'uniform mat3 normalMatrix;', 'uniform vec3 cameraPosition;', 'uniform bool isOrthographic;', '#ifdef USE_INSTANCING', '	attribute mat4 instanceMatrix;', '#endif', '#ifdef USE_INSTANCING_COLOR', '	attribute vec3 instanceColor;', '#endif', 'attribute vec3 position;', 'attribute vec3 normal;', 'attribute vec2 uv;', '#ifdef USE_TANGENT', '	attribute vec4 tangent;', '#endif', '#if defined( USE_COLOR_ALPHA )', '	attribute vec4 color;', '#elif defined( USE_COLOR )', '	attribute vec3 color;', '#endif', '#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )', '	attribute vec3 morphTarget0;', '	attribute vec3 morphTarget1;', '	attribute vec3 morphTarget2;', '	attribute vec3 morphTarget3;', '	#ifdef USE_MORPHNORMALS', '		attribute vec3 morphNormal0;', '		attribute vec3 morphNormal1;', '		attribute vec3 morphNormal2;', '		attribute vec3 morphNormal3;', '	#else', '		attribute vec3 morphTarget4;', '		attribute vec3 morphTarget5;', '		attribute vec3 morphTarget6;', '		attribute vec3 morphTarget7;', '	#endif', '#endif', '#ifdef USE_SKINNING', '	attribute vec4 skinIndex;', '	attribute vec4 skinWeight;', '#endif', '\n'].filter(filterEmptyLine).join('\n');
			prefixFragment = [customExtensions, generatePrecision(parameters), '#define SHADER_NAME ' + parameters.shaderName, customDefines, '#define GAMMA_FACTOR ' + gammaFactorDefine, parameters.useFog && parameters.fog ? '#define USE_FOG' : '', parameters.useFog && parameters.fogExp2 ? '#define FOG_EXP2' : '', parameters.map ? '#define USE_MAP' : '', parameters.matcap ? '#define USE_MATCAP' : '', parameters.envMap ? '#define USE_ENVMAP' : '', parameters.envMap ? '#define ' + envMapTypeDefine : '', parameters.envMap ? '#define ' + envMapModeDefine : '', parameters.envMap ? '#define ' + envMapBlendingDefine : '', parameters.lightMap ? '#define USE_LIGHTMAP' : '', parameters.aoMap ? '#define USE_AOMAP' : '', parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '', parameters.bumpMap ? '#define USE_BUMPMAP' : '', parameters.normalMap ? '#define USE_NORMALMAP' : '', parameters.normalMap && parameters.objectSpaceNormalMap ? '#define OBJECTSPACE_NORMALMAP' : '', parameters.normalMap && parameters.tangentSpaceNormalMap ? '#define TANGENTSPACE_NORMALMAP' : '', parameters.clearcoat ? '#define USE_CLEARCOAT' : '', parameters.clearcoatMap ? '#define USE_CLEARCOATMAP' : '', parameters.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '', parameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '', parameters.specularMap ? '#define USE_SPECULARMAP' : '', parameters.specularIntensityMap ? '#define USE_SPECULARINTENSITYMAP' : '', parameters.specularTintMap ? '#define USE_SPECULARTINTMAP' : '', parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '', parameters.metalnessMap ? '#define USE_METALNESSMAP' : '', parameters.alphaMap ? '#define USE_ALPHAMAP' : '', parameters.alphaTest ? '#define USE_ALPHATEST' : '', parameters.sheen ? '#define USE_SHEEN' : '', parameters.transmission ? '#define USE_TRANSMISSION' : '', parameters.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '', parameters.thicknessMap ? '#define USE_THICKNESSMAP' : '', parameters.vertexTangents ? '#define USE_TANGENT' : '', parameters.vertexColors || parameters.instancingColor ? '#define USE_COLOR' : '', parameters.vertexAlphas ? '#define USE_COLOR_ALPHA' : '', parameters.vertexUvs ? '#define USE_UV' : '', parameters.uvsVertexOnly ? '#define UVS_VERTEX_ONLY' : '', parameters.gradientMap ? '#define USE_GRADIENTMAP' : '', parameters.flatShading ? '#define FLAT_SHADED' : '', parameters.doubleSided ? '#define DOUBLE_SIDED' : '', parameters.flipSided ? '#define FLIP_SIDED' : '', parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '', parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '', parameters.premultipliedAlpha ? '#define PREMULTIPLIED_ALPHA' : '', parameters.physicallyCorrectLights ? '#define PHYSICALLY_CORRECT_LIGHTS' : '', parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '', parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ? '#define USE_LOGDEPTHBUF_EXT' : '', (parameters.extensionShaderTextureLOD || parameters.envMap) && parameters.rendererExtensionShaderTextureLod ? '#define TEXTURE_LOD_EXT' : '', 'uniform mat4 viewMatrix;', 'uniform vec3 cameraPosition;', 'uniform bool isOrthographic;', parameters.toneMapping !== NoToneMapping ? '#define TONE_MAPPING' : '', parameters.toneMapping !== NoToneMapping ? ShaderChunk['tonemapping_pars_fragment'] : '', // this code is required here because it is used by the toneMapping() function defined below
			parameters.toneMapping !== NoToneMapping ? getToneMappingFunction('toneMapping', parameters.toneMapping) : '', parameters.dithering ? '#define DITHERING' : '', parameters.format === RGBFormat ? '#define OPAQUE' : '', ShaderChunk['encodings_pars_fragment'], // this code is required here because it is used by the various encoding/decoding function defined below
			parameters.map ? getTexelDecodingFunction('mapTexelToLinear', parameters.mapEncoding) : '', parameters.matcap ? getTexelDecodingFunction('matcapTexelToLinear', parameters.matcapEncoding) : '', parameters.envMap ? getTexelDecodingFunction('envMapTexelToLinear', parameters.envMapEncoding) : '', parameters.emissiveMap ? getTexelDecodingFunction('emissiveMapTexelToLinear', parameters.emissiveMapEncoding) : '', parameters.specularTintMap ? getTexelDecodingFunction('specularTintMapTexelToLinear', parameters.specularTintMapEncoding) : '', parameters.lightMap ? getTexelDecodingFunction('lightMapTexelToLinear', parameters.lightMapEncoding) : '', getTexelEncodingFunction('linearToOutputTexel', parameters.outputEncoding), parameters.depthPacking ? '#define DEPTH_PACKING ' + parameters.depthPacking : '', '\n'].filter(filterEmptyLine).join('\n');
		}

		vertexShader = resolveIncludes(vertexShader);
		vertexShader = replaceLightNums(vertexShader, parameters);
		vertexShader = replaceClippingPlaneNums(vertexShader, parameters);
		fragmentShader = resolveIncludes(fragmentShader);
		fragmentShader = replaceLightNums(fragmentShader, parameters);
		fragmentShader = replaceClippingPlaneNums(fragmentShader, parameters);
		vertexShader = unrollLoops(vertexShader);
		fragmentShader = unrollLoops(fragmentShader);

		if (parameters.isWebGL2 && parameters.isRawShaderMaterial !== true) {
			// GLSL 3.0 conversion for built-in materials and ShaderMaterial
			versionString = '#version 300 es\n';
			prefixVertex = ['precision mediump sampler2DArray;', '#define attribute in', '#define varying out', '#define texture2D texture'].join('\n') + '\n' + prefixVertex;
			prefixFragment = ['#define varying in', parameters.glslVersion === GLSL3 ? '' : 'out highp vec4 pc_fragColor;', parameters.glslVersion === GLSL3 ? '' : '#define gl_FragColor pc_fragColor', '#define gl_FragDepthEXT gl_FragDepth', '#define texture2D texture', '#define textureCube texture', '#define texture2DProj textureProj', '#define texture2DLodEXT textureLod', '#define texture2DProjLodEXT textureProjLod', '#define textureCubeLodEXT textureLod', '#define texture2DGradEXT textureGrad', '#define texture2DProjGradEXT textureProjGrad', '#define textureCubeGradEXT textureGrad'].join('\n') + '\n' + prefixFragment;
		}

		var vertexGlsl = versionString + prefixVertex + vertexShader;
		var fragmentGlsl = versionString + prefixFragment + fragmentShader; // console.log( '*VERTEX*', vertexGlsl );
		// console.log( '*FRAGMENT*', fragmentGlsl );

		var glVertexShader = WebGLShader(gl, gl.VERTEX_SHADER, vertexGlsl);
		var glFragmentShader = WebGLShader(gl, gl.FRAGMENT_SHADER, fragmentGlsl);
		gl.attachShader(program, glVertexShader);
		gl.attachShader(program, glFragmentShader); // Force a particular attribute to index 0.

		if (parameters.index0AttributeName !== undefined) {
			gl.bindAttribLocation(program, 0, parameters.index0AttributeName);
		} else if (parameters.morphTargets === true) {
			// programs with morphTargets displace position out of attribute 0
			gl.bindAttribLocation(program, 0, 'position');
		}

		gl.linkProgram(program); // check for link errors

		if (renderer.debug.checkShaderErrors) {
			var programLog = gl.getProgramInfoLog(program).trim();
			var vertexLog = gl.getShaderInfoLog(glVertexShader).trim();
			var fragmentLog = gl.getShaderInfoLog(glFragmentShader).trim();
			var runnable = true;
			var haveDiagnostics = true;

			if (gl.getProgramParameter(program, gl.LINK_STATUS) === false) {
				runnable = false;
				var vertexErrors = getShaderErrors(gl, glVertexShader, 'vertex');
				var fragmentErrors = getShaderErrors(gl, glFragmentShader, 'fragment');
				console.error('THREE.WebGLProgram: Shader Error ' + gl.getError() + ' - ' + 'VALIDATE_STATUS ' + gl.getProgramParameter(program, gl.VALIDATE_STATUS) + '\n\n' + 'Program Info Log: ' + programLog + '\n' + vertexErrors + '\n' + fragmentErrors);
			} else if (programLog !== '') {
				console.warn('THREE.WebGLProgram: Program Info Log:', programLog);
			} else if (vertexLog === '' || fragmentLog === '') {
				haveDiagnostics = false;
			}

			if (haveDiagnostics) {
				this.diagnostics = {
					runnable: runnable,
					programLog: programLog,
					vertexShader: {
						log: vertexLog,
						prefix: prefixVertex
					},
					fragmentShader: {
						log: fragmentLog,
						prefix: prefixFragment
					}
				};
			}
		} // Clean up
		// Crashes in iOS9 and iOS10. #18402
		// gl.detachShader( program, glVertexShader );
		// gl.detachShader( program, glFragmentShader );


		gl.deleteShader(glVertexShader);
		gl.deleteShader(glFragmentShader); // set up caching for uniform locations

		var cachedUniforms;

		this.getUniforms = function () {
			if (cachedUniforms === undefined) {
				cachedUniforms = new WebGLUniforms(gl, program);
			}

			return cachedUniforms;
		}; // set up caching for attribute locations


		var cachedAttributes;

		this.getAttributes = function () {
			if (cachedAttributes === undefined) {
				cachedAttributes = fetchAttributeLocations(gl, program);
			}

			return cachedAttributes;
		}; // free resource


		this.destroy = function () {
			bindingStates.releaseStatesOfProgram(this);
			gl.deleteProgram(program);
			this.program = undefined;
		}; //


		this.name = parameters.shaderName;
		this.id = programIdCount++;
		this.cacheKey = cacheKey;
		this.usedTimes = 1;
		this.program = program;
		this.vertexShader = glVertexShader;
		this.fragmentShader = glFragmentShader;
		return this;
	}

	function WebGLPrograms(renderer, cubemaps, cubeuvmaps, extensions, capabilities, bindingStates, clipping) {
		var programs = [];
		var isWebGL2 = capabilities.isWebGL2;
		var logarithmicDepthBuffer = capabilities.logarithmicDepthBuffer;
		var floatVertexTextures = capabilities.floatVertexTextures;
		var maxVertexUniforms = capabilities.maxVertexUniforms;
		var vertexTextures = capabilities.vertexTextures;
		var precision = capabilities.precision;
		var shaderIDs = {
			MeshDepthMaterial: 'depth',
			MeshDistanceMaterial: 'distanceRGBA',
			MeshNormalMaterial: 'normal',
			MeshBasicMaterial: 'basic',
			MeshLambertMaterial: 'lambert',
			MeshPhongMaterial: 'phong',
			MeshToonMaterial: 'toon',
			MeshStandardMaterial: 'physical',
			MeshPhysicalMaterial: 'physical',
			MeshMatcapMaterial: 'matcap',
			LineBasicMaterial: 'basic',
			LineDashedMaterial: 'dashed',
			PointsMaterial: 'points',
			ShadowMaterial: 'shadow',
			SpriteMaterial: 'sprite'
		};
		var parameterNames = ['precision', 'isWebGL2', 'supportsVertexTextures', 'outputEncoding', 'instancing', 'instancingColor', 'map', 'mapEncoding', 'matcap', 'matcapEncoding', 'envMap', 'envMapMode', 'envMapEncoding', 'envMapCubeUV', 'lightMap', 'lightMapEncoding', 'aoMap', 'emissiveMap', 'emissiveMapEncoding', 'bumpMap', 'normalMap', 'objectSpaceNormalMap', 'tangentSpaceNormalMap', 'clearcoat', 'clearcoatMap', 'clearcoatRoughnessMap', 'clearcoatNormalMap', 'displacementMap', 'specularMap', 'specularIntensityMap', 'specularTintMap', 'specularTintMapEncoding', 'roughnessMap', 'metalnessMap', 'gradientMap', 'alphaMap', 'alphaTest', 'combine', 'vertexColors', 'vertexAlphas', 'vertexTangents', 'vertexUvs', 'uvsVertexOnly', 'fog', 'useFog', 'fogExp2', 'flatShading', 'sizeAttenuation', 'logarithmicDepthBuffer', 'skinning', 'maxBones', 'useVertexTexture', 'morphTargets', 'morphNormals', 'morphTargetsCount', 'premultipliedAlpha', 'numDirLights', 'numPointLights', 'numSpotLights', 'numHemiLights', 'numRectAreaLights', 'numDirLightShadows', 'numPointLightShadows', 'numSpotLightShadows', 'shadowMapEnabled', 'shadowMapType', 'toneMapping', 'physicallyCorrectLights', 'doubleSided', 'flipSided', 'numClippingPlanes', 'numClipIntersection', 'depthPacking', 'dithering', 'format', 'sheen', 'transmission', 'transmissionMap', 'thicknessMap'];

		function getMaxBones(object) {
			var skeleton = object.skeleton;
			var bones = skeleton.bones;

			if (floatVertexTextures) {
				return 1024;
			} else {
				// default for when object is not specified
				// ( for example when prebuilding shader to be used with multiple objects )
				//
				//	- leave some extra space for other uniforms
				//	- limit here is ANGLE's 254 max uniform vectors
				//		(up to 54 should be safe)
				var nVertexUniforms = maxVertexUniforms;
				var nVertexMatrices = Math.floor((nVertexUniforms - 20) / 4);
				var maxBones = Math.min(nVertexMatrices, bones.length);

				if (maxBones < bones.length) {
					console.warn('THREE.WebGLRenderer: Skeleton has ' + bones.length + ' bones. This GPU supports ' + maxBones + '.');
					return 0;
				}

				return maxBones;
			}
		}

		function getTextureEncodingFromMap(map) {
			var encoding;

			if (map && map.isTexture) {
				encoding = map.encoding;
			} else if (map && map.isWebGLRenderTarget) {
				console.warn('THREE.WebGLPrograms.getTextureEncodingFromMap: don\'t use render targets as textures. Use their .texture property instead.');
				encoding = map.texture.encoding;
			} else {
				encoding = LinearEncoding;
			}

			if (isWebGL2 && map && map.isTexture && map.format === RGBAFormat && map.type === UnsignedByteType && map.encoding === sRGBEncoding) {
				encoding = LinearEncoding; // disable inline decode for sRGB textures in WebGL 2
			}

			return encoding;
		}

		function getParameters(material, lights, shadows, scene, object) {
			var fog = scene.fog;
			var environment = material.isMeshStandardMaterial ? scene.environment : null;
			var envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || environment);
			var shaderID = shaderIDs[material.type]; // heuristics to create shader parameters according to lights in the scene
			// (not to blow over maxLights budget)

			var maxBones = object.isSkinnedMesh ? getMaxBones(object) : 0;

			if (material.precision !== null) {
				precision = capabilities.getMaxPrecision(material.precision);

				if (precision !== material.precision) {
					console.warn('THREE.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.');
				}
			}

			var vertexShader, fragmentShader;

			if (shaderID) {
				var shader = ShaderLib[shaderID];
				vertexShader = shader.vertexShader;
				fragmentShader = shader.fragmentShader;
			} else {
				vertexShader = material.vertexShader;
				fragmentShader = material.fragmentShader;
			}

			var currentRenderTarget = renderer.getRenderTarget();
			var useAlphaTest = material.alphaTest > 0;
			var useClearcoat = material.clearcoat > 0;
			var parameters = {
				isWebGL2: isWebGL2,
				shaderID: shaderID,
				shaderName: material.type,
				vertexShader: vertexShader,
				fragmentShader: fragmentShader,
				defines: material.defines,
				isRawShaderMaterial: material.isRawShaderMaterial === true,
				glslVersion: material.glslVersion,
				precision: precision,
				instancing: object.isInstancedMesh === true,
				instancingColor: object.isInstancedMesh === true && object.instanceColor !== null,
				supportsVertexTextures: vertexTextures,
				outputEncoding: currentRenderTarget !== null ? getTextureEncodingFromMap(currentRenderTarget.texture) : renderer.outputEncoding,
				map: !!material.map,
				mapEncoding: getTextureEncodingFromMap(material.map),
				matcap: !!material.matcap,
				matcapEncoding: getTextureEncodingFromMap(material.matcap),
				envMap: !!envMap,
				envMapMode: envMap && envMap.mapping,
				envMapEncoding: getTextureEncodingFromMap(envMap),
				envMapCubeUV: !!envMap && (envMap.mapping === CubeUVReflectionMapping || envMap.mapping === CubeUVRefractionMapping),
				lightMap: !!material.lightMap,
				lightMapEncoding: getTextureEncodingFromMap(material.lightMap),
				aoMap: !!material.aoMap,
				emissiveMap: !!material.emissiveMap,
				emissiveMapEncoding: getTextureEncodingFromMap(material.emissiveMap),
				bumpMap: !!material.bumpMap,
				normalMap: !!material.normalMap,
				objectSpaceNormalMap: material.normalMapType === ObjectSpaceNormalMap,
				tangentSpaceNormalMap: material.normalMapType === TangentSpaceNormalMap,
				clearcoat: useClearcoat,
				clearcoatMap: useClearcoat && !!material.clearcoatMap,
				clearcoatRoughnessMap: useClearcoat && !!material.clearcoatRoughnessMap,
				clearcoatNormalMap: useClearcoat && !!material.clearcoatNormalMap,
				displacementMap: !!material.displacementMap,
				roughnessMap: !!material.roughnessMap,
				metalnessMap: !!material.metalnessMap,
				specularMap: !!material.specularMap,
				specularIntensityMap: !!material.specularIntensityMap,
				specularTintMap: !!material.specularTintMap,
				specularTintMapEncoding: getTextureEncodingFromMap(material.specularTintMap),
				alphaMap: !!material.alphaMap,
				alphaTest: useAlphaTest,
				gradientMap: !!material.gradientMap,
				sheen: material.sheen > 0,
				transmission: material.transmission > 0,
				transmissionMap: !!material.transmissionMap,
				thicknessMap: !!material.thicknessMap,
				combine: material.combine,
				vertexTangents: !!material.normalMap && !!object.geometry && !!object.geometry.attributes.tangent,
				vertexColors: material.vertexColors,
				vertexAlphas: material.vertexColors === true && !!object.geometry && !!object.geometry.attributes.color && object.geometry.attributes.color.itemSize === 4,
				vertexUvs: !!material.map || !!material.bumpMap || !!material.normalMap || !!material.specularMap || !!material.alphaMap || !!material.emissiveMap || !!material.roughnessMap || !!material.metalnessMap || !!material.clearcoatMap || !!material.clearcoatRoughnessMap || !!material.clearcoatNormalMap || !!material.displacementMap || !!material.transmissionMap || !!material.thicknessMap || !!material.specularIntensityMap || !!material.specularTintMap,
				uvsVertexOnly: !(!!material.map || !!material.bumpMap || !!material.normalMap || !!material.specularMap || !!material.alphaMap || !!material.emissiveMap || !!material.roughnessMap || !!material.metalnessMap || !!material.clearcoatNormalMap || material.transmission > 0 || !!material.transmissionMap || !!material.thicknessMap || !!material.specularIntensityMap || !!material.specularTintMap) && !!material.displacementMap,
				fog: !!fog,
				useFog: material.fog,
				fogExp2: fog && fog.isFogExp2,
				flatShading: !!material.flatShading,
				sizeAttenuation: material.sizeAttenuation,
				logarithmicDepthBuffer: logarithmicDepthBuffer,
				skinning: object.isSkinnedMesh === true && maxBones > 0,
				maxBones: maxBones,
				useVertexTexture: floatVertexTextures,
				morphTargets: !!object.geometry && !!object.geometry.morphAttributes.position,
				morphNormals: !!object.geometry && !!object.geometry.morphAttributes.normal,
				morphTargetsCount: !!object.geometry && !!object.geometry.morphAttributes.position ? object.geometry.morphAttributes.position.length : 0,
				numDirLights: lights.directional.length,
				numPointLights: lights.point.length,
				numSpotLights: lights.spot.length,
				numRectAreaLights: lights.rectArea.length,
				numHemiLights: lights.hemi.length,
				numDirLightShadows: lights.directionalShadowMap.length,
				numPointLightShadows: lights.pointShadowMap.length,
				numSpotLightShadows: lights.spotShadowMap.length,
				numClippingPlanes: clipping.numPlanes,
				numClipIntersection: clipping.numIntersection,
				format: material.format,
				dithering: material.dithering,
				shadowMapEnabled: renderer.shadowMap.enabled && shadows.length > 0,
				shadowMapType: renderer.shadowMap.type,
				toneMapping: material.toneMapped ? renderer.toneMapping : NoToneMapping,
				physicallyCorrectLights: renderer.physicallyCorrectLights,
				premultipliedAlpha: material.premultipliedAlpha,
				doubleSided: material.side === DoubleSide,
				flipSided: material.side === BackSide,
				depthPacking: material.depthPacking !== undefined ? material.depthPacking : false,
				index0AttributeName: material.index0AttributeName,
				extensionDerivatives: material.extensions && material.extensions.derivatives,
				extensionFragDepth: material.extensions && material.extensions.fragDepth,
				extensionDrawBuffers: material.extensions && material.extensions.drawBuffers,
				extensionShaderTextureLOD: material.extensions && material.extensions.shaderTextureLOD,
				rendererExtensionFragDepth: isWebGL2 || extensions.has('EXT_frag_depth'),
				rendererExtensionDrawBuffers: isWebGL2 || extensions.has('WEBGL_draw_buffers'),
				rendererExtensionShaderTextureLod: isWebGL2 || extensions.has('EXT_shader_texture_lod'),
				customProgramCacheKey: material.customProgramCacheKey()
			};
			return parameters;
		}

		function getProgramCacheKey(parameters) {
			var array = [];

			if (parameters.shaderID) {
				array.push(parameters.shaderID);
			} else {
				array.push(parameters.fragmentShader);
				array.push(parameters.vertexShader);
			}

			if (parameters.defines !== undefined) {
				for (var name in parameters.defines) {
					array.push(name);
					array.push(parameters.defines[name]);
				}
			}

			if (parameters.isRawShaderMaterial === false) {
				for (var i = 0; i < parameterNames.length; i++) {
					array.push(parameters[parameterNames[i]]);
				}

				array.push(renderer.outputEncoding);
				array.push(renderer.gammaFactor);
			}

			array.push(parameters.customProgramCacheKey);
			return array.join();
		}

		function getUniforms(material) {
			var shaderID = shaderIDs[material.type];
			var uniforms;

			if (shaderID) {
				var shader = ShaderLib[shaderID];
				uniforms = UniformsUtils.clone(shader.uniforms);
			} else {
				uniforms = material.uniforms;
			}

			return uniforms;
		}

		function acquireProgram(parameters, cacheKey) {
			var program; // Check if code has been already compiled

			for (var p = 0, pl = programs.length; p < pl; p++) {
				var preexistingProgram = programs[p];

				if (preexistingProgram.cacheKey === cacheKey) {
					program = preexistingProgram;
					++program.usedTimes;
					break;
				}
			}

			if (program === undefined) {
				program = new WebGLProgram(renderer, cacheKey, parameters, bindingStates);
				programs.push(program);
			}

			return program;
		}

		function releaseProgram(program) {
			if (--program.usedTimes === 0) {
				// Remove from unordered set
				var i = programs.indexOf(program);
				programs[i] = programs[programs.length - 1];
				programs.pop(); // Free WebGL resources

				program.destroy();
			}
		}

		return {
			getParameters: getParameters,
			getProgramCacheKey: getProgramCacheKey,
			getUniforms: getUniforms,
			acquireProgram: acquireProgram,
			releaseProgram: releaseProgram,
			// Exposed for resource monitoring & error feedback via renderer.info:
			programs: programs
		};
	}

	function WebGLProperties() {
		var properties = new WeakMap();

		function get(object) {
			var map = properties.get(object);

			if (map === undefined) {
				map = {};
				properties.set(object, map);
			}

			return map;
		}

		function remove(object) {
			properties.delete(object);
		}

		function update(object, key, value) {
			properties.get(object)[key] = value;
		}

		function dispose() {
			properties = new WeakMap();
		}

		return {
			get: get,
			remove: remove,
			update: update,
			dispose: dispose
		};
	}

	function painterSortStable(a, b) {
		if (a.groupOrder !== b.groupOrder) {
			return a.groupOrder - b.groupOrder;
		} else if (a.renderOrder !== b.renderOrder) {
			return a.renderOrder - b.renderOrder;
		} else if (a.program !== b.program) {
			return a.program.id - b.program.id;
		} else if (a.material.id !== b.material.id) {
			return a.material.id - b.material.id;
		} else if (a.z !== b.z) {
			return a.z - b.z;
		} else {
			return a.id - b.id;
		}
	}

	function reversePainterSortStable(a, b) {
		if (a.groupOrder !== b.groupOrder) {
			return a.groupOrder - b.groupOrder;
		} else if (a.renderOrder !== b.renderOrder) {
			return a.renderOrder - b.renderOrder;
		} else if (a.z !== b.z) {
			return b.z - a.z;
		} else {
			return a.id - b.id;
		}
	}

	function WebGLRenderList(properties) {
		var renderItems = [];
		var renderItemsIndex = 0;
		var opaque = [];
		var transmissive = [];
		var transparent = [];
		var defaultProgram = {
			id: -1
		};

		function init() {
			renderItemsIndex = 0;
			opaque.length = 0;
			transmissive.length = 0;
			transparent.length = 0;
		}

		function getNextRenderItem(object, geometry, material, groupOrder, z, group) {
			var renderItem = renderItems[renderItemsIndex];
			var materialProperties = properties.get(material);

			if (renderItem === undefined) {
				renderItem = {
					id: object.id,
					object: object,
					geometry: geometry,
					material: material,
					program: materialProperties.program || defaultProgram,
					groupOrder: groupOrder,
					renderOrder: object.renderOrder,
					z: z,
					group: group
				};
				renderItems[renderItemsIndex] = renderItem;
			} else {
				renderItem.id = object.id;
				renderItem.object = object;
				renderItem.geometry = geometry;
				renderItem.material = material;
				renderItem.program = materialProperties.program || defaultProgram;
				renderItem.groupOrder = groupOrder;
				renderItem.renderOrder = object.renderOrder;
				renderItem.z = z;
				renderItem.group = group;
			}

			renderItemsIndex++;
			return renderItem;
		}

		function push(object, geometry, material, groupOrder, z, group) {
			var renderItem = getNextRenderItem(object, geometry, material, groupOrder, z, group);

			if (material.transmission > 0.0) {
				transmissive.push(renderItem);
			} else if (material.transparent === true) {
				transparent.push(renderItem);
			} else {
				opaque.push(renderItem);
			}
		}

		function unshift(object, geometry, material, groupOrder, z, group) {
			var renderItem = getNextRenderItem(object, geometry, material, groupOrder, z, group);

			if (material.transmission > 0.0) {
				transmissive.unshift(renderItem);
			} else if (material.transparent === true) {
				transparent.unshift(renderItem);
			} else {
				opaque.unshift(renderItem);
			}
		}

		function sort(customOpaqueSort, customTransparentSort) {
			if (opaque.length > 1) opaque.sort(customOpaqueSort || painterSortStable);
			if (transmissive.length > 1) transmissive.sort(customTransparentSort || reversePainterSortStable);
			if (transparent.length > 1) transparent.sort(customTransparentSort || reversePainterSortStable);
		}

		function finish() {
			// Clear references from inactive renderItems in the list
			for (var i = renderItemsIndex, il = renderItems.length; i < il; i++) {
				var renderItem = renderItems[i];
				if (renderItem.id === null) break;
				renderItem.id = null;
				renderItem.object = null;
				renderItem.geometry = null;
				renderItem.material = null;
				renderItem.program = null;
				renderItem.group = null;
			}
		}

		return {
			opaque: opaque,
			transmissive: transmissive,
			transparent: transparent,
			init: init,
			push: push,
			unshift: unshift,
			finish: finish,
			sort: sort
		};
	}

	function WebGLRenderLists(properties) {
		var lists = new WeakMap();

		function get(scene, renderCallDepth) {
			var list;

			if (lists.has(scene) === false) {
				list = new WebGLRenderList(properties);
				lists.set(scene, [list]);
			} else {
				if (renderCallDepth >= lists.get(scene).length) {
					list = new WebGLRenderList(properties);
					lists.get(scene).push(list);
				} else {
					list = lists.get(scene)[renderCallDepth];
				}
			}

			return list;
		}

		function dispose() {
			lists = new WeakMap();
		}

		return {
			get: get,
			dispose: dispose
		};
	}

	function UniformsCache() {
		var lights = {};
		return {
			get: function get(light) {
				if (lights[light.id] !== undefined) {
					return lights[light.id];
				}

				var uniforms;

				switch (light.type) {
					case 'DirectionalLight':
						uniforms = {
							direction: new Vector3(),
							color: new Color()
						};
						break;

					case 'SpotLight':
						uniforms = {
							position: new Vector3(),
							direction: new Vector3(),
							color: new Color(),
							distance: 0,
							coneCos: 0,
							penumbraCos: 0,
							decay: 0
						};
						break;

					case 'PointLight':
						uniforms = {
							position: new Vector3(),
							color: new Color(),
							distance: 0,
							decay: 0
						};
						break;

					case 'HemisphereLight':
						uniforms = {
							direction: new Vector3(),
							skyColor: new Color(),
							groundColor: new Color()
						};
						break;

					case 'RectAreaLight':
						uniforms = {
							color: new Color(),
							position: new Vector3(),
							halfWidth: new Vector3(),
							halfHeight: new Vector3()
						};
						break;
				}

				lights[light.id] = uniforms;
				return uniforms;
			}
		};
	}

	function ShadowUniformsCache() {
		var lights = {};
		return {
			get: function get(light) {
				if (lights[light.id] !== undefined) {
					return lights[light.id];
				}

				var uniforms;

				switch (light.type) {
					case 'DirectionalLight':
						uniforms = {
							shadowBias: 0,
							shadowNormalBias: 0,
							shadowRadius: 1,
							shadowMapSize: new Vector2()
						};
						break;

					case 'SpotLight':
						uniforms = {
							shadowBias: 0,
							shadowNormalBias: 0,
							shadowRadius: 1,
							shadowMapSize: new Vector2()
						};
						break;

					case 'PointLight':
						uniforms = {
							shadowBias: 0,
							shadowNormalBias: 0,
							shadowRadius: 1,
							shadowMapSize: new Vector2(),
							shadowCameraNear: 1,
							shadowCameraFar: 1000
						};
						break;
					// TODO (abelnation): set RectAreaLight shadow uniforms
				}

				lights[light.id] = uniforms;
				return uniforms;
			}
		};
	}

	var nextVersion = 0;

	function shadowCastingLightsFirst(lightA, lightB) {
		return (lightB.castShadow ? 1 : 0) - (lightA.castShadow ? 1 : 0);
	}

	function WebGLLights(extensions, capabilities) {
		var cache = new UniformsCache();
		var shadowCache = ShadowUniformsCache();
		var state = {
			version: 0,
			hash: {
				directionalLength: -1,
				pointLength: -1,
				spotLength: -1,
				rectAreaLength: -1,
				hemiLength: -1,
				numDirectionalShadows: -1,
				numPointShadows: -1,
				numSpotShadows: -1
			},
			ambient: [0, 0, 0],
			probe: [],
			directional: [],
			directionalShadow: [],
			directionalShadowMap: [],
			directionalShadowMatrix: [],
			spot: [],
			spotShadow: [],
			spotShadowMap: [],
			spotShadowMatrix: [],
			rectArea: [],
			rectAreaLTC1: null,
			rectAreaLTC2: null,
			point: [],
			pointShadow: [],
			pointShadowMap: [],
			pointShadowMatrix: [],
			hemi: []
		};

		for (var i = 0; i < 9; i++) {
			state.probe.push(new Vector3());
		}

		var vector3 = new Vector3();
		var matrix4 = new Matrix4();
		var matrix42 = new Matrix4();

		function setup(lights, physicallyCorrectLights) {
			var r = 0,
					g = 0,
					b = 0;

			for (var _i = 0; _i < 9; _i++) {
				state.probe[_i].set(0, 0, 0);
			}

			var directionalLength = 0;
			var pointLength = 0;
			var spotLength = 0;
			var rectAreaLength = 0;
			var hemiLength = 0;
			var numDirectionalShadows = 0;
			var numPointShadows = 0;
			var numSpotShadows = 0;
			lights.sort(shadowCastingLightsFirst); // artist-friendly light intensity scaling factor

			var scaleFactor = physicallyCorrectLights !== true ? Math.PI : 1;

			for (var _i2 = 0, l = lights.length; _i2 < l; _i2++) {
				var light = lights[_i2];
				var color = light.color;
				var intensity = light.intensity;
				var distance = light.distance;
				var shadowMap = light.shadow && light.shadow.map ? light.shadow.map.texture : null;

				if (light.isAmbientLight) {
					r += color.r * intensity * scaleFactor;
					g += color.g * intensity * scaleFactor;
					b += color.b * intensity * scaleFactor;
				} else if (light.isLightProbe) {
					for (var j = 0; j < 9; j++) {
						state.probe[j].addScaledVector(light.sh.coefficients[j], intensity);
					}
				} else if (light.isDirectionalLight) {
					var uniforms = cache.get(light);
					uniforms.color.copy(light.color).multiplyScalar(light.intensity * scaleFactor);

					if (light.castShadow) {
						var shadow = light.shadow;
						var shadowUniforms = shadowCache.get(light);
						shadowUniforms.shadowBias = shadow.bias;
						shadowUniforms.shadowNormalBias = shadow.normalBias;
						shadowUniforms.shadowRadius = shadow.radius;
						shadowUniforms.shadowMapSize = shadow.mapSize;
						state.directionalShadow[directionalLength] = shadowUniforms;
						state.directionalShadowMap[directionalLength] = shadowMap;
						state.directionalShadowMatrix[directionalLength] = light.shadow.matrix;
						numDirectionalShadows++;
					}

					state.directional[directionalLength] = uniforms;
					directionalLength++;
				} else if (light.isSpotLight) {
					var _uniforms = cache.get(light);

					_uniforms.position.setFromMatrixPosition(light.matrixWorld);

					_uniforms.color.copy(color).multiplyScalar(intensity * scaleFactor);

					_uniforms.distance = distance;
					_uniforms.coneCos = Math.cos(light.angle);
					_uniforms.penumbraCos = Math.cos(light.angle * (1 - light.penumbra));
					_uniforms.decay = light.decay;

					if (light.castShadow) {
						var _shadow = light.shadow;

						var _shadowUniforms = shadowCache.get(light);

						_shadowUniforms.shadowBias = _shadow.bias;
						_shadowUniforms.shadowNormalBias = _shadow.normalBias;
						_shadowUniforms.shadowRadius = _shadow.radius;
						_shadowUniforms.shadowMapSize = _shadow.mapSize;
						state.spotShadow[spotLength] = _shadowUniforms;
						state.spotShadowMap[spotLength] = shadowMap;
						state.spotShadowMatrix[spotLength] = light.shadow.matrix;
						numSpotShadows++;
					}

					state.spot[spotLength] = _uniforms;
					spotLength++;
				} else if (light.isRectAreaLight) {
					var _uniforms2 = cache.get(light); // (a) intensity is the total visible light emitted
					//uniforms.color.copy( color ).multiplyScalar( intensity / ( light.width * light.height * Math.PI ) );
					// (b) intensity is the brightness of the light


					_uniforms2.color.copy(color).multiplyScalar(intensity);

					_uniforms2.halfWidth.set(light.width * 0.5, 0.0, 0.0);

					_uniforms2.halfHeight.set(0.0, light.height * 0.5, 0.0);

					state.rectArea[rectAreaLength] = _uniforms2;
					rectAreaLength++;
				} else if (light.isPointLight) {
					var _uniforms3 = cache.get(light);

					_uniforms3.color.copy(light.color).multiplyScalar(light.intensity * scaleFactor);

					_uniforms3.distance = light.distance;
					_uniforms3.decay = light.decay;

					if (light.castShadow) {
						var _shadow2 = light.shadow;

						var _shadowUniforms2 = shadowCache.get(light);

						_shadowUniforms2.shadowBias = _shadow2.bias;
						_shadowUniforms2.shadowNormalBias = _shadow2.normalBias;
						_shadowUniforms2.shadowRadius = _shadow2.radius;
						_shadowUniforms2.shadowMapSize = _shadow2.mapSize;
						_shadowUniforms2.shadowCameraNear = _shadow2.camera.near;
						_shadowUniforms2.shadowCameraFar = _shadow2.camera.far;
						state.pointShadow[pointLength] = _shadowUniforms2;
						state.pointShadowMap[pointLength] = shadowMap;
						state.pointShadowMatrix[pointLength] = light.shadow.matrix;
						numPointShadows++;
					}

					state.point[pointLength] = _uniforms3;
					pointLength++;
				} else if (light.isHemisphereLight) {
					var _uniforms4 = cache.get(light);

					_uniforms4.skyColor.copy(light.color).multiplyScalar(intensity * scaleFactor);

					_uniforms4.groundColor.copy(light.groundColor).multiplyScalar(intensity * scaleFactor);

					state.hemi[hemiLength] = _uniforms4;
					hemiLength++;
				}
			}

			if (rectAreaLength > 0) {
				if (capabilities.isWebGL2) {
					// WebGL 2
					state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
					state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;
				} else {
					// WebGL 1
					if (extensions.has('OES_texture_float_linear') === true) {
						state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
						state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;
					} else if (extensions.has('OES_texture_half_float_linear') === true) {
						state.rectAreaLTC1 = UniformsLib.LTC_HALF_1;
						state.rectAreaLTC2 = UniformsLib.LTC_HALF_2;
					} else {
						console.error('THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.');
					}
				}
			}

			state.ambient[0] = r;
			state.ambient[1] = g;
			state.ambient[2] = b;
			var hash = state.hash;

			if (hash.directionalLength !== directionalLength || hash.pointLength !== pointLength || hash.spotLength !== spotLength || hash.rectAreaLength !== rectAreaLength || hash.hemiLength !== hemiLength || hash.numDirectionalShadows !== numDirectionalShadows || hash.numPointShadows !== numPointShadows || hash.numSpotShadows !== numSpotShadows) {
				state.directional.length = directionalLength;
				state.spot.length = spotLength;
				state.rectArea.length = rectAreaLength;
				state.point.length = pointLength;
				state.hemi.length = hemiLength;
				state.directionalShadow.length = numDirectionalShadows;
				state.directionalShadowMap.length = numDirectionalShadows;
				state.pointShadow.length = numPointShadows;
				state.pointShadowMap.length = numPointShadows;
				state.spotShadow.length = numSpotShadows;
				state.spotShadowMap.length = numSpotShadows;
				state.directionalShadowMatrix.length = numDirectionalShadows;
				state.pointShadowMatrix.length = numPointShadows;
				state.spotShadowMatrix.length = numSpotShadows;
				hash.directionalLength = directionalLength;
				hash.pointLength = pointLength;
				hash.spotLength = spotLength;
				hash.rectAreaLength = rectAreaLength;
				hash.hemiLength = hemiLength;
				hash.numDirectionalShadows = numDirectionalShadows;
				hash.numPointShadows = numPointShadows;
				hash.numSpotShadows = numSpotShadows;
				state.version = nextVersion++;
			}
		}

		function setupView(lights, camera) {
			var directionalLength = 0;
			var pointLength = 0;
			var spotLength = 0;
			var rectAreaLength = 0;
			var hemiLength = 0;
			var viewMatrix = camera.matrixWorldInverse;

			for (var _i3 = 0, l = lights.length; _i3 < l; _i3++) {
				var light = lights[_i3];

				if (light.isDirectionalLight) {
					var uniforms = state.directional[directionalLength];
					uniforms.direction.setFromMatrixPosition(light.matrixWorld);
					vector3.setFromMatrixPosition(light.target.matrixWorld);
					uniforms.direction.sub(vector3);
					uniforms.direction.transformDirection(viewMatrix);
					directionalLength++;
				} else if (light.isSpotLight) {
					var _uniforms5 = state.spot[spotLength];

					_uniforms5.position.setFromMatrixPosition(light.matrixWorld);

					_uniforms5.position.applyMatrix4(viewMatrix);

					_uniforms5.direction.setFromMatrixPosition(light.matrixWorld);

					vector3.setFromMatrixPosition(light.target.matrixWorld);

					_uniforms5.direction.sub(vector3);

					_uniforms5.direction.transformDirection(viewMatrix);

					spotLength++;
				} else if (light.isRectAreaLight) {
					var _uniforms6 = state.rectArea[rectAreaLength];

					_uniforms6.position.setFromMatrixPosition(light.matrixWorld);

					_uniforms6.position.applyMatrix4(viewMatrix); // extract local rotation of light to derive width/height half vectors


					matrix42.identity();
					matrix4.copy(light.matrixWorld);
					matrix4.premultiply(viewMatrix);
					matrix42.extractRotation(matrix4);

					_uniforms6.halfWidth.set(light.width * 0.5, 0.0, 0.0);

					_uniforms6.halfHeight.set(0.0, light.height * 0.5, 0.0);

					_uniforms6.halfWidth.applyMatrix4(matrix42);

					_uniforms6.halfHeight.applyMatrix4(matrix42);

					rectAreaLength++;
				} else if (light.isPointLight) {
					var _uniforms7 = state.point[pointLength];

					_uniforms7.position.setFromMatrixPosition(light.matrixWorld);

					_uniforms7.position.applyMatrix4(viewMatrix);

					pointLength++;
				} else if (light.isHemisphereLight) {
					var _uniforms8 = state.hemi[hemiLength];

					_uniforms8.direction.setFromMatrixPosition(light.matrixWorld);

					_uniforms8.direction.transformDirection(viewMatrix);

					_uniforms8.direction.normalize();

					hemiLength++;
				}
			}
		}

		return {
			setup: setup,
			setupView: setupView,
			state: state
		};
	}

	function WebGLRenderState(extensions, capabilities) {
		var lights = new WebGLLights(extensions, capabilities);
		var lightsArray = [];
		var shadowsArray = [];

		function init() {
			lightsArray.length = 0;
			shadowsArray.length = 0;
		}

		function pushLight(light) {
			lightsArray.push(light);
		}

		function pushShadow(shadowLight) {
			shadowsArray.push(shadowLight);
		}

		function setupLights(physicallyCorrectLights) {
			lights.setup(lightsArray, physicallyCorrectLights);
		}

		function setupLightsView(camera) {
			lights.setupView(lightsArray, camera);
		}

		var state = {
			lightsArray: lightsArray,
			shadowsArray: shadowsArray,
			lights: lights
		};
		return {
			init: init,
			state: state,
			setupLights: setupLights,
			setupLightsView: setupLightsView,
			pushLight: pushLight,
			pushShadow: pushShadow
		};
	}

	function WebGLRenderStates(extensions, capabilities) {
		var renderStates = new WeakMap();

		function get(scene, renderCallDepth) {
			if (renderCallDepth === void 0) {
				renderCallDepth = 0;
			}

			var renderState;

			if (renderStates.has(scene) === false) {
				renderState = new WebGLRenderState(extensions, capabilities);
				renderStates.set(scene, [renderState]);
			} else {
				if (renderCallDepth >= renderStates.get(scene).length) {
					renderState = new WebGLRenderState(extensions, capabilities);
					renderStates.get(scene).push(renderState);
				} else {
					renderState = renderStates.get(scene)[renderCallDepth];
				}
			}

			return renderState;
		}

		function dispose() {
			renderStates = new WeakMap();
		}

		return {
			get: get,
			dispose: dispose
		};
	}

	/**
	 * parameters = {
	 *
	 *	opacity: <float>,
	 *
	 *	map: new THREE.Texture( <Image> ),
	 *
	 *	alphaMap: new THREE.Texture( <Image> ),
	 *
	 *	displacementMap: new THREE.Texture( <Image> ),
	 *	displacementScale: <float>,
	 *	displacementBias: <float>,
	 *
	 *	wireframe: <boolean>,
	 *	wireframeLinewidth: <float>
	 * }
	 */

	var MeshDepthMaterial = /*#__PURE__*/function (_Material) {
		_inheritsLoose(MeshDepthMaterial, _Material);

		function MeshDepthMaterial(parameters) {
			var _this;

			_this = _Material.call(this) || this;
			_this.type = 'MeshDepthMaterial';
			_this.depthPacking = BasicDepthPacking;
			_this.map = null;
			_this.alphaMap = null;
			_this.displacementMap = null;
			_this.displacementScale = 1;
			_this.displacementBias = 0;
			_this.wireframe = false;
			_this.wireframeLinewidth = 1;
			_this.fog = false;

			_this.setValues(parameters);

			return _this;
		}

		var _proto = MeshDepthMaterial.prototype;

		_proto.copy = function copy(source) {
			_Material.prototype.copy.call(this, source);

			this.depthPacking = source.depthPacking;
			this.map = source.map;
			this.alphaMap = source.alphaMap;
			this.displacementMap = source.displacementMap;
			this.displacementScale = source.displacementScale;
			this.displacementBias = source.displacementBias;
			this.wireframe = source.wireframe;
			this.wireframeLinewidth = source.wireframeLinewidth;
			return this;
		};

		return MeshDepthMaterial;
	}(Material);

	MeshDepthMaterial.prototype.isMeshDepthMaterial = true;

	/**
	 * parameters = {
	 *
	 *	referencePosition: <float>,
	 *	nearDistance: <float>,
	 *	farDistance: <float>,
	 *
	 *	map: new THREE.Texture( <Image> ),
	 *
	 *	alphaMap: new THREE.Texture( <Image> ),
	 *
	 *	displacementMap: new THREE.Texture( <Image> ),
	 *	displacementScale: <float>,
	 *	displacementBias: <float>
	 *
	 * }
	 */

	var MeshDistanceMaterial = /*#__PURE__*/function (_Material) {
		_inheritsLoose(MeshDistanceMaterial, _Material);

		function MeshDistanceMaterial(parameters) {
			var _this;

			_this = _Material.call(this) || this;
			_this.type = 'MeshDistanceMaterial';
			_this.referencePosition = new Vector3();
			_this.nearDistance = 1;
			_this.farDistance = 1000;
			_this.map = null;
			_this.alphaMap = null;
			_this.displacementMap = null;
			_this.displacementScale = 1;
			_this.displacementBias = 0;
			_this.fog = false;

			_this.setValues(parameters);

			return _this;
		}

		var _proto = MeshDistanceMaterial.prototype;

		_proto.copy = function copy(source) {
			_Material.prototype.copy.call(this, source);

			this.referencePosition.copy(source.referencePosition);
			this.nearDistance = source.nearDistance;
			this.farDistance = source.farDistance;
			this.map = source.map;
			this.alphaMap = source.alphaMap;
			this.displacementMap = source.displacementMap;
			this.displacementScale = source.displacementScale;
			this.displacementBias = source.displacementBias;
			return this;
		};

		return MeshDistanceMaterial;
	}(Material);

	MeshDistanceMaterial.prototype.isMeshDistanceMaterial = true;

	var vertex$g = "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}";
	var fragment$g = "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\nuniform float samples;\n#include <packing>\nvoid main() {\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}";

	function WebGLShadowMap(_renderer, _objects, _capabilities) {
		var _frustum = new Frustum();

		var _shadowMapSize = new Vector2(),
				_viewportSize = new Vector2(),
				_viewport = new Vector4(),
				_depthMaterial = new MeshDepthMaterial({
			depthPacking: RGBADepthPacking
		}),
				_distanceMaterial = new MeshDistanceMaterial(),
				_materialCache = {},
				_maxTextureSize = _capabilities.maxTextureSize;

		var shadowSide = {
			0: BackSide,
			1: FrontSide,
			2: DoubleSide
		};
		var shadowMaterialVertical = new ShaderMaterial({
			uniforms: {
				shadow_pass: {
					value: null
				},
				resolution: {
					value: new Vector2()
				},
				radius: {
					value: 4.0
				},
				samples: {
					value: 8.0
				}
			},
			vertexShader: vertex$g,
			fragmentShader: fragment$g
		});
		var shadowMaterialHorizontal = shadowMaterialVertical.clone();
		shadowMaterialHorizontal.defines.HORIZONTAL_PASS = 1;
		var fullScreenTri = new BufferGeometry();
		fullScreenTri.setAttribute('position', new BufferAttribute(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3));
		var fullScreenMesh = new Mesh(fullScreenTri, shadowMaterialVertical);
		var scope = this;
		this.enabled = false;
		this.autoUpdate = true;
		this.needsUpdate = false;
		this.type = PCFShadowMap;

		this.render = function (lights, scene, camera) {
			if (scope.enabled === false) return;
			if (scope.autoUpdate === false && scope.needsUpdate === false) return;
			if (lights.length === 0) return;

			var currentRenderTarget = _renderer.getRenderTarget();

			var activeCubeFace = _renderer.getActiveCubeFace();

			var activeMipmapLevel = _renderer.getActiveMipmapLevel();

			var _state = _renderer.state; // Set GL state for depth map.

			_state.setBlending(NoBlending);

			_state.buffers.color.setClear(1, 1, 1, 1);

			_state.buffers.depth.setTest(true);

			_state.setScissorTest(false); // render depth map


			for (var i = 0, il = lights.length; i < il; i++) {
				var light = lights[i];
				var shadow = light.shadow;

				if (shadow === undefined) {
					console.warn('THREE.WebGLShadowMap:', light, 'has no shadow.');
					continue;
				}

				if (shadow.autoUpdate === false && shadow.needsUpdate === false) continue;

				_shadowMapSize.copy(shadow.mapSize);

				var shadowFrameExtents = shadow.getFrameExtents();

				_shadowMapSize.multiply(shadowFrameExtents);

				_viewportSize.copy(shadow.mapSize);

				if (_shadowMapSize.x > _maxTextureSize || _shadowMapSize.y > _maxTextureSize) {
					if (_shadowMapSize.x > _maxTextureSize) {
						_viewportSize.x = Math.floor(_maxTextureSize / shadowFrameExtents.x);
						_shadowMapSize.x = _viewportSize.x * shadowFrameExtents.x;
						shadow.mapSize.x = _viewportSize.x;
					}

					if (_shadowMapSize.y > _maxTextureSize) {
						_viewportSize.y = Math.floor(_maxTextureSize / shadowFrameExtents.y);
						_shadowMapSize.y = _viewportSize.y * shadowFrameExtents.y;
						shadow.mapSize.y = _viewportSize.y;
					}
				}

				if (shadow.map === null && !shadow.isPointLightShadow && this.type === VSMShadowMap) {
					var pars = {
						minFilter: LinearFilter,
						magFilter: LinearFilter,
						format: RGBAFormat
					};
					shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
					shadow.map.texture.name = light.name + '.shadowMap';
					shadow.mapPass = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
					shadow.camera.updateProjectionMatrix();
				}

				if (shadow.map === null) {
					var _pars = {
						minFilter: NearestFilter,
						magFilter: NearestFilter,
						format: RGBAFormat
					};
					shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, _pars);
					shadow.map.texture.name = light.name + '.shadowMap';
					shadow.camera.updateProjectionMatrix();
				}

				_renderer.setRenderTarget(shadow.map);

				_renderer.clear();

				var viewportCount = shadow.getViewportCount();

				for (var vp = 0; vp < viewportCount; vp++) {
					var viewport = shadow.getViewport(vp);

					_viewport.set(_viewportSize.x * viewport.x, _viewportSize.y * viewport.y, _viewportSize.x * viewport.z, _viewportSize.y * viewport.w);

					_state.viewport(_viewport);

					shadow.updateMatrices(light, vp);
					_frustum = shadow.getFrustum();
					renderObject(scene, camera, shadow.camera, light, this.type);
				} // do blur pass for VSM


				if (!shadow.isPointLightShadow && this.type === VSMShadowMap) {
					VSMPass(shadow, camera);
				}

				shadow.needsUpdate = false;
			}

			scope.needsUpdate = false;

			_renderer.setRenderTarget(currentRenderTarget, activeCubeFace, activeMipmapLevel);
		};

		function VSMPass(shadow, camera) {
			var geometry = _objects.update(fullScreenMesh); // vertical pass


			shadowMaterialVertical.uniforms.shadow_pass.value = shadow.map.texture;
			shadowMaterialVertical.uniforms.resolution.value = shadow.mapSize;
			shadowMaterialVertical.uniforms.radius.value = shadow.radius;
			shadowMaterialVertical.uniforms.samples.value = shadow.blurSamples;

			_renderer.setRenderTarget(shadow.mapPass);

			_renderer.clear();

			_renderer.renderBufferDirect(camera, null, geometry, shadowMaterialVertical, fullScreenMesh, null); // horizontal pass


			shadowMaterialHorizontal.uniforms.shadow_pass.value = shadow.mapPass.texture;
			shadowMaterialHorizontal.uniforms.resolution.value = shadow.mapSize;
			shadowMaterialHorizontal.uniforms.radius.value = shadow.radius;
			shadowMaterialHorizontal.uniforms.samples.value = shadow.blurSamples;

			_renderer.setRenderTarget(shadow.map);

			_renderer.clear();

			_renderer.renderBufferDirect(camera, null, geometry, shadowMaterialHorizontal, fullScreenMesh, null);
		}

		function getDepthMaterial(object, geometry, material, light, shadowCameraNear, shadowCameraFar, type) {
			var result = null;
			var customMaterial = light.isPointLight === true ? object.customDistanceMaterial : object.customDepthMaterial;

			if (customMaterial !== undefined) {
				result = customMaterial;
			} else {
				result = light.isPointLight === true ? _distanceMaterial : _depthMaterial;
			}

			if (_renderer.localClippingEnabled && material.clipShadows === true && material.clippingPlanes.length !== 0 || material.displacementMap && material.displacementScale !== 0 || material.alphaMap && material.alphaTest > 0) {
				// in this case we need a unique material instance reflecting the
				// appropriate state
				var keyA = result.uuid,
						keyB = material.uuid;
				var materialsForVariant = _materialCache[keyA];

				if (materialsForVariant === undefined) {
					materialsForVariant = {};
					_materialCache[keyA] = materialsForVariant;
				}

				var cachedMaterial = materialsForVariant[keyB];

				if (cachedMaterial === undefined) {
					cachedMaterial = result.clone();
					materialsForVariant[keyB] = cachedMaterial;
				}

				result = cachedMaterial;
			}

			result.visible = material.visible;
			result.wireframe = material.wireframe;

			if (type === VSMShadowMap) {
				result.side = material.shadowSide !== null ? material.shadowSide : material.side;
			} else {
				result.side = material.shadowSide !== null ? material.shadowSide : shadowSide[material.side];
			}

			result.alphaMap = material.alphaMap;
			result.alphaTest = material.alphaTest;
			result.clipShadows = material.clipShadows;
			result.clippingPlanes = material.clippingPlanes;
			result.clipIntersection = material.clipIntersection;
			result.displacementMap = material.displacementMap;
			result.displacementScale = material.displacementScale;
			result.displacementBias = material.displacementBias;
			result.wireframeLinewidth = material.wireframeLinewidth;
			result.linewidth = material.linewidth;

			if (light.isPointLight === true && result.isMeshDistanceMaterial === true) {
				result.referencePosition.setFromMatrixPosition(light.matrixWorld);
				result.nearDistance = shadowCameraNear;
				result.farDistance = shadowCameraFar;
			}

			return result;
		}

		function renderObject(object, camera, shadowCamera, light, type) {
			if (object.visible === false) return;
			var visible = object.layers.test(camera.layers);

			if (visible && (object.isMesh || object.isLine || object.isPoints)) {
				if ((object.castShadow || object.receiveShadow && type === VSMShadowMap) && (!object.frustumCulled || _frustum.intersectsObject(object))) {
					object.modelViewMatrix.multiplyMatrices(shadowCamera.matrixWorldInverse, object.matrixWorld);

					var geometry = _objects.update(object);

					var material = object.material;

					if (Array.isArray(material)) {
						var groups = geometry.groups;

						for (var k = 0, kl = groups.length; k < kl; k++) {
							var group = groups[k];
							var groupMaterial = material[group.materialIndex];

							if (groupMaterial && groupMaterial.visible) {
								var depthMaterial = getDepthMaterial(object, geometry, groupMaterial, light, shadowCamera.near, shadowCamera.far, type);

								_renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, group);
							}
						}
					} else if (material.visible) {
						var _depthMaterial2 = getDepthMaterial(object, geometry, material, light, shadowCamera.near, shadowCamera.far, type);

						_renderer.renderBufferDirect(shadowCamera, null, geometry, _depthMaterial2, object, null);
					}
				}
			}

			var children = object.children;

			for (var i = 0, l = children.length; i < l; i++) {
				renderObject(children[i], camera, shadowCamera, light, type);
			}
		}
	}

	function WebGLState(gl, extensions, capabilities) {
		var _equationToGL, _factorToGL;

		var isWebGL2 = capabilities.isWebGL2;

		function ColorBuffer() {
			var locked = false;
			var color = new Vector4();
			var currentColorMask = null;
			var currentColorClear = new Vector4(0, 0, 0, 0);
			return {
				setMask: function setMask(colorMask) {
					if (currentColorMask !== colorMask && !locked) {
						gl.colorMask(colorMask, colorMask, colorMask, colorMask);
						currentColorMask = colorMask;
					}
				},
				setLocked: function setLocked(lock) {
					locked = lock;
				},
				setClear: function setClear(r, g, b, a, premultipliedAlpha) {
					if (premultipliedAlpha === true) {
						r *= a;
						g *= a;
						b *= a;
					}

					color.set(r, g, b, a);

					if (currentColorClear.equals(color) === false) {
						gl.clearColor(r, g, b, a);
						currentColorClear.copy(color);
					}
				},
				reset: function reset() {
					locked = false;
					currentColorMask = null;
					currentColorClear.set(-1, 0, 0, 0); // set to invalid state
				}
			};
		}

		function DepthBuffer() {
			var locked = false;
			var currentDepthMask = null;
			var currentDepthFunc = null;
			var currentDepthClear = null;
			return {
				setTest: function setTest(depthTest) {
					if (depthTest) {
						enable(gl.DEPTH_TEST);
					} else {
						disable(gl.DEPTH_TEST);
					}
				},
				setMask: function setMask(depthMask) {
					if (currentDepthMask !== depthMask && !locked) {
						gl.depthMask(depthMask);
						currentDepthMask = depthMask;
					}
				},
				setFunc: function setFunc(depthFunc) {
					if (currentDepthFunc !== depthFunc) {
						if (depthFunc) {
							switch (depthFunc) {
								case NeverDepth:
									gl.depthFunc(gl.NEVER);
									break;

								case AlwaysDepth:
									gl.depthFunc(gl.ALWAYS);
									break;

								case LessDepth:
									gl.depthFunc(gl.LESS);
									break;

								case LessEqualDepth:
									gl.depthFunc(gl.LEQUAL);
									break;

								case EqualDepth:
									gl.depthFunc(gl.EQUAL);
									break;

								case GreaterEqualDepth:
									gl.depthFunc(gl.GEQUAL);
									break;

								case GreaterDepth:
									gl.depthFunc(gl.GREATER);
									break;

								case NotEqualDepth:
									gl.depthFunc(gl.NOTEQUAL);
									break;

								default:
									gl.depthFunc(gl.LEQUAL);
							}
						} else {
							gl.depthFunc(gl.LEQUAL);
						}

						currentDepthFunc = depthFunc;
					}
				},
				setLocked: function setLocked(lock) {
					locked = lock;
				},
				setClear: function setClear(depth) {
					if (currentDepthClear !== depth) {
						gl.clearDepth(depth);
						currentDepthClear = depth;
					}
				},
				reset: function reset() {
					locked = false;
					currentDepthMask = null;
					currentDepthFunc = null;
					currentDepthClear = null;
				}
			};
		}

		function StencilBuffer() {
			var locked = false;
			var currentStencilMask = null;
			var currentStencilFunc = null;
			var currentStencilRef = null;
			var currentStencilFuncMask = null;
			var currentStencilFail = null;
			var currentStencilZFail = null;
			var currentStencilZPass = null;
			var currentStencilClear = null;
			return {
				setTest: function setTest(stencilTest) {
					if (!locked) {
						if (stencilTest) {
							enable(gl.STENCIL_TEST);
						} else {
							disable(gl.STENCIL_TEST);
						}
					}
				},
				setMask: function setMask(stencilMask) {
					if (currentStencilMask !== stencilMask && !locked) {
						gl.stencilMask(stencilMask);
						currentStencilMask = stencilMask;
					}
				},
				setFunc: function setFunc(stencilFunc, stencilRef, stencilMask) {
					if (currentStencilFunc !== stencilFunc || currentStencilRef !== stencilRef || currentStencilFuncMask !== stencilMask) {
						gl.stencilFunc(stencilFunc, stencilRef, stencilMask);
						currentStencilFunc = stencilFunc;
						currentStencilRef = stencilRef;
						currentStencilFuncMask = stencilMask;
					}
				},
				setOp: function setOp(stencilFail, stencilZFail, stencilZPass) {
					if (currentStencilFail !== stencilFail || currentStencilZFail !== stencilZFail || currentStencilZPass !== stencilZPass) {
						gl.stencilOp(stencilFail, stencilZFail, stencilZPass);
						currentStencilFail = stencilFail;
						currentStencilZFail = stencilZFail;
						currentStencilZPass = stencilZPass;
					}
				},
				setLocked: function setLocked(lock) {
					locked = lock;
				},
				setClear: function setClear(stencil) {
					if (currentStencilClear !== stencil) {
						gl.clearStencil(stencil);
						currentStencilClear = stencil;
					}
				},
				reset: function reset() {
					locked = false;
					currentStencilMask = null;
					currentStencilFunc = null;
					currentStencilRef = null;
					currentStencilFuncMask = null;
					currentStencilFail = null;
					currentStencilZFail = null;
					currentStencilZPass = null;
					currentStencilClear = null;
				}
			};
		} //


		var colorBuffer = new ColorBuffer();
		var depthBuffer = new DepthBuffer();
		var stencilBuffer = new StencilBuffer();
		var enabledCapabilities = {};
		var xrFramebuffer = null;
		var currentBoundFramebuffers = {};
		var currentProgram = null;
		var currentBlendingEnabled = false;
		var currentBlending = null;
		var currentBlendEquation = null;
		var currentBlendSrc = null;
		var currentBlendDst = null;
		var currentBlendEquationAlpha = null;
		var currentBlendSrcAlpha = null;
		var currentBlendDstAlpha = null;
		var currentPremultipledAlpha = false;
		var currentFlipSided = null;
		var currentCullFace = null;
		var currentLineWidth = null;
		var currentPolygonOffsetFactor = null;
		var currentPolygonOffsetUnits = null;
		var maxTextures = gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
		var lineWidthAvailable = false;
		var version = 0;
		var glVersion = gl.getParameter(gl.VERSION);

		if (glVersion.indexOf('WebGL') !== -1) {
			version = parseFloat(/^WebGL (\d)/.exec(glVersion)[1]);
			lineWidthAvailable = version >= 1.0;
		} else if (glVersion.indexOf('OpenGL ES') !== -1) {
			version = parseFloat(/^OpenGL ES (\d)/.exec(glVersion)[1]);
			lineWidthAvailable = version >= 2.0;
		}

		var currentTextureSlot = null;
		var currentBoundTextures = {};
		var scissorParam = gl.getParameter(gl.SCISSOR_BOX);
		var viewportParam = gl.getParameter(gl.VIEWPORT);
		var currentScissor = new Vector4().fromArray(scissorParam);
		var currentViewport = new Vector4().fromArray(viewportParam);

		function createTexture(type, target, count) {
			var data = new Uint8Array(4); // 4 is required to match default unpack alignment of 4.

			var texture = gl.createTexture();
			gl.bindTexture(type, texture);
			gl.texParameteri(type, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
			gl.texParameteri(type, gl.TEXTURE_MAG_FILTER, gl.NEAREST);

			for (var i = 0; i < count; i++) {
				gl.texImage2D(target + i, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);
			}

			return texture;
		}

		var emptyTextures = {};
		emptyTextures[gl.TEXTURE_2D] = createTexture(gl.TEXTURE_2D, gl.TEXTURE_2D, 1);
		emptyTextures[gl.TEXTURE_CUBE_MAP] = createTexture(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_CUBE_MAP_POSITIVE_X, 6); // init

		colorBuffer.setClear(0, 0, 0, 1);
		depthBuffer.setClear(1);
		stencilBuffer.setClear(0);
		enable(gl.DEPTH_TEST);
		depthBuffer.setFunc(LessEqualDepth);
		setFlipSided(false);
		setCullFace(CullFaceBack);
		enable(gl.CULL_FACE);
		setBlending(NoBlending); //

		function enable(id) {
			if (enabledCapabilities[id] !== true) {
				gl.enable(id);
				enabledCapabilities[id] = true;
			}
		}

		function disable(id) {
			if (enabledCapabilities[id] !== false) {
				gl.disable(id);
				enabledCapabilities[id] = false;
			}
		}

		function bindXRFramebuffer(framebuffer) {
			if (framebuffer !== xrFramebuffer) {
				gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
				xrFramebuffer = framebuffer;
			}
		}

		function bindFramebuffer(target, framebuffer) {
			if (framebuffer === null && xrFramebuffer !== null) framebuffer = xrFramebuffer; // use active XR framebuffer if available

			if (currentBoundFramebuffers[target] !== framebuffer) {
				gl.bindFramebuffer(target, framebuffer);
				currentBoundFramebuffers[target] = framebuffer;

				if (isWebGL2) {
					// gl.DRAW_FRAMEBUFFER is equivalent to gl.FRAMEBUFFER
					if (target === gl.DRAW_FRAMEBUFFER) {
						currentBoundFramebuffers[gl.FRAMEBUFFER] = framebuffer;
					}

					if (target === gl.FRAMEBUFFER) {
						currentBoundFramebuffers[gl.DRAW_FRAMEBUFFER] = framebuffer;
					}
				}

				return true;
			}

			return false;
		}

		function useProgram(program) {
			if (currentProgram !== program) {
				gl.useProgram(program);
				currentProgram = program;
				return true;
			}

			return false;
		}

		var equationToGL = (_equationToGL = {}, _equationToGL[AddEquation] = gl.FUNC_ADD, _equationToGL[SubtractEquation] = gl.FUNC_SUBTRACT, _equationToGL[ReverseSubtractEquation] = gl.FUNC_REVERSE_SUBTRACT, _equationToGL);

		if (isWebGL2) {
			equationToGL[MinEquation] = gl.MIN;
			equationToGL[MaxEquation] = gl.MAX;
		} else {
			var extension = extensions.get('EXT_blend_minmax');

			if (extension !== null) {
				equationToGL[MinEquation] = extension.MIN_EXT;
				equationToGL[MaxEquation] = extension.MAX_EXT;
			}
		}

		var factorToGL = (_factorToGL = {}, _factorToGL[ZeroFactor] = gl.ZERO, _factorToGL[OneFactor] = gl.ONE, _factorToGL[SrcColorFactor] = gl.SRC_COLOR, _factorToGL[SrcAlphaFactor] = gl.SRC_ALPHA, _factorToGL[SrcAlphaSaturateFactor] = gl.SRC_ALPHA_SATURATE, _factorToGL[DstColorFactor] = gl.DST_COLOR, _factorToGL[DstAlphaFactor] = gl.DST_ALPHA, _factorToGL[OneMinusSrcColorFactor] = gl.ONE_MINUS_SRC_COLOR, _factorToGL[OneMinusSrcAlphaFactor] = gl.ONE_MINUS_SRC_ALPHA, _factorToGL[OneMinusDstColorFactor] = gl.ONE_MINUS_DST_COLOR, _factorToGL[OneMinusDstAlphaFactor] = gl.ONE_MINUS_DST_ALPHA, _factorToGL);

		function setBlending(blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha) {
			if (blending === NoBlending) {
				if (currentBlendingEnabled === true) {
					disable(gl.BLEND);
					currentBlendingEnabled = false;
				}

				return;
			}

			if (currentBlendingEnabled === false) {
				enable(gl.BLEND);
				currentBlendingEnabled = true;
			}

			if (blending !== CustomBlending) {
				if (blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha) {
					if (currentBlendEquation !== AddEquation || currentBlendEquationAlpha !== AddEquation) {
						gl.blendEquation(gl.FUNC_ADD);
						currentBlendEquation = AddEquation;
						currentBlendEquationAlpha = AddEquation;
					}

					if (premultipliedAlpha) {
						switch (blending) {
							case NormalBlending:
								gl.blendFuncSeparate(gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
								break;

							case AdditiveBlending:
								gl.blendFunc(gl.ONE, gl.ONE);
								break;

							case SubtractiveBlending:
								gl.blendFuncSeparate(gl.ZERO, gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ONE_MINUS_SRC_ALPHA);
								break;

							case MultiplyBlending:
								gl.blendFuncSeparate(gl.ZERO, gl.SRC_COLOR, gl.ZERO, gl.SRC_ALPHA);
								break;

							default:
								console.error('THREE.WebGLState: Invalid blending: ', blending);
								break;
						}
					} else {
						switch (blending) {
							case NormalBlending:
								gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
								break;

							case AdditiveBlending:
								gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
								break;

							case SubtractiveBlending:
								gl.blendFunc(gl.ZERO, gl.ONE_MINUS_SRC_COLOR);
								break;

							case MultiplyBlending:
								gl.blendFunc(gl.ZERO, gl.SRC_COLOR);
								break;

							default:
								console.error('THREE.WebGLState: Invalid blending: ', blending);
								break;
						}
					}

					currentBlendSrc = null;
					currentBlendDst = null;
					currentBlendSrcAlpha = null;
					currentBlendDstAlpha = null;
					currentBlending = blending;
					currentPremultipledAlpha = premultipliedAlpha;
				}

				return;
			} // custom blending


			blendEquationAlpha = blendEquationAlpha || blendEquation;
			blendSrcAlpha = blendSrcAlpha || blendSrc;
			blendDstAlpha = blendDstAlpha || blendDst;

			if (blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha) {
				gl.blendEquationSeparate(equationToGL[blendEquation], equationToGL[blendEquationAlpha]);
				currentBlendEquation = blendEquation;
				currentBlendEquationAlpha = blendEquationAlpha;
			}

			if (blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha) {
				gl.blendFuncSeparate(factorToGL[blendSrc], factorToGL[blendDst], factorToGL[blendSrcAlpha], factorToGL[blendDstAlpha]);
				currentBlendSrc = blendSrc;
				currentBlendDst = blendDst;
				currentBlendSrcAlpha = blendSrcAlpha;
				currentBlendDstAlpha = blendDstAlpha;
			}

			currentBlending = blending;
			currentPremultipledAlpha = null;
		}

		function setMaterial(material, frontFaceCW) {
			material.side === DoubleSide ? disable(gl.CULL_FACE) : enable(gl.CULL_FACE);
			var flipSided = material.side === BackSide;
			if (frontFaceCW) flipSided = !flipSided;
			setFlipSided(flipSided);
			material.blending === NormalBlending && material.transparent === false ? setBlending(NoBlending) : setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha);
			depthBuffer.setFunc(material.depthFunc);
			depthBuffer.setTest(material.depthTest);
			depthBuffer.setMask(material.depthWrite);
			colorBuffer.setMask(material.colorWrite);
			var stencilWrite = material.stencilWrite;
			stencilBuffer.setTest(stencilWrite);

			if (stencilWrite) {
				stencilBuffer.setMask(material.stencilWriteMask);
				stencilBuffer.setFunc(material.stencilFunc, material.stencilRef, material.stencilFuncMask);
				stencilBuffer.setOp(material.stencilFail, material.stencilZFail, material.stencilZPass);
			}

			setPolygonOffset(material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits);
			material.alphaToCoverage === true ? enable(gl.SAMPLE_ALPHA_TO_COVERAGE) : disable(gl.SAMPLE_ALPHA_TO_COVERAGE);
		} //


		function setFlipSided(flipSided) {
			if (currentFlipSided !== flipSided) {
				if (flipSided) {
					gl.frontFace(gl.CW);
				} else {
					gl.frontFace(gl.CCW);
				}

				currentFlipSided = flipSided;
			}
		}

		function setCullFace(cullFace) {
			if (cullFace !== CullFaceNone) {
				enable(gl.CULL_FACE);

				if (cullFace !== currentCullFace) {
					if (cullFace === CullFaceBack) {
						gl.cullFace(gl.BACK);
					} else if (cullFace === CullFaceFront) {
						gl.cullFace(gl.FRONT);
					} else {
						gl.cullFace(gl.FRONT_AND_BACK);
					}
				}
			} else {
				disable(gl.CULL_FACE);
			}

			currentCullFace = cullFace;
		}

		function setLineWidth(width) {
			if (width !== currentLineWidth) {
				if (lineWidthAvailable) gl.lineWidth(width);
				currentLineWidth = width;
			}
		}

		function setPolygonOffset(polygonOffset, factor, units) {
			if (polygonOffset) {
				enable(gl.POLYGON_OFFSET_FILL);

				if (currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units) {
					gl.polygonOffset(factor, units);
					currentPolygonOffsetFactor = factor;
					currentPolygonOffsetUnits = units;
				}
			} else {
				disable(gl.POLYGON_OFFSET_FILL);
			}
		}

		function setScissorTest(scissorTest) {
			if (scissorTest) {
				enable(gl.SCISSOR_TEST);
			} else {
				disable(gl.SCISSOR_TEST);
			}
		} // texture


		function activeTexture(webglSlot) {
			if (webglSlot === undefined) webglSlot = gl.TEXTURE0 + maxTextures - 1;

			if (currentTextureSlot !== webglSlot) {
				gl.activeTexture(webglSlot);
				currentTextureSlot = webglSlot;
			}
		}

		function bindTexture(webglType, webglTexture) {
			if (currentTextureSlot === null) {
				activeTexture();
			}

			var boundTexture = currentBoundTextures[currentTextureSlot];

			if (boundTexture === undefined) {
				boundTexture = {
					type: undefined,
					texture: undefined
				};
				currentBoundTextures[currentTextureSlot] = boundTexture;
			}

			if (boundTexture.type !== webglType || boundTexture.texture !== webglTexture) {
				gl.bindTexture(webglType, webglTexture || emptyTextures[webglType]);
				boundTexture.type = webglType;
				boundTexture.texture = webglTexture;
			}
		}

		function unbindTexture() {
			var boundTexture = currentBoundTextures[currentTextureSlot];

			if (boundTexture !== undefined && boundTexture.type !== undefined) {
				gl.bindTexture(boundTexture.type, null);
				boundTexture.type = undefined;
				boundTexture.texture = undefined;
			}
		}

		function compressedTexImage2D() {
			try {
				gl.compressedTexImage2D.apply(gl, arguments);
			} catch (error) {
				console.error('THREE.WebGLState:', error);
			}
		}

		function texImage2D() {
			try {
				gl.texImage2D.apply(gl, arguments);
			} catch (error) {
				console.error('THREE.WebGLState:', error);
			}
		}

		function texImage3D() {
			try {
				gl.texImage3D.apply(gl, arguments);
			} catch (error) {
				console.error('THREE.WebGLState:', error);
			}
		} //


		function scissor(scissor) {
			if (currentScissor.equals(scissor) === false) {
				gl.scissor(scissor.x, scissor.y, scissor.z, scissor.w);
				currentScissor.copy(scissor);
			}
		}

		function viewport(viewport) {
			if (currentViewport.equals(viewport) === false) {
				gl.viewport(viewport.x, viewport.y, viewport.z, viewport.w);
				currentViewport.copy(viewport);
			}
		} //


		function reset() {
			// reset state
			gl.disable(gl.BLEND);
			gl.disable(gl.CULL_FACE);
			gl.disable(gl.DEPTH_TEST);
			gl.disable(gl.POLYGON_OFFSET_FILL);
			gl.disable(gl.SCISSOR_TEST);
			gl.disable(gl.STENCIL_TEST);
			gl.disable(gl.SAMPLE_ALPHA_TO_COVERAGE);
			gl.blendEquation(gl.FUNC_ADD);
			gl.blendFunc(gl.ONE, gl.ZERO);
			gl.blendFuncSeparate(gl.ONE, gl.ZERO, gl.ONE, gl.ZERO);
			gl.colorMask(true, true, true, true);
			gl.clearColor(0, 0, 0, 0);
			gl.depthMask(true);
			gl.depthFunc(gl.LESS);
			gl.clearDepth(1);
			gl.stencilMask(0xffffffff);
			gl.stencilFunc(gl.ALWAYS, 0, 0xffffffff);
			gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
			gl.clearStencil(0);
			gl.cullFace(gl.BACK);
			gl.frontFace(gl.CCW);
			gl.polygonOffset(0, 0);
			gl.activeTexture(gl.TEXTURE0);
			gl.bindFramebuffer(gl.FRAMEBUFFER, null);

			if (isWebGL2 === true) {
				gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, null);
				gl.bindFramebuffer(gl.READ_FRAMEBUFFER, null);
			}

			gl.useProgram(null);
			gl.lineWidth(1);
			gl.scissor(0, 0, gl.canvas.width, gl.canvas.height);
			gl.viewport(0, 0, gl.canvas.width, gl.canvas.height); // reset internals

			enabledCapabilities = {};
			currentTextureSlot = null;
			currentBoundTextures = {};
			xrFramebuffer = null;
			currentBoundFramebuffers = {};
			currentProgram = null;
			currentBlendingEnabled = false;
			currentBlending = null;
			currentBlendEquation = null;
			currentBlendSrc = null;
			currentBlendDst = null;
			currentBlendEquationAlpha = null;
			currentBlendSrcAlpha = null;
			currentBlendDstAlpha = null;
			currentPremultipledAlpha = false;
			currentFlipSided = null;
			currentCullFace = null;
			currentLineWidth = null;
			currentPolygonOffsetFactor = null;
			currentPolygonOffsetUnits = null;
			currentScissor.set(0, 0, gl.canvas.width, gl.canvas.height);
			currentViewport.set(0, 0, gl.canvas.width, gl.canvas.height);
			colorBuffer.reset();
			depthBuffer.reset();
			stencilBuffer.reset();
		}

		return {
			buffers: {
				color: colorBuffer,
				depth: depthBuffer,
				stencil: stencilBuffer
			},
			enable: enable,
			disable: disable,
			bindFramebuffer: bindFramebuffer,
			bindXRFramebuffer: bindXRFramebuffer,
			useProgram: useProgram,
			setBlending: setBlending,
			setMaterial: setMaterial,
			setFlipSided: setFlipSided,
			setCullFace: setCullFace,
			setLineWidth: setLineWidth,
			setPolygonOffset: setPolygonOffset,
			setScissorTest: setScissorTest,
			activeTexture: activeTexture,
			bindTexture: bindTexture,
			unbindTexture: unbindTexture,
			compressedTexImage2D: compressedTexImage2D,
			texImage2D: texImage2D,
			texImage3D: texImage3D,
			scissor: scissor,
			viewport: viewport,
			reset: reset
		};
	}

	function WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info) {
		var _wrappingToGL, _filterToGL;

		var isWebGL2 = capabilities.isWebGL2;
		var maxTextures = capabilities.maxTextures;
		var maxCubemapSize = capabilities.maxCubemapSize;
		var maxTextureSize = capabilities.maxTextureSize;
		var maxSamples = capabilities.maxSamples;

		var _videoTextures = new WeakMap();

		var _canvas; // cordova iOS (as of 5.0) still uses UIWebView, which provides OffscreenCanvas,
		// also OffscreenCanvas.getContext("webgl"), but not OffscreenCanvas.getContext("2d")!
		// Some implementations may only implement OffscreenCanvas partially (e.g. lacking 2d).


		var useOffscreenCanvas = false;

		try {
			useOffscreenCanvas = typeof OffscreenCanvas !== 'undefined' && new OffscreenCanvas(1, 1).getContext('2d') !== null;
		} catch (err) {// Ignore any errors
		}

		function createCanvas(width, height) {
			// Use OffscreenCanvas when available. Specially needed in web workers
			return useOffscreenCanvas ? new OffscreenCanvas(width, height) : createElementNS('canvas');
		}

		function resizeImage(image, needsPowerOfTwo, needsNewCanvas, maxSize) {
			var scale = 1; // handle case if texture exceeds max size

			if (image.width > maxSize || image.height > maxSize) {
				scale = maxSize / Math.max(image.width, image.height);
			} // only perform resize if necessary


			if (scale < 1 || needsPowerOfTwo === true) {
				// only perform resize for certain image types
				if (typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement || typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap) {
					var floor = needsPowerOfTwo ? floorPowerOfTwo : Math.floor;
					var width = floor(scale * image.width);
					var height = floor(scale * image.height);
					if (_canvas === undefined) _canvas = createCanvas(width, height); // cube textures can't reuse the same canvas

					var canvas = needsNewCanvas ? createCanvas(width, height) : _canvas;
					canvas.width = width;
					canvas.height = height;
					var context = canvas.getContext('2d');
					context.drawImage(image, 0, 0, width, height);
					console.warn('THREE.WebGLRenderer: Texture has been resized from (' + image.width + 'x' + image.height + ') to (' + width + 'x' + height + ').');
					return canvas;
				} else {
					if ('data' in image) {
						console.warn('THREE.WebGLRenderer: Image in DataTexture is too big (' + image.width + 'x' + image.height + ').');
					}

					return image;
				}
			}

			return image;
		}

		function isPowerOfTwo$1(image) {
			return isPowerOfTwo(image.width) && isPowerOfTwo(image.height);
		}

		function textureNeedsPowerOfTwo(texture) {
			if (isWebGL2) return false;
			return texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping || texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;
		}

		function textureNeedsGenerateMipmaps(texture, supportsMips) {
			return texture.generateMipmaps && supportsMips && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;
		}

		function generateMipmap(target, texture, width, height, depth) {
			if (depth === void 0) {
				depth = 1;
			}

			_gl.generateMipmap(target);

			var textureProperties = properties.get(texture);
			textureProperties.__maxMipLevel = Math.log2(Math.max(width, height, depth));
		}

		function getInternalFormat(internalFormatName, glFormat, glType, encoding) {
			if (isWebGL2 === false) return glFormat;

			if (internalFormatName !== null) {
				if (_gl[internalFormatName] !== undefined) return _gl[internalFormatName];
				console.warn('THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format \'' + internalFormatName + '\'');
			}

			var internalFormat = glFormat;

			if (glFormat === _gl.RED) {
				if (glType === _gl.FLOAT) internalFormat = _gl.R32F;
				if (glType === _gl.HALF_FLOAT) internalFormat = _gl.R16F;
				if (glType === _gl.UNSIGNED_BYTE) internalFormat = _gl.R8;
			}

			if (glFormat === _gl.RGB) {
				if (glType === _gl.FLOAT) internalFormat = _gl.RGB32F;
				if (glType === _gl.HALF_FLOAT) internalFormat = _gl.RGB16F;
				if (glType === _gl.UNSIGNED_BYTE) internalFormat = _gl.RGB8;
			}

			if (glFormat === _gl.RGBA) {
				if (glType === _gl.FLOAT) internalFormat = _gl.RGBA32F;
				if (glType === _gl.HALF_FLOAT) internalFormat = _gl.RGBA16F;
				if (glType === _gl.UNSIGNED_BYTE) internalFormat = encoding === sRGBEncoding ? _gl.SRGB8_ALPHA8 : _gl.RGBA8;
			}

			if (internalFormat === _gl.R16F || internalFormat === _gl.R32F || internalFormat === _gl.RGBA16F || internalFormat === _gl.RGBA32F) {
				extensions.get('EXT_color_buffer_float');
			}

			return internalFormat;
		} // Fallback filters for non-power-of-2 textures


		function filterFallback(f) {
			if (f === NearestFilter || f === NearestMipmapNearestFilter || f === NearestMipmapLinearFilter) {
				return _gl.NEAREST;
			}

			return _gl.LINEAR;
		} //


		function onTextureDispose(event) {
			var texture = event.target;
			texture.removeEventListener('dispose', onTextureDispose);
			deallocateTexture(texture);

			if (texture.isVideoTexture) {
				_videoTextures.delete(texture);
			}

			info.memory.textures--;
		}

		function onRenderTargetDispose(event) {
			var renderTarget = event.target;
			renderTarget.removeEventListener('dispose', onRenderTargetDispose);
			deallocateRenderTarget(renderTarget);
		} //


		function deallocateTexture(texture) {
			var textureProperties = properties.get(texture);
			if (textureProperties.__webglInit === undefined) return;

			_gl.deleteTexture(textureProperties.__webglTexture);

			properties.remove(texture);
		}

		function deallocateRenderTarget(renderTarget) {
			var texture = renderTarget.texture;
			var renderTargetProperties = properties.get(renderTarget);
			var textureProperties = properties.get(texture);
			if (!renderTarget) return;

			if (textureProperties.__webglTexture !== undefined) {
				_gl.deleteTexture(textureProperties.__webglTexture);

				info.memory.textures--;
			}

			if (renderTarget.depthTexture) {
				renderTarget.depthTexture.dispose();
			}

			if (renderTarget.isWebGLCubeRenderTarget) {
				for (var i = 0; i < 6; i++) {
					_gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i]);

					if (renderTargetProperties.__webglDepthbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer[i]);
				}
			} else {
				_gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer);

				if (renderTargetProperties.__webglDepthbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer);
				if (renderTargetProperties.__webglMultisampledFramebuffer) _gl.deleteFramebuffer(renderTargetProperties.__webglMultisampledFramebuffer);
				if (renderTargetProperties.__webglColorRenderbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglColorRenderbuffer);
				if (renderTargetProperties.__webglDepthRenderbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthRenderbuffer);
			}

			if (renderTarget.isWebGLMultipleRenderTargets) {
				for (var _i = 0, il = texture.length; _i < il; _i++) {
					var attachmentProperties = properties.get(texture[_i]);

					if (attachmentProperties.__webglTexture) {
						_gl.deleteTexture(attachmentProperties.__webglTexture);

						info.memory.textures--;
					}

					properties.remove(texture[_i]);
				}
			}

			properties.remove(texture);
			properties.remove(renderTarget);
		} //


		var textureUnits = 0;

		function resetTextureUnits() {
			textureUnits = 0;
		}

		function allocateTextureUnit() {
			var textureUnit = textureUnits;

			if (textureUnit >= maxTextures) {
				console.warn('THREE.WebGLTextures: Trying to use ' + textureUnit + ' texture units while this GPU supports only ' + maxTextures);
			}

			textureUnits += 1;
			return textureUnit;
		} //


		function setTexture2D(texture, slot) {
			var textureProperties = properties.get(texture);
			if (texture.isVideoTexture) updateVideoTexture(texture);

			if (texture.version > 0 && textureProperties.__version !== texture.version) {
				var image = texture.image;

				if (image === undefined) {
					console.warn('THREE.WebGLRenderer: Texture marked for update but image is undefined');
				} else if (image.complete === false) {
					console.warn('THREE.WebGLRenderer: Texture marked for update but image is incomplete');
				} else {
					uploadTexture(textureProperties, texture, slot);
					return;
				}
			}

			state.activeTexture(_gl.TEXTURE0 + slot);
			state.bindTexture(_gl.TEXTURE_2D, textureProperties.__webglTexture);
		}

		function setTexture2DArray(texture, slot) {
			var textureProperties = properties.get(texture);

			if (texture.version > 0 && textureProperties.__version !== texture.version) {
				uploadTexture(textureProperties, texture, slot);
				return;
			}

			state.activeTexture(_gl.TEXTURE0 + slot);
			state.bindTexture(_gl.TEXTURE_2D_ARRAY, textureProperties.__webglTexture);
		}

		function setTexture3D(texture, slot) {
			var textureProperties = properties.get(texture);

			if (texture.version > 0 && textureProperties.__version !== texture.version) {
				uploadTexture(textureProperties, texture, slot);
				return;
			}

			state.activeTexture(_gl.TEXTURE0 + slot);
			state.bindTexture(_gl.TEXTURE_3D, textureProperties.__webglTexture);
		}

		function setTextureCube(texture, slot) {
			var textureProperties = properties.get(texture);

			if (texture.version > 0 && textureProperties.__version !== texture.version) {
				uploadCubeTexture(textureProperties, texture, slot);
				return;
			}

			state.activeTexture(_gl.TEXTURE0 + slot);
			state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture);
		}

		var wrappingToGL = (_wrappingToGL = {}, _wrappingToGL[RepeatWrapping] = _gl.REPEAT, _wrappingToGL[ClampToEdgeWrapping] = _gl.CLAMP_TO_EDGE, _wrappingToGL[MirroredRepeatWrapping] = _gl.MIRRORED_REPEAT, _wrappingToGL);
		var filterToGL = (_filterToGL = {}, _filterToGL[NearestFilter] = _gl.NEAREST, _filterToGL[NearestMipmapNearestFilter] = _gl.NEAREST_MIPMAP_NEAREST, _filterToGL[NearestMipmapLinearFilter] = _gl.NEAREST_MIPMAP_LINEAR, _filterToGL[LinearFilter] = _gl.LINEAR, _filterToGL[LinearMipmapNearestFilter] = _gl.LINEAR_MIPMAP_NEAREST, _filterToGL[LinearMipmapLinearFilter] = _gl.LINEAR_MIPMAP_LINEAR, _filterToGL);

		function setTextureParameters(textureType, texture, supportsMips) {
			if (supportsMips) {
				_gl.texParameteri(textureType, _gl.TEXTURE_WRAP_S, wrappingToGL[texture.wrapS]);

				_gl.texParameteri(textureType, _gl.TEXTURE_WRAP_T, wrappingToGL[texture.wrapT]);

				if (textureType === _gl.TEXTURE_3D || textureType === _gl.TEXTURE_2D_ARRAY) {
					_gl.texParameteri(textureType, _gl.TEXTURE_WRAP_R, wrappingToGL[texture.wrapR]);
				}

				_gl.texParameteri(textureType, _gl.TEXTURE_MAG_FILTER, filterToGL[texture.magFilter]);

				_gl.texParameteri(textureType, _gl.TEXTURE_MIN_FILTER, filterToGL[texture.minFilter]);
			} else {
				_gl.texParameteri(textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE);

				_gl.texParameteri(textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE);

				if (textureType === _gl.TEXTURE_3D || textureType === _gl.TEXTURE_2D_ARRAY) {
					_gl.texParameteri(textureType, _gl.TEXTURE_WRAP_R, _gl.CLAMP_TO_EDGE);
				}

				if (texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping) {
					console.warn('THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.');
				}

				_gl.texParameteri(textureType, _gl.TEXTURE_MAG_FILTER, filterFallback(texture.magFilter));

				_gl.texParameteri(textureType, _gl.TEXTURE_MIN_FILTER, filterFallback(texture.minFilter));

				if (texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter) {
					console.warn('THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.');
				}
			}

			if (extensions.has('EXT_texture_filter_anisotropic') === true) {
				var extension = extensions.get('EXT_texture_filter_anisotropic');
				if (texture.type === FloatType && extensions.has('OES_texture_float_linear') === false) return; // verify extension for WebGL 1 and WebGL 2

				if (isWebGL2 === false && texture.type === HalfFloatType && extensions.has('OES_texture_half_float_linear') === false) return; // verify extension for WebGL 1 only

				if (texture.anisotropy > 1 || properties.get(texture).__currentAnisotropy) {
					_gl.texParameterf(textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(texture.anisotropy, capabilities.getMaxAnisotropy()));

					properties.get(texture).__currentAnisotropy = texture.anisotropy;
				}
			}
		}

		function initTexture(textureProperties, texture) {
			if (textureProperties.__webglInit === undefined) {
				textureProperties.__webglInit = true;
				texture.addEventListener('dispose', onTextureDispose);
				textureProperties.__webglTexture = _gl.createTexture();
				info.memory.textures++;
			}
		}

		function uploadTexture(textureProperties, texture, slot) {
			var textureType = _gl.TEXTURE_2D;
			if (texture.isDataTexture2DArray) textureType = _gl.TEXTURE_2D_ARRAY;
			if (texture.isDataTexture3D) textureType = _gl.TEXTURE_3D;
			initTexture(textureProperties, texture);
			state.activeTexture(_gl.TEXTURE0 + slot);
			state.bindTexture(textureType, textureProperties.__webglTexture);

			_gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);

			_gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha);

			_gl.pixelStorei(_gl.UNPACK_ALIGNMENT, texture.unpackAlignment);

			_gl.pixelStorei(_gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, _gl.NONE);

			var needsPowerOfTwo = textureNeedsPowerOfTwo(texture) && isPowerOfTwo$1(texture.image) === false;
			var image = resizeImage(texture.image, needsPowerOfTwo, false, maxTextureSize);
			var supportsMips = isPowerOfTwo$1(image) || isWebGL2,
					glFormat = utils.convert(texture.format);
			var glType = utils.convert(texture.type),
					glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.encoding);
			setTextureParameters(textureType, texture, supportsMips);
			var mipmap;
			var mipmaps = texture.mipmaps;

			if (texture.isDepthTexture) {
				// populate depth texture with dummy data
				glInternalFormat = _gl.DEPTH_COMPONENT;

				if (isWebGL2) {
					if (texture.type === FloatType) {
						glInternalFormat = _gl.DEPTH_COMPONENT32F;
					} else if (texture.type === UnsignedIntType) {
						glInternalFormat = _gl.DEPTH_COMPONENT24;
					} else if (texture.type === UnsignedInt248Type) {
						glInternalFormat = _gl.DEPTH24_STENCIL8;
					} else {
						glInternalFormat = _gl.DEPTH_COMPONENT16; // WebGL2 requires sized internalformat for glTexImage2D
					}
				} else {
					if (texture.type === FloatType) {
						console.error('WebGLRenderer: Floating point depth texture requires WebGL2.');
					}
				} // validation checks for WebGL 1


				if (texture.format === DepthFormat && glInternalFormat === _gl.DEPTH_COMPONENT) {
					// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
					// DEPTH_COMPONENT and type is not UNSIGNED_SHORT or UNSIGNED_INT
					// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
					if (texture.type !== UnsignedShortType && texture.type !== UnsignedIntType) {
						console.warn('THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.');
						texture.type = UnsignedShortType;
						glType = utils.convert(texture.type);
					}
				}

				if (texture.format === DepthStencilFormat && glInternalFormat === _gl.DEPTH_COMPONENT) {
					// Depth stencil textures need the DEPTH_STENCIL internal format
					// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
					glInternalFormat = _gl.DEPTH_STENCIL; // The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
					// DEPTH_STENCIL and type is not UNSIGNED_INT_24_8_WEBGL.
					// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)

					if (texture.type !== UnsignedInt248Type) {
						console.warn('THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.');
						texture.type = UnsignedInt248Type;
						glType = utils.convert(texture.type);
					}
				} //


				state.texImage2D(_gl.TEXTURE_2D, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null);
			} else if (texture.isDataTexture) {
				// use manually created mipmaps if available
				// if there are no manual mipmaps
				// set 0 level mipmap and then use GL to generate other mipmap levels
				if (mipmaps.length > 0 && supportsMips) {
					for (var i = 0, il = mipmaps.length; i < il; i++) {
						mipmap = mipmaps[i];
						state.texImage2D(_gl.TEXTURE_2D, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
					}

					texture.generateMipmaps = false;
					textureProperties.__maxMipLevel = mipmaps.length - 1;
				} else {
					state.texImage2D(_gl.TEXTURE_2D, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, image.data);
					textureProperties.__maxMipLevel = 0;
				}
			} else if (texture.isCompressedTexture) {
				for (var _i2 = 0, _il = mipmaps.length; _i2 < _il; _i2++) {
					mipmap = mipmaps[_i2];

					if (texture.format !== RGBAFormat && texture.format !== RGBFormat) {
						if (glFormat !== null) {
							state.compressedTexImage2D(_gl.TEXTURE_2D, _i2, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
						} else {
							console.warn('THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()');
						}
					} else {
						state.texImage2D(_gl.TEXTURE_2D, _i2, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
					}
				}

				textureProperties.__maxMipLevel = mipmaps.length - 1;
			} else if (texture.isDataTexture2DArray) {
				state.texImage3D(_gl.TEXTURE_2D_ARRAY, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
				textureProperties.__maxMipLevel = 0;
			} else if (texture.isDataTexture3D) {
				state.texImage3D(_gl.TEXTURE_3D, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
				textureProperties.__maxMipLevel = 0;
			} else {
				// regular Texture (image, video, canvas)
				// use manually created mipmaps if available
				// if there are no manual mipmaps
				// set 0 level mipmap and then use GL to generate other mipmap levels
				if (mipmaps.length > 0 && supportsMips) {
					for (var _i3 = 0, _il2 = mipmaps.length; _i3 < _il2; _i3++) {
						mipmap = mipmaps[_i3];
						state.texImage2D(_gl.TEXTURE_2D, _i3, glInternalFormat, glFormat, glType, mipmap);
					}

					texture.generateMipmaps = false;
					textureProperties.__maxMipLevel = mipmaps.length - 1;
				} else {
					state.texImage2D(_gl.TEXTURE_2D, 0, glInternalFormat, glFormat, glType, image);
					textureProperties.__maxMipLevel = 0;
				}
			}

			if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
				generateMipmap(textureType, texture, image.width, image.height);
			}

			textureProperties.__version = texture.version;
			if (texture.onUpdate) texture.onUpdate(texture);
		}

		function uploadCubeTexture(textureProperties, texture, slot) {
			if (texture.image.length !== 6) return;
			initTexture(textureProperties, texture);
			state.activeTexture(_gl.TEXTURE0 + slot);
			state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture);

			_gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);

			_gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha);

			_gl.pixelStorei(_gl.UNPACK_ALIGNMENT, texture.unpackAlignment);

			_gl.pixelStorei(_gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, _gl.NONE);

			var isCompressed = texture && (texture.isCompressedTexture || texture.image[0].isCompressedTexture);
			var isDataTexture = texture.image[0] && texture.image[0].isDataTexture;
			var cubeImage = [];

			for (var i = 0; i < 6; i++) {
				if (!isCompressed && !isDataTexture) {
					cubeImage[i] = resizeImage(texture.image[i], false, true, maxCubemapSize);
				} else {
					cubeImage[i] = isDataTexture ? texture.image[i].image : texture.image[i];
				}
			}

			var image = cubeImage[0],
					supportsMips = isPowerOfTwo$1(image) || isWebGL2,
					glFormat = utils.convert(texture.format),
					glType = utils.convert(texture.type),
					glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.encoding);
			setTextureParameters(_gl.TEXTURE_CUBE_MAP, texture, supportsMips);
			var mipmaps;

			if (isCompressed) {
				for (var _i4 = 0; _i4 < 6; _i4++) {
					mipmaps = cubeImage[_i4].mipmaps;

					for (var j = 0; j < mipmaps.length; j++) {
						var mipmap = mipmaps[j];

						if (texture.format !== RGBAFormat && texture.format !== RGBFormat) {
							if (glFormat !== null) {
								state.compressedTexImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + _i4, j, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
							} else {
								console.warn('THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()');
							}
						} else {
							state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + _i4, j, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
						}
					}
				}

				textureProperties.__maxMipLevel = mipmaps.length - 1;
			} else {
				mipmaps = texture.mipmaps;

				for (var _i5 = 0; _i5 < 6; _i5++) {
					if (isDataTexture) {
						state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + _i5, 0, glInternalFormat, cubeImage[_i5].width, cubeImage[_i5].height, 0, glFormat, glType, cubeImage[_i5].data);

						for (var _j = 0; _j < mipmaps.length; _j++) {
							var _mipmap = mipmaps[_j];
							var mipmapImage = _mipmap.image[_i5].image;
							state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + _i5, _j + 1, glInternalFormat, mipmapImage.width, mipmapImage.height, 0, glFormat, glType, mipmapImage.data);
						}
					} else {
						state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + _i5, 0, glInternalFormat, glFormat, glType, cubeImage[_i5]);

						for (var _j2 = 0; _j2 < mipmaps.length; _j2++) {
							var _mipmap2 = mipmaps[_j2];
							state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + _i5, _j2 + 1, glInternalFormat, glFormat, glType, _mipmap2.image[_i5]);
						}
					}
				}

				textureProperties.__maxMipLevel = mipmaps.length;
			}

			if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
				// We assume images for cube map have the same size.
				generateMipmap(_gl.TEXTURE_CUBE_MAP, texture, image.width, image.height);
			}

			textureProperties.__version = texture.version;
			if (texture.onUpdate) texture.onUpdate(texture);
		} // Render targets
		// Setup storage for target texture and bind it to correct framebuffer


		function setupFrameBufferTexture(framebuffer, renderTarget, texture, attachment, textureTarget) {
			var glFormat = utils.convert(texture.format);
			var glType = utils.convert(texture.type);
			var glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.encoding);

			if (textureTarget === _gl.TEXTURE_3D || textureTarget === _gl.TEXTURE_2D_ARRAY) {
				state.texImage3D(textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, renderTarget.depth, 0, glFormat, glType, null);
			} else {
				state.texImage2D(textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null);
			}

			state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);

			_gl.framebufferTexture2D(_gl.FRAMEBUFFER, attachment, textureTarget, properties.get(texture).__webglTexture, 0);

			state.bindFramebuffer(_gl.FRAMEBUFFER, null);
		} // Setup storage for internal depth/stencil buffers and bind to correct framebuffer


		function setupRenderBufferStorage(renderbuffer, renderTarget, isMultisample) {
			_gl.bindRenderbuffer(_gl.RENDERBUFFER, renderbuffer);

			if (renderTarget.depthBuffer && !renderTarget.stencilBuffer) {
				var glInternalFormat = _gl.DEPTH_COMPONENT16;

				if (isMultisample) {
					var depthTexture = renderTarget.depthTexture;

					if (depthTexture && depthTexture.isDepthTexture) {
						if (depthTexture.type === FloatType) {
							glInternalFormat = _gl.DEPTH_COMPONENT32F;
						} else if (depthTexture.type === UnsignedIntType) {
							glInternalFormat = _gl.DEPTH_COMPONENT24;
						}
					}

					var samples = getRenderTargetSamples(renderTarget);

					_gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);
				} else {
					_gl.renderbufferStorage(_gl.RENDERBUFFER, glInternalFormat, renderTarget.width, renderTarget.height);
				}

				_gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer);
			} else if (renderTarget.depthBuffer && renderTarget.stencilBuffer) {
				if (isMultisample) {
					var _samples = getRenderTargetSamples(renderTarget);

					_gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, _samples, _gl.DEPTH24_STENCIL8, renderTarget.width, renderTarget.height);
				} else {
					_gl.renderbufferStorage(_gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height);
				}

				_gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer);
			} else {
				// Use the first texture for MRT so far
				var texture = renderTarget.isWebGLMultipleRenderTargets === true ? renderTarget.texture[0] : renderTarget.texture;
				var glFormat = utils.convert(texture.format);
				var glType = utils.convert(texture.type);

				var _glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.encoding);

				if (isMultisample) {
					var _samples2 = getRenderTargetSamples(renderTarget);

					_gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, _samples2, _glInternalFormat, renderTarget.width, renderTarget.height);
				} else {
					_gl.renderbufferStorage(_gl.RENDERBUFFER, _glInternalFormat, renderTarget.width, renderTarget.height);
				}
			}

			_gl.bindRenderbuffer(_gl.RENDERBUFFER, null);
		} // Setup resources for a Depth Texture for a FBO (needs an extension)


		function setupDepthTexture(framebuffer, renderTarget) {
			var isCube = renderTarget && renderTarget.isWebGLCubeRenderTarget;
			if (isCube) throw new Error('Depth Texture with cube render targets is not supported');
			state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);

			if (!(renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture)) {
				throw new Error('renderTarget.depthTexture must be an instance of THREE.DepthTexture');
			} // upload an empty depth texture with framebuffer size


			if (!properties.get(renderTarget.depthTexture).__webglTexture || renderTarget.depthTexture.image.width !== renderTarget.width || renderTarget.depthTexture.image.height !== renderTarget.height) {
				renderTarget.depthTexture.image.width = renderTarget.width;
				renderTarget.depthTexture.image.height = renderTarget.height;
				renderTarget.depthTexture.needsUpdate = true;
			}

			setTexture2D(renderTarget.depthTexture, 0);

			var webglDepthTexture = properties.get(renderTarget.depthTexture).__webglTexture;

			if (renderTarget.depthTexture.format === DepthFormat) {
				_gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0);
			} else if (renderTarget.depthTexture.format === DepthStencilFormat) {
				_gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0);
			} else {
				throw new Error('Unknown depthTexture format');
			}
		} // Setup GL resources for a non-texture depth buffer


		function setupDepthRenderbuffer(renderTarget) {
			var renderTargetProperties = properties.get(renderTarget);
			var isCube = renderTarget.isWebGLCubeRenderTarget === true;

			if (renderTarget.depthTexture) {
				if (isCube) throw new Error('target.depthTexture not supported in Cube render targets');
				setupDepthTexture(renderTargetProperties.__webglFramebuffer, renderTarget);
			} else {
				if (isCube) {
					renderTargetProperties.__webglDepthbuffer = [];

					for (var i = 0; i < 6; i++) {
						state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer[i]);
						renderTargetProperties.__webglDepthbuffer[i] = _gl.createRenderbuffer();
						setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer[i], renderTarget, false);
					}
				} else {
					state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer);
					renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
					setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer, renderTarget, false);
				}
			}

			state.bindFramebuffer(_gl.FRAMEBUFFER, null);
		} // Set up GL resources for the render target


		function setupRenderTarget(renderTarget) {
			var texture = renderTarget.texture;
			var renderTargetProperties = properties.get(renderTarget);
			var textureProperties = properties.get(texture);
			renderTarget.addEventListener('dispose', onRenderTargetDispose);

			if (renderTarget.isWebGLMultipleRenderTargets !== true) {
				textureProperties.__webglTexture = _gl.createTexture();
				textureProperties.__version = texture.version;
				info.memory.textures++;
			}

			var isCube = renderTarget.isWebGLCubeRenderTarget === true;
			var isMultipleRenderTargets = renderTarget.isWebGLMultipleRenderTargets === true;
			var isMultisample = renderTarget.isWebGLMultisampleRenderTarget === true;
			var isRenderTarget3D = texture.isDataTexture3D || texture.isDataTexture2DArray;
			var supportsMips = isPowerOfTwo$1(renderTarget) || isWebGL2; // Handles WebGL2 RGBFormat fallback - #18858

			if (isWebGL2 && texture.format === RGBFormat && (texture.type === FloatType || texture.type === HalfFloatType)) {
				texture.format = RGBAFormat;
				console.warn('THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.');
			} // Setup framebuffer


			if (isCube) {
				renderTargetProperties.__webglFramebuffer = [];

				for (var i = 0; i < 6; i++) {
					renderTargetProperties.__webglFramebuffer[i] = _gl.createFramebuffer();
				}
			} else {
				renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();

				if (isMultipleRenderTargets) {
					if (capabilities.drawBuffers) {
						var textures = renderTarget.texture;

						for (var _i6 = 0, il = textures.length; _i6 < il; _i6++) {
							var attachmentProperties = properties.get(textures[_i6]);

							if (attachmentProperties.__webglTexture === undefined) {
								attachmentProperties.__webglTexture = _gl.createTexture();
								info.memory.textures++;
							}
						}
					} else {
						console.warn('THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.');
					}
				} else if (isMultisample) {
					if (isWebGL2) {
						renderTargetProperties.__webglMultisampledFramebuffer = _gl.createFramebuffer();
						renderTargetProperties.__webglColorRenderbuffer = _gl.createRenderbuffer();

						_gl.bindRenderbuffer(_gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer);

						var glFormat = utils.convert(texture.format);
						var glType = utils.convert(texture.type);
						var glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.encoding);
						var samples = getRenderTargetSamples(renderTarget);

						_gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);

						state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);

						_gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer);

						_gl.bindRenderbuffer(_gl.RENDERBUFFER, null);

						if (renderTarget.depthBuffer) {
							renderTargetProperties.__webglDepthRenderbuffer = _gl.createRenderbuffer();
							setupRenderBufferStorage(renderTargetProperties.__webglDepthRenderbuffer, renderTarget, true);
						}

						state.bindFramebuffer(_gl.FRAMEBUFFER, null);
					} else {
						console.warn('THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.');
					}
				}
			} // Setup color buffer


			if (isCube) {
				state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture);
				setTextureParameters(_gl.TEXTURE_CUBE_MAP, texture, supportsMips);

				for (var _i7 = 0; _i7 < 6; _i7++) {
					setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[_i7], renderTarget, texture, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + _i7);
				}

				if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
					generateMipmap(_gl.TEXTURE_CUBE_MAP, texture, renderTarget.width, renderTarget.height);
				}

				state.unbindTexture();
			} else if (isMultipleRenderTargets) {
				var _textures = renderTarget.texture;

				for (var _i8 = 0, _il3 = _textures.length; _i8 < _il3; _i8++) {
					var attachment = _textures[_i8];

					var _attachmentProperties = properties.get(attachment);

					state.bindTexture(_gl.TEXTURE_2D, _attachmentProperties.__webglTexture);
					setTextureParameters(_gl.TEXTURE_2D, attachment, supportsMips);
					setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, attachment, _gl.COLOR_ATTACHMENT0 + _i8, _gl.TEXTURE_2D);

					if (textureNeedsGenerateMipmaps(attachment, supportsMips)) {
						generateMipmap(_gl.TEXTURE_2D, attachment, renderTarget.width, renderTarget.height);
					}
				}

				state.unbindTexture();
			} else {
				var glTextureType = _gl.TEXTURE_2D;

				if (isRenderTarget3D) {
					// Render targets containing layers, i.e: Texture 3D and 2d arrays
					if (isWebGL2) {
						var isTexture3D = texture.isDataTexture3D;
						glTextureType = isTexture3D ? _gl.TEXTURE_3D : _gl.TEXTURE_2D_ARRAY;
					} else {
						console.warn('THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2.');
					}
				}

				state.bindTexture(glTextureType, textureProperties.__webglTexture);
				setTextureParameters(glTextureType, texture, supportsMips);
				setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, texture, _gl.COLOR_ATTACHMENT0, glTextureType);

				if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
					generateMipmap(glTextureType, texture, renderTarget.width, renderTarget.height, renderTarget.depth);
				}

				state.unbindTexture();
			} // Setup depth and stencil buffers


			if (renderTarget.depthBuffer) {
				setupDepthRenderbuffer(renderTarget);
			}
		}

		function updateRenderTargetMipmap(renderTarget) {
			var supportsMips = isPowerOfTwo$1(renderTarget) || isWebGL2;
			var textures = renderTarget.isWebGLMultipleRenderTargets === true ? renderTarget.texture : [renderTarget.texture];

			for (var i = 0, il = textures.length; i < il; i++) {
				var texture = textures[i];

				if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
					var target = renderTarget.isWebGLCubeRenderTarget ? _gl.TEXTURE_CUBE_MAP : _gl.TEXTURE_2D;

					var webglTexture = properties.get(texture).__webglTexture;

					state.bindTexture(target, webglTexture);
					generateMipmap(target, texture, renderTarget.width, renderTarget.height);
					state.unbindTexture();
				}
			}
		}

		function updateMultisampleRenderTarget(renderTarget) {
			if (renderTarget.isWebGLMultisampleRenderTarget) {
				if (isWebGL2) {
					var width = renderTarget.width;
					var height = renderTarget.height;
					var mask = _gl.COLOR_BUFFER_BIT;
					if (renderTarget.depthBuffer) mask |= _gl.DEPTH_BUFFER_BIT;
					if (renderTarget.stencilBuffer) mask |= _gl.STENCIL_BUFFER_BIT;
					var renderTargetProperties = properties.get(renderTarget);
					state.bindFramebuffer(_gl.READ_FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);
					state.bindFramebuffer(_gl.DRAW_FRAMEBUFFER, renderTargetProperties.__webglFramebuffer);

					_gl.blitFramebuffer(0, 0, width, height, 0, 0, width, height, mask, _gl.NEAREST);

					state.bindFramebuffer(_gl.READ_FRAMEBUFFER, null);
					state.bindFramebuffer(_gl.DRAW_FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);
				} else {
					console.warn('THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.');
				}
			}
		}

		function getRenderTargetSamples(renderTarget) {
			return isWebGL2 && renderTarget.isWebGLMultisampleRenderTarget ? Math.min(maxSamples, renderTarget.samples) : 0;
		}

		function updateVideoTexture(texture) {
			var frame = info.render.frame; // Check the last frame we updated the VideoTexture

			if (_videoTextures.get(texture) !== frame) {
				_videoTextures.set(texture, frame);

				texture.update();
			}
		} // backwards compatibility


		var warnedTexture2D = false;
		var warnedTextureCube = false;

		function safeSetTexture2D(texture, slot) {
			if (texture && texture.isWebGLRenderTarget) {
				if (warnedTexture2D === false) {
					console.warn('THREE.WebGLTextures.safeSetTexture2D: don\'t use render targets as textures. Use their .texture property instead.');
					warnedTexture2D = true;
				}

				texture = texture.texture;
			}

			setTexture2D(texture, slot);
		}

		function safeSetTextureCube(texture, slot) {
			if (texture && texture.isWebGLCubeRenderTarget) {
				if (warnedTextureCube === false) {
					console.warn('THREE.WebGLTextures.safeSetTextureCube: don\'t use cube render targets as textures. Use their .texture property instead.');
					warnedTextureCube = true;
				}

				texture = texture.texture;
			}

			setTextureCube(texture, slot);
		} //


		this.allocateTextureUnit = allocateTextureUnit;
		this.resetTextureUnits = resetTextureUnits;
		this.setTexture2D = setTexture2D;
		this.setTexture2DArray = setTexture2DArray;
		this.setTexture3D = setTexture3D;
		this.setTextureCube = setTextureCube;
		this.setupRenderTarget = setupRenderTarget;
		this.updateRenderTargetMipmap = updateRenderTargetMipmap;
		this.updateMultisampleRenderTarget = updateMultisampleRenderTarget;
		this.safeSetTexture2D = safeSetTexture2D;
		this.safeSetTextureCube = safeSetTextureCube;
	}

	function WebGLUtils(gl, extensions, capabilities) {
		var isWebGL2 = capabilities.isWebGL2;

		function convert(p) {
			var extension;
			if (p === UnsignedByteType) return gl.UNSIGNED_BYTE;
			if (p === UnsignedShort4444Type) return gl.UNSIGNED_SHORT_4_4_4_4;
			if (p === UnsignedShort5551Type) return gl.UNSIGNED_SHORT_5_5_5_1;
			if (p === UnsignedShort565Type) return gl.UNSIGNED_SHORT_5_6_5;
			if (p === ByteType) return gl.BYTE;
			if (p === ShortType) return gl.SHORT;
			if (p === UnsignedShortType) return gl.UNSIGNED_SHORT;
			if (p === IntType) return gl.INT;
			if (p === UnsignedIntType) return gl.UNSIGNED_INT;
			if (p === FloatType) return gl.FLOAT;

			if (p === HalfFloatType) {
				if (isWebGL2) return gl.HALF_FLOAT;
				extension = extensions.get('OES_texture_half_float');

				if (extension !== null) {
					return extension.HALF_FLOAT_OES;
				} else {
					return null;
				}
			}

			if (p === AlphaFormat) return gl.ALPHA;
			if (p === RGBFormat) return gl.RGB;
			if (p === RGBAFormat) return gl.RGBA;
			if (p === LuminanceFormat) return gl.LUMINANCE;
			if (p === LuminanceAlphaFormat) return gl.LUMINANCE_ALPHA;
			if (p === DepthFormat) return gl.DEPTH_COMPONENT;
			if (p === DepthStencilFormat) return gl.DEPTH_STENCIL;
			if (p === RedFormat) return gl.RED; // WebGL2 formats.

			if (p === RedIntegerFormat) return gl.RED_INTEGER;
			if (p === RGFormat) return gl.RG;
			if (p === RGIntegerFormat) return gl.RG_INTEGER;
			if (p === RGBIntegerFormat) return gl.RGB_INTEGER;
			if (p === RGBAIntegerFormat) return gl.RGBA_INTEGER;

			if (p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format || p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format) {
				extension = extensions.get('WEBGL_compressed_texture_s3tc');

				if (extension !== null) {
					if (p === RGB_S3TC_DXT1_Format) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
					if (p === RGBA_S3TC_DXT1_Format) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
					if (p === RGBA_S3TC_DXT3_Format) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
					if (p === RGBA_S3TC_DXT5_Format) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;
				} else {
					return null;
				}
			}

			if (p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format || p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format) {
				extension = extensions.get('WEBGL_compressed_texture_pvrtc');

				if (extension !== null) {
					if (p === RGB_PVRTC_4BPPV1_Format) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
					if (p === RGB_PVRTC_2BPPV1_Format) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
					if (p === RGBA_PVRTC_4BPPV1_Format) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
					if (p === RGBA_PVRTC_2BPPV1_Format) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
				} else {
					return null;
				}
			}

			if (p === RGB_ETC1_Format) {
				extension = extensions.get('WEBGL_compressed_texture_etc1');

				if (extension !== null) {
					return extension.COMPRESSED_RGB_ETC1_WEBGL;
				} else {
					return null;
				}
			}

			if (p === RGB_ETC2_Format || p === RGBA_ETC2_EAC_Format) {
				extension = extensions.get('WEBGL_compressed_texture_etc');

				if (extension !== null) {
					if (p === RGB_ETC2_Format) return extension.COMPRESSED_RGB8_ETC2;
					if (p === RGBA_ETC2_EAC_Format) return extension.COMPRESSED_RGBA8_ETC2_EAC;
				}
			}

			if (p === RGBA_ASTC_4x4_Format || p === RGBA_ASTC_5x4_Format || p === RGBA_ASTC_5x5_Format || p === RGBA_ASTC_6x5_Format || p === RGBA_ASTC_6x6_Format || p === RGBA_ASTC_8x5_Format || p === RGBA_ASTC_8x6_Format || p === RGBA_ASTC_8x8_Format || p === RGBA_ASTC_10x5_Format || p === RGBA_ASTC_10x6_Format || p === RGBA_ASTC_10x8_Format || p === RGBA_ASTC_10x10_Format || p === RGBA_ASTC_12x10_Format || p === RGBA_ASTC_12x12_Format || p === SRGB8_ALPHA8_ASTC_4x4_Format || p === SRGB8_ALPHA8_ASTC_5x4_Format || p === SRGB8_ALPHA8_ASTC_5x5_Format || p === SRGB8_ALPHA8_ASTC_6x5_Format || p === SRGB8_ALPHA8_ASTC_6x6_Format || p === SRGB8_ALPHA8_ASTC_8x5_Format || p === SRGB8_ALPHA8_ASTC_8x6_Format || p === SRGB8_ALPHA8_ASTC_8x8_Format || p === SRGB8_ALPHA8_ASTC_10x5_Format || p === SRGB8_ALPHA8_ASTC_10x6_Format || p === SRGB8_ALPHA8_ASTC_10x8_Format || p === SRGB8_ALPHA8_ASTC_10x10_Format || p === SRGB8_ALPHA8_ASTC_12x10_Format || p === SRGB8_ALPHA8_ASTC_12x12_Format) {
				extension = extensions.get('WEBGL_compressed_texture_astc');

				if (extension !== null) {
					// TODO Complete?
					return p;
				} else {
					return null;
				}
			}

			if (p === RGBA_BPTC_Format) {
				extension = extensions.get('EXT_texture_compression_bptc');

				if (extension !== null) {
					// TODO Complete?
					return p;
				} else {
					return null;
				}
			}

			if (p === UnsignedInt248Type) {
				if (isWebGL2) return gl.UNSIGNED_INT_24_8;
				extension = extensions.get('WEBGL_depth_texture');

				if (extension !== null) {
					return extension.UNSIGNED_INT_24_8_WEBGL;
				} else {
					return null;
				}
			}
		}

		return {
			convert: convert
		};
	}

	var ArrayCamera = /*#__PURE__*/function (_PerspectiveCamera) {
		_inheritsLoose(ArrayCamera, _PerspectiveCamera);

		function ArrayCamera(array) {
			var _this;

			if (array === void 0) {
				array = [];
			}

			_this = _PerspectiveCamera.call(this) || this;
			_this.cameras = array;
			return _this;
		}

		return ArrayCamera;
	}(PerspectiveCamera);

	ArrayCamera.prototype.isArrayCamera = true;

	var Group = /*#__PURE__*/function (_Object3D) {
		_inheritsLoose(Group, _Object3D);

		function Group() {
			var _this;

			_this = _Object3D.call(this) || this;
			_this.type = 'Group';
			return _this;
		}

		return Group;
	}(Object3D);

	Group.prototype.isGroup = true;

	var _moveEvent = {
		type: 'move'
	};

	var WebXRController = /*#__PURE__*/function () {
		function WebXRController() {
			this._targetRay = null;
			this._grip = null;
			this._hand = null;
		}

		var _proto = WebXRController.prototype;

		_proto.getHandSpace = function getHandSpace() {
			if (this._hand === null) {
				this._hand = new Group();
				this._hand.matrixAutoUpdate = false;
				this._hand.visible = false;
				this._hand.joints = {};
				this._hand.inputState = {
					pinching: false
				};
			}

			return this._hand;
		};

		_proto.getTargetRaySpace = function getTargetRaySpace() {
			if (this._targetRay === null) {
				this._targetRay = new Group();
				this._targetRay.matrixAutoUpdate = false;
				this._targetRay.visible = false;
				this._targetRay.hasLinearVelocity = false;
				this._targetRay.linearVelocity = new Vector3();
				this._targetRay.hasAngularVelocity = false;
				this._targetRay.angularVelocity = new Vector3();
			}

			return this._targetRay;
		};

		_proto.getGripSpace = function getGripSpace() {
			if (this._grip === null) {
				this._grip = new Group();
				this._grip.matrixAutoUpdate = false;
				this._grip.visible = false;
				this._grip.hasLinearVelocity = false;
				this._grip.linearVelocity = new Vector3();
				this._grip.hasAngularVelocity = false;
				this._grip.angularVelocity = new Vector3();
			}

			return this._grip;
		};

		_proto.dispatchEvent = function dispatchEvent(event) {
			if (this._targetRay !== null) {
				this._targetRay.dispatchEvent(event);
			}

			if (this._grip !== null) {
				this._grip.dispatchEvent(event);
			}

			if (this._hand !== null) {
				this._hand.dispatchEvent(event);
			}

			return this;
		};

		_proto.disconnect = function disconnect(inputSource) {
			this.dispatchEvent({
				type: 'disconnected',
				data: inputSource
			});

			if (this._targetRay !== null) {
				this._targetRay.visible = false;
			}

			if (this._grip !== null) {
				this._grip.visible = false;
			}

			if (this._hand !== null) {
				this._hand.visible = false;
			}

			return this;
		};

		_proto.update = function update(inputSource, frame, referenceSpace) {
			var inputPose = null;
			var gripPose = null;
			var handPose = null;
			var targetRay = this._targetRay;
			var grip = this._grip;
			var hand = this._hand;

			if (inputSource && frame.session.visibilityState !== 'visible-blurred') {
				if (targetRay !== null) {
					inputPose = frame.getPose(inputSource.targetRaySpace, referenceSpace);

					if (inputPose !== null) {
						targetRay.matrix.fromArray(inputPose.transform.matrix);
						targetRay.matrix.decompose(targetRay.position, targetRay.rotation, targetRay.scale);

						if (inputPose.linearVelocity) {
							targetRay.hasLinearVelocity = true;
							targetRay.linearVelocity.copy(inputPose.linearVelocity);
						} else {
							targetRay.hasLinearVelocity = false;
						}

						if (inputPose.angularVelocity) {
							targetRay.hasAngularVelocity = true;
							targetRay.angularVelocity.copy(inputPose.angularVelocity);
						} else {
							targetRay.hasAngularVelocity = false;
						}

						this.dispatchEvent(_moveEvent);
					}
				}

				if (hand && inputSource.hand) {
					handPose = true;

					for (var _iterator = _createForOfIteratorHelperLoose(inputSource.hand.values()), _step; !(_step = _iterator()).done;) {
						var inputjoint = _step.value;
						// Update the joints groups with the XRJoint poses
						var jointPose = frame.getJointPose(inputjoint, referenceSpace);

						if (hand.joints[inputjoint.jointName] === undefined) {
							// The transform of this joint will be updated with the joint pose on each frame
							var _joint = new Group();

							_joint.matrixAutoUpdate = false;
							_joint.visible = false;
							hand.joints[inputjoint.jointName] = _joint; // ??

							hand.add(_joint);
						}

						var joint = hand.joints[inputjoint.jointName];

						if (jointPose !== null) {
							joint.matrix.fromArray(jointPose.transform.matrix);
							joint.matrix.decompose(joint.position, joint.rotation, joint.scale);
							joint.jointRadius = jointPose.radius;
						}

						joint.visible = jointPose !== null;
					} // Custom events
					// Check pinchz


					var indexTip = hand.joints['index-finger-tip'];
					var thumbTip = hand.joints['thumb-tip'];
					var distance = indexTip.position.distanceTo(thumbTip.position);
					var distanceToPinch = 0.02;
					var threshold = 0.005;

					if (hand.inputState.pinching && distance > distanceToPinch + threshold) {
						hand.inputState.pinching = false;
						this.dispatchEvent({
							type: 'pinchend',
							handedness: inputSource.handedness,
							target: this
						});
					} else if (!hand.inputState.pinching && distance <= distanceToPinch - threshold) {
						hand.inputState.pinching = true;
						this.dispatchEvent({
							type: 'pinchstart',
							handedness: inputSource.handedness,
							target: this
						});
					}
				} else {
					if (grip !== null && inputSource.gripSpace) {
						gripPose = frame.getPose(inputSource.gripSpace, referenceSpace);

						if (gripPose !== null) {
							grip.matrix.fromArray(gripPose.transform.matrix);
							grip.matrix.decompose(grip.position, grip.rotation, grip.scale);

							if (gripPose.linearVelocity) {
								grip.hasLinearVelocity = true;
								grip.linearVelocity.copy(gripPose.linearVelocity);
							} else {
								grip.hasLinearVelocity = false;
							}

							if (gripPose.angularVelocity) {
								grip.hasAngularVelocity = true;
								grip.angularVelocity.copy(gripPose.angularVelocity);
							} else {
								grip.hasAngularVelocity = false;
							}
						}
					}
				}
			}

			if (targetRay !== null) {
				targetRay.visible = inputPose !== null;
			}

			if (grip !== null) {
				grip.visible = gripPose !== null;
			}

			if (hand !== null) {
				hand.visible = handPose !== null;
			}

			return this;
		};

		return WebXRController;
	}();

	var WebXRManager = /*#__PURE__*/function (_EventDispatcher) {
		_inheritsLoose(WebXRManager, _EventDispatcher);

		function WebXRManager(renderer, gl) {
			var _this;

			_this = _EventDispatcher.call(this) || this;

			var scope = _assertThisInitialized(_this);

			var state = renderer.state;
			var session = null;
			var framebufferScaleFactor = 1.0;
			var referenceSpace = null;
			var referenceSpaceType = 'local-floor';
			var pose = null;
			var glBinding = null;
			var glFramebuffer = null;
			var glProjLayer = null;
			var glBaseLayer = null;
			var isMultisample = false;
			var glMultisampledFramebuffer = null;
			var glColorRenderbuffer = null;
			var glDepthRenderbuffer = null;
			var xrFrame = null;
			var depthStyle = null;
			var clearStyle = null;
			var controllers = [];
			var inputSourcesMap = new Map(); //

			var cameraL = new PerspectiveCamera();
			cameraL.layers.enable(1);
			cameraL.viewport = new Vector4();
			var cameraR = new PerspectiveCamera();
			cameraR.layers.enable(2);
			cameraR.viewport = new Vector4();
			var cameras = [cameraL, cameraR];
			var cameraVR = new ArrayCamera();
			cameraVR.layers.enable(1);
			cameraVR.layers.enable(2);
			var _currentDepthNear = null;
			var _currentDepthFar = null; //

			_this.cameraAutoUpdate = true;
			_this.enabled = false;
			_this.isPresenting = false;

			_this.getController = function (index) {
				var controller = controllers[index];

				if (controller === undefined) {
					controller = new WebXRController();
					controllers[index] = controller;
				}

				return controller.getTargetRaySpace();
			};

			_this.getControllerGrip = function (index) {
				var controller = controllers[index];

				if (controller === undefined) {
					controller = new WebXRController();
					controllers[index] = controller;
				}

				return controller.getGripSpace();
			};

			_this.getHand = function (index) {
				var controller = controllers[index];

				if (controller === undefined) {
					controller = new WebXRController();
					controllers[index] = controller;
				}

				return controller.getHandSpace();
			}; //


			function onSessionEvent(event) {
				var controller = inputSourcesMap.get(event.inputSource);

				if (controller) {
					controller.dispatchEvent({
						type: event.type,
						data: event.inputSource
					});
				}
			}

			function onSessionEnd() {
				inputSourcesMap.forEach(function (controller, inputSource) {
					controller.disconnect(inputSource);
				});
				inputSourcesMap.clear();
				_currentDepthNear = null;
				_currentDepthFar = null; // restore framebuffer/rendering state

				state.bindXRFramebuffer(null);
				renderer.setRenderTarget(renderer.getRenderTarget());
				if (glFramebuffer) gl.deleteFramebuffer(glFramebuffer);
				if (glMultisampledFramebuffer) gl.deleteFramebuffer(glMultisampledFramebuffer);
				if (glColorRenderbuffer) gl.deleteRenderbuffer(glColorRenderbuffer);
				if (glDepthRenderbuffer) gl.deleteRenderbuffer(glDepthRenderbuffer);
				glFramebuffer = null;
				glMultisampledFramebuffer = null;
				glColorRenderbuffer = null;
				glDepthRenderbuffer = null;
				glBaseLayer = null;
				glProjLayer = null;
				glBinding = null;
				session = null; //

				animation.stop();
				scope.isPresenting = false;
				scope.dispatchEvent({
					type: 'sessionend'
				});
			}

			_this.setFramebufferScaleFactor = function (value) {
				framebufferScaleFactor = value;

				if (scope.isPresenting === true) {
					console.warn('THREE.WebXRManager: Cannot change framebuffer scale while presenting.');
				}
			};

			_this.setReferenceSpaceType = function (value) {
				referenceSpaceType = value;

				if (scope.isPresenting === true) {
					console.warn('THREE.WebXRManager: Cannot change reference space type while presenting.');
				}
			};

			_this.getReferenceSpace = function () {
				return referenceSpace;
			};

			_this.getBaseLayer = function () {
				return glProjLayer !== null ? glProjLayer : glBaseLayer;
			};

			_this.getBinding = function () {
				return glBinding;
			};

			_this.getFrame = function () {
				return xrFrame;
			};

			_this.getSession = function () {
				return session;
			};

			_this.setSession = /*#__PURE__*/function () {
				var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(value) {
					var attributes, layerInit, _layerInit, depthFormat, projectionlayerInit;

					return regeneratorRuntime.wrap(function _callee$(_context) {
						while (1) {
							switch (_context.prev = _context.next) {
								case 0:
									session = value;

									if (!(session !== null)) {
										_context.next = 22;
										break;
									}

									session.addEventListener('select', onSessionEvent);
									session.addEventListener('selectstart', onSessionEvent);
									session.addEventListener('selectend', onSessionEvent);
									session.addEventListener('squeeze', onSessionEvent);
									session.addEventListener('squeezestart', onSessionEvent);
									session.addEventListener('squeezeend', onSessionEvent);
									session.addEventListener('end', onSessionEnd);
									session.addEventListener('inputsourceschange', onInputSourcesChange);
									attributes = gl.getContextAttributes();

									if (!(attributes.xrCompatible !== true)) {
										_context.next = 14;
										break;
									}

									_context.next = 14;
									return gl.makeXRCompatible();

								case 14:
									if (session.renderState.layers === undefined) {
										layerInit = {
											antialias: attributes.antialias,
											alpha: attributes.alpha,
											depth: attributes.depth,
											stencil: attributes.stencil,
											framebufferScaleFactor: framebufferScaleFactor
										};
										glBaseLayer = new XRWebGLLayer(session, gl, layerInit);
										session.updateRenderState({
											baseLayer: glBaseLayer
										});
									} else if (gl instanceof WebGLRenderingContext) {
										// Use old style webgl layer because we can't use MSAA
										// WebGL2 support.
										_layerInit = {
											antialias: true,
											alpha: attributes.alpha,
											depth: attributes.depth,
											stencil: attributes.stencil,
											framebufferScaleFactor: framebufferScaleFactor
										};
										glBaseLayer = new XRWebGLLayer(session, gl, _layerInit);
										session.updateRenderState({
											layers: [glBaseLayer]
										});
									} else {
										isMultisample = attributes.antialias;
										depthFormat = null;

										if (attributes.depth) {
											clearStyle = gl.DEPTH_BUFFER_BIT;
											if (attributes.stencil) clearStyle |= gl.STENCIL_BUFFER_BIT;
											depthStyle = attributes.stencil ? gl.DEPTH_STENCIL_ATTACHMENT : gl.DEPTH_ATTACHMENT;
											depthFormat = attributes.stencil ? gl.DEPTH24_STENCIL8 : gl.DEPTH_COMPONENT24;
										}

										projectionlayerInit = {
											colorFormat: attributes.alpha ? gl.RGBA8 : gl.RGB8,
											depthFormat: depthFormat,
											scaleFactor: framebufferScaleFactor
										};
										glBinding = new XRWebGLBinding(session, gl);
										glProjLayer = glBinding.createProjectionLayer(projectionlayerInit);
										glFramebuffer = gl.createFramebuffer();
										session.updateRenderState({
											layers: [glProjLayer]
										});

										if (isMultisample) {
											glMultisampledFramebuffer = gl.createFramebuffer();
											glColorRenderbuffer = gl.createRenderbuffer();
											gl.bindRenderbuffer(gl.RENDERBUFFER, glColorRenderbuffer);
											gl.renderbufferStorageMultisample(gl.RENDERBUFFER, 4, gl.RGBA8, glProjLayer.textureWidth, glProjLayer.textureHeight);
											state.bindFramebuffer(gl.FRAMEBUFFER, glMultisampledFramebuffer);
											gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.RENDERBUFFER, glColorRenderbuffer);
											gl.bindRenderbuffer(gl.RENDERBUFFER, null);

											if (depthFormat !== null) {
												glDepthRenderbuffer = gl.createRenderbuffer();
												gl.bindRenderbuffer(gl.RENDERBUFFER, glDepthRenderbuffer);
												gl.renderbufferStorageMultisample(gl.RENDERBUFFER, 4, depthFormat, glProjLayer.textureWidth, glProjLayer.textureHeight);
												gl.framebufferRenderbuffer(gl.FRAMEBUFFER, depthStyle, gl.RENDERBUFFER, glDepthRenderbuffer);
												gl.bindRenderbuffer(gl.RENDERBUFFER, null);
											}

											state.bindFramebuffer(gl.FRAMEBUFFER, null);
										}
									}

									_context.next = 17;
									return session.requestReferenceSpace(referenceSpaceType);

								case 17:
									referenceSpace = _context.sent;
									animation.setContext(session);
									animation.start();
									scope.isPresenting = true;
									scope.dispatchEvent({
										type: 'sessionstart'
									});

								case 22:
								case "end":
									return _context.stop();
							}
						}
					}, _callee);
				}));

				return function (_x) {
					return _ref.apply(this, arguments);
				};
			}();

			function onInputSourcesChange(event) {
				var inputSources = session.inputSources; // Assign inputSources to available controllers

				for (var i = 0; i < controllers.length; i++) {
					inputSourcesMap.set(inputSources[i], controllers[i]);
				} // Notify disconnected


				for (var _i = 0; _i < event.removed.length; _i++) {
					var inputSource = event.removed[_i];
					var controller = inputSourcesMap.get(inputSource);

					if (controller) {
						controller.dispatchEvent({
							type: 'disconnected',
							data: inputSource
						});
						inputSourcesMap.delete(inputSource);
					}
				} // Notify connected


				for (var _i2 = 0; _i2 < event.added.length; _i2++) {
					var _inputSource = event.added[_i2];

					var _controller = inputSourcesMap.get(_inputSource);

					if (_controller) {
						_controller.dispatchEvent({
							type: 'connected',
							data: _inputSource
						});
					}
				}
			} //


			var cameraLPos = new Vector3();
			var cameraRPos = new Vector3();
			/**
			 * Assumes 2 cameras that are parallel and share an X-axis, and that
			 * the cameras' projection and world matrices have already been set.
			 * And that near and far planes are identical for both cameras.
			 * Visualization of this technique: https://computergraphics.stackexchange.com/a/4765
			 */

			function setProjectionFromUnion(camera, cameraL, cameraR) {
				cameraLPos.setFromMatrixPosition(cameraL.matrixWorld);
				cameraRPos.setFromMatrixPosition(cameraR.matrixWorld);
				var ipd = cameraLPos.distanceTo(cameraRPos);
				var projL = cameraL.projectionMatrix.elements;
				var projR = cameraR.projectionMatrix.elements; // VR systems will have identical far and near planes, and
				// most likely identical top and bottom frustum extents.
				// Use the left camera for these values.

				var near = projL[14] / (projL[10] - 1);
				var far = projL[14] / (projL[10] + 1);
				var topFov = (projL[9] + 1) / projL[5];
				var bottomFov = (projL[9] - 1) / projL[5];
				var leftFov = (projL[8] - 1) / projL[0];
				var rightFov = (projR[8] + 1) / projR[0];
				var left = near * leftFov;
				var right = near * rightFov; // Calculate the new camera's position offset from the
				// left camera. xOffset should be roughly half `ipd`.

				var zOffset = ipd / (-leftFov + rightFov);
				var xOffset = zOffset * -leftFov; // TODO: Better way to apply this offset?

				cameraL.matrixWorld.decompose(camera.position, camera.quaternion, camera.scale);
				camera.translateX(xOffset);
				camera.translateZ(zOffset);
				camera.matrixWorld.compose(camera.position, camera.quaternion, camera.scale);
				camera.matrixWorldInverse.copy(camera.matrixWorld).invert(); // Find the union of the frustum values of the cameras and scale
				// the values so that the near plane's position does not change in world space,
				// although must now be relative to the new union camera.

				var near2 = near + zOffset;
				var far2 = far + zOffset;
				var left2 = left - xOffset;
				var right2 = right + (ipd - xOffset);
				var top2 = topFov * far / far2 * near2;
				var bottom2 = bottomFov * far / far2 * near2;
				camera.projectionMatrix.makePerspective(left2, right2, top2, bottom2, near2, far2);
			}

			function updateCamera(camera, parent) {
				if (parent === null) {
					camera.matrixWorld.copy(camera.matrix);
				} else {
					camera.matrixWorld.multiplyMatrices(parent.matrixWorld, camera.matrix);
				}

				camera.matrixWorldInverse.copy(camera.matrixWorld).invert();
			}

			_this.updateCamera = function (camera) {
				if (session === null) return;
				cameraVR.near = cameraR.near = cameraL.near = camera.near;
				cameraVR.far = cameraR.far = cameraL.far = camera.far;

				if (_currentDepthNear !== cameraVR.near || _currentDepthFar !== cameraVR.far) {
					// Note that the new renderState won't apply until the next frame. See #18320
					session.updateRenderState({
						depthNear: cameraVR.near,
						depthFar: cameraVR.far
					});
					_currentDepthNear = cameraVR.near;
					_currentDepthFar = cameraVR.far;
				}

				var parent = camera.parent;
				var cameras = cameraVR.cameras;
				updateCamera(cameraVR, parent);

				for (var i = 0; i < cameras.length; i++) {
					updateCamera(cameras[i], parent);
				}

				cameraVR.matrixWorld.decompose(cameraVR.position, cameraVR.quaternion, cameraVR.scale); // update user camera and its children

				camera.position.copy(cameraVR.position);
				camera.quaternion.copy(cameraVR.quaternion);
				camera.scale.copy(cameraVR.scale);
				camera.matrix.copy(cameraVR.matrix);
				camera.matrixWorld.copy(cameraVR.matrixWorld);
				var children = camera.children;

				for (var _i3 = 0, l = children.length; _i3 < l; _i3++) {
					children[_i3].updateMatrixWorld(true);
				} // update projection matrix for proper view frustum culling


				if (cameras.length === 2) {
					setProjectionFromUnion(cameraVR, cameraL, cameraR);
				} else {
					// assume single camera setup (AR)
					cameraVR.projectionMatrix.copy(cameraL.projectionMatrix);
				}
			};

			_this.getCamera = function () {
				return cameraVR;
			};

			_this.getFoveation = function () {
				if (glProjLayer !== null) {
					return glProjLayer.fixedFoveation;
				}

				if (glBaseLayer !== null) {
					return glBaseLayer.fixedFoveation;
				}

				return undefined;
			};

			_this.setFoveation = function (foveation) {
				// 0 = no foveation = full resolution
				// 1 = maximum foveation = the edges render at lower resolution
				if (glProjLayer !== null) {
					glProjLayer.fixedFoveation = foveation;
				}

				if (glBaseLayer !== null && glBaseLayer.fixedFoveation !== undefined) {
					glBaseLayer.fixedFoveation = foveation;
				}
			}; // Animation Loop


			var onAnimationFrameCallback = null;

			function onAnimationFrame(time, frame) {
				pose = frame.getViewerPose(referenceSpace);
				xrFrame = frame;

				if (pose !== null) {
					var views = pose.views;

					if (glBaseLayer !== null) {
						state.bindXRFramebuffer(glBaseLayer.framebuffer);
					}

					var cameraVRNeedsUpdate = false; // check if it's necessary to rebuild cameraVR's camera list

					if (views.length !== cameraVR.cameras.length) {
						cameraVR.cameras.length = 0;
						cameraVRNeedsUpdate = true;
					}

					for (var i = 0; i < views.length; i++) {
						var view = views[i];
						var viewport = null;

						if (glBaseLayer !== null) {
							viewport = glBaseLayer.getViewport(view);
						} else {
							var glSubImage = glBinding.getViewSubImage(glProjLayer, view);
							state.bindXRFramebuffer(glFramebuffer);

							if (glSubImage.depthStencilTexture !== undefined) {
								gl.framebufferTexture2D(gl.FRAMEBUFFER, depthStyle, gl.TEXTURE_2D, glSubImage.depthStencilTexture, 0);
							}

							gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, glSubImage.colorTexture, 0);
							viewport = glSubImage.viewport;
						}

						var camera = cameras[i];
						camera.matrix.fromArray(view.transform.matrix);
						camera.projectionMatrix.fromArray(view.projectionMatrix);
						camera.viewport.set(viewport.x, viewport.y, viewport.width, viewport.height);

						if (i === 0) {
							cameraVR.matrix.copy(camera.matrix);
						}

						if (cameraVRNeedsUpdate === true) {
							cameraVR.cameras.push(camera);
						}
					}

					if (isMultisample) {
						state.bindXRFramebuffer(glMultisampledFramebuffer);
						if (clearStyle !== null) gl.clear(clearStyle);
					}
				} //


				var inputSources = session.inputSources;

				for (var _i4 = 0; _i4 < controllers.length; _i4++) {
					var controller = controllers[_i4];
					var inputSource = inputSources[_i4];
					controller.update(inputSource, frame, referenceSpace);
				}

				if (onAnimationFrameCallback) onAnimationFrameCallback(time, frame);

				if (isMultisample) {
					var width = glProjLayer.textureWidth;
					var height = glProjLayer.textureHeight;
					state.bindFramebuffer(gl.READ_FRAMEBUFFER, glMultisampledFramebuffer);
					state.bindFramebuffer(gl.DRAW_FRAMEBUFFER, glFramebuffer); // Invalidate the depth here to avoid flush of the depth data to main memory.

					gl.invalidateFramebuffer(gl.READ_FRAMEBUFFER, [depthStyle]);
					gl.invalidateFramebuffer(gl.DRAW_FRAMEBUFFER, [depthStyle]);
					gl.blitFramebuffer(0, 0, width, height, 0, 0, width, height, gl.COLOR_BUFFER_BIT, gl.NEAREST); // Invalidate the MSAA buffer because it's not needed anymore.

					gl.invalidateFramebuffer(gl.READ_FRAMEBUFFER, [gl.COLOR_ATTACHMENT0]);
					state.bindFramebuffer(gl.READ_FRAMEBUFFER, null);
					state.bindFramebuffer(gl.DRAW_FRAMEBUFFER, null);
					state.bindFramebuffer(gl.FRAMEBUFFER, glMultisampledFramebuffer);
				}

				xrFrame = null;
			}

			var animation = new WebGLAnimation();
			animation.setAnimationLoop(onAnimationFrame);

			_this.setAnimationLoop = function (callback) {
				onAnimationFrameCallback = callback;
			};

			_this.dispose = function () {};

			return _this;
		}

		return WebXRManager;
	}(EventDispatcher);

	function WebGLMaterials(properties) {
		function refreshFogUniforms(uniforms, fog) {
			uniforms.fogColor.value.copy(fog.color);

			if (fog.isFog) {
				uniforms.fogNear.value = fog.near;
				uniforms.fogFar.value = fog.far;
			} else if (fog.isFogExp2) {
				uniforms.fogDensity.value = fog.density;
			}
		}

		function refreshMaterialUniforms(uniforms, material, pixelRatio, height, transmissionRenderTarget) {
			if (material.isMeshBasicMaterial) {
				refreshUniformsCommon(uniforms, material);
			} else if (material.isMeshLambertMaterial) {
				refreshUniformsCommon(uniforms, material);
				refreshUniformsLambert(uniforms, material);
			} else if (material.isMeshToonMaterial) {
				refreshUniformsCommon(uniforms, material);
				refreshUniformsToon(uniforms, material);
			} else if (material.isMeshPhongMaterial) {
				refreshUniformsCommon(uniforms, material);
				refreshUniformsPhong(uniforms, material);
			} else if (material.isMeshStandardMaterial) {
				refreshUniformsCommon(uniforms, material);

				if (material.isMeshPhysicalMaterial) {
					refreshUniformsPhysical(uniforms, material, transmissionRenderTarget);
				} else {
					refreshUniformsStandard(uniforms, material);
				}
			} else if (material.isMeshMatcapMaterial) {
				refreshUniformsCommon(uniforms, material);
				refreshUniformsMatcap(uniforms, material);
			} else if (material.isMeshDepthMaterial) {
				refreshUniformsCommon(uniforms, material);
				refreshUniformsDepth(uniforms, material);
			} else if (material.isMeshDistanceMaterial) {
				refreshUniformsCommon(uniforms, material);
				refreshUniformsDistance(uniforms, material);
			} else if (material.isMeshNormalMaterial) {
				refreshUniformsCommon(uniforms, material);
				refreshUniformsNormal(uniforms, material);
			} else if (material.isLineBasicMaterial) {
				refreshUniformsLine(uniforms, material);

				if (material.isLineDashedMaterial) {
					refreshUniformsDash(uniforms, material);
				}
			} else if (material.isPointsMaterial) {
				refreshUniformsPoints(uniforms, material, pixelRatio, height);
			} else if (material.isSpriteMaterial) {
				refreshUniformsSprites(uniforms, material);
			} else if (material.isShadowMaterial) {
				uniforms.color.value.copy(material.color);
				uniforms.opacity.value = material.opacity;
			} else if (material.isShaderMaterial) {
				material.uniformsNeedUpdate = false; // #15581
			}
		}

		function refreshUniformsCommon(uniforms, material) {
			uniforms.opacity.value = material.opacity;

			if (material.color) {
				uniforms.diffuse.value.copy(material.color);
			}

			if (material.emissive) {
				uniforms.emissive.value.copy(material.emissive).multiplyScalar(material.emissiveIntensity);
			}

			if (material.map) {
				uniforms.map.value = material.map;
			}

			if (material.alphaMap) {
				uniforms.alphaMap.value = material.alphaMap;
			}

			if (material.specularMap) {
				uniforms.specularMap.value = material.specularMap;
			}

			if (material.alphaTest > 0) {
				uniforms.alphaTest.value = material.alphaTest;
			}

			var envMap = properties.get(material).envMap;

			if (envMap) {
				uniforms.envMap.value = envMap;
				uniforms.flipEnvMap.value = envMap.isCubeTexture && envMap.isRenderTargetTexture === false ? -1 : 1;
				uniforms.reflectivity.value = material.reflectivity;
				uniforms.ior.value = material.ior;
				uniforms.refractionRatio.value = material.refractionRatio;

				var maxMipLevel = properties.get(envMap).__maxMipLevel;

				if (maxMipLevel !== undefined) {
					uniforms.maxMipLevel.value = maxMipLevel;
				}
			}

			if (material.lightMap) {
				uniforms.lightMap.value = material.lightMap;
				uniforms.lightMapIntensity.value = material.lightMapIntensity;
			}

			if (material.aoMap) {
				uniforms.aoMap.value = material.aoMap;
				uniforms.aoMapIntensity.value = material.aoMapIntensity;
			} // uv repeat and offset setting priorities
			// 1. color map
			// 2. specular map
			// 3. displacementMap map
			// 4. normal map
			// 5. bump map
			// 6. roughnessMap map
			// 7. metalnessMap map
			// 8. alphaMap map
			// 9. emissiveMap map
			// 10. clearcoat map
			// 11. clearcoat normal map
			// 12. clearcoat roughnessMap map
			// 13. specular intensity map
			// 14. specular tint map
			// 15. transmission map
			// 16. thickness map


			var uvScaleMap;

			if (material.map) {
				uvScaleMap = material.map;
			} else if (material.specularMap) {
				uvScaleMap = material.specularMap;
			} else if (material.displacementMap) {
				uvScaleMap = material.displacementMap;
			} else if (material.normalMap) {
				uvScaleMap = material.normalMap;
			} else if (material.bumpMap) {
				uvScaleMap = material.bumpMap;
			} else if (material.roughnessMap) {
				uvScaleMap = material.roughnessMap;
			} else if (material.metalnessMap) {
				uvScaleMap = material.metalnessMap;
			} else if (material.alphaMap) {
				uvScaleMap = material.alphaMap;
			} else if (material.emissiveMap) {
				uvScaleMap = material.emissiveMap;
			} else if (material.clearcoatMap) {
				uvScaleMap = material.clearcoatMap;
			} else if (material.clearcoatNormalMap) {
				uvScaleMap = material.clearcoatNormalMap;
			} else if (material.clearcoatRoughnessMap) {
				uvScaleMap = material.clearcoatRoughnessMap;
			} else if (material.specularIntensityMap) {
				uvScaleMap = material.specularIntensityMap;
			} else if (material.specularTintMap) {
				uvScaleMap = material.specularTintMap;
			} else if (material.transmissionMap) {
				uvScaleMap = material.transmissionMap;
			} else if (material.thicknessMap) {
				uvScaleMap = material.thicknessMap;
			}

			if (uvScaleMap !== undefined) {
				// backwards compatibility
				if (uvScaleMap.isWebGLRenderTarget) {
					uvScaleMap = uvScaleMap.texture;
				}

				if (uvScaleMap.matrixAutoUpdate === true) {
					uvScaleMap.updateMatrix();
				}

				uniforms.uvTransform.value.copy(uvScaleMap.matrix);
			} // uv repeat and offset setting priorities for uv2
			// 1. ao map
			// 2. light map


			var uv2ScaleMap;

			if (material.aoMap) {
				uv2ScaleMap = material.aoMap;
			} else if (material.lightMap) {
				uv2ScaleMap = material.lightMap;
			}

			if (uv2ScaleMap !== undefined) {
				// backwards compatibility
				if (uv2ScaleMap.isWebGLRenderTarget) {
					uv2ScaleMap = uv2ScaleMap.texture;
				}

				if (uv2ScaleMap.matrixAutoUpdate === true) {
					uv2ScaleMap.updateMatrix();
				}

				uniforms.uv2Transform.value.copy(uv2ScaleMap.matrix);
			}
		}

		function refreshUniformsLine(uniforms, material) {
			uniforms.diffuse.value.copy(material.color);
			uniforms.opacity.value = material.opacity;
		}

		function refreshUniformsDash(uniforms, material) {
			uniforms.dashSize.value = material.dashSize;
			uniforms.totalSize.value = material.dashSize + material.gapSize;
			uniforms.scale.value = material.scale;
		}

		function refreshUniformsPoints(uniforms, material, pixelRatio, height) {
			uniforms.diffuse.value.copy(material.color);
			uniforms.opacity.value = material.opacity;
			uniforms.size.value = material.size * pixelRatio;
			uniforms.scale.value = height * 0.5;

			if (material.map) {
				uniforms.map.value = material.map;
			}

			if (material.alphaMap) {
				uniforms.alphaMap.value = material.alphaMap;
			}

			if (material.alphaTest > 0) {
				uniforms.alphaTest.value = material.alphaTest;
			} // uv repeat and offset setting priorities
			// 1. color map
			// 2. alpha map


			var uvScaleMap;

			if (material.map) {
				uvScaleMap = material.map;
			} else if (material.alphaMap) {
				uvScaleMap = material.alphaMap;
			}

			if (uvScaleMap !== undefined) {
				if (uvScaleMap.matrixAutoUpdate === true) {
					uvScaleMap.updateMatrix();
				}

				uniforms.uvTransform.value.copy(uvScaleMap.matrix);
			}
		}

		function refreshUniformsSprites(uniforms, material) {
			uniforms.diffuse.value.copy(material.color);
			uniforms.opacity.value = material.opacity;
			uniforms.rotation.value = material.rotation;

			if (material.map) {
				uniforms.map.value = material.map;
			}

			if (material.alphaMap) {
				uniforms.alphaMap.value = material.alphaMap;
			}

			if (material.alphaTest > 0) {
				uniforms.alphaTest.value = material.alphaTest;
			} // uv repeat and offset setting priorities
			// 1. color map
			// 2. alpha map


			var uvScaleMap;

			if (material.map) {
				uvScaleMap = material.map;
			} else if (material.alphaMap) {
				uvScaleMap = material.alphaMap;
			}

			if (uvScaleMap !== undefined) {
				if (uvScaleMap.matrixAutoUpdate === true) {
					uvScaleMap.updateMatrix();
				}

				uniforms.uvTransform.value.copy(uvScaleMap.matrix);
			}
		}

		function refreshUniformsLambert(uniforms, material) {
			if (material.emissiveMap) {
				uniforms.emissiveMap.value = material.emissiveMap;
			}
		}

		function refreshUniformsPhong(uniforms, material) {
			uniforms.specular.value.copy(material.specular);
			uniforms.shininess.value = Math.max(material.shininess, 1e-4); // to prevent pow( 0.0, 0.0 )

			if (material.emissiveMap) {
				uniforms.emissiveMap.value = material.emissiveMap;
			}

			if (material.bumpMap) {
				uniforms.bumpMap.value = material.bumpMap;
				uniforms.bumpScale.value = material.bumpScale;
				if (material.side === BackSide) uniforms.bumpScale.value *= -1;
			}

			if (material.normalMap) {
				uniforms.normalMap.value = material.normalMap;
				uniforms.normalScale.value.copy(material.normalScale);
				if (material.side === BackSide) uniforms.normalScale.value.negate();
			}

			if (material.displacementMap) {
				uniforms.displacementMap.value = material.displacementMap;
				uniforms.displacementScale.value = material.displacementScale;
				uniforms.displacementBias.value = material.displacementBias;
			}
		}

		function refreshUniformsToon(uniforms, material) {
			if (material.gradientMap) {
				uniforms.gradientMap.value = material.gradientMap;
			}

			if (material.emissiveMap) {
				uniforms.emissiveMap.value = material.emissiveMap;
			}

			if (material.bumpMap) {
				uniforms.bumpMap.value = material.bumpMap;
				uniforms.bumpScale.value = material.bumpScale;
				if (material.side === BackSide) uniforms.bumpScale.value *= -1;
			}

			if (material.normalMap) {
				uniforms.normalMap.value = material.normalMap;
				uniforms.normalScale.value.copy(material.normalScale);
				if (material.side === BackSide) uniforms.normalScale.value.negate();
			}

			if (material.displacementMap) {
				uniforms.displacementMap.value = material.displacementMap;
				uniforms.displacementScale.value = material.displacementScale;
				uniforms.displacementBias.value = material.displacementBias;
			}
		}

		function refreshUniformsStandard(uniforms, material) {
			uniforms.roughness.value = material.roughness;
			uniforms.metalness.value = material.metalness;

			if (material.roughnessMap) {
				uniforms.roughnessMap.value = material.roughnessMap;
			}

			if (material.metalnessMap) {
				uniforms.metalnessMap.value = material.metalnessMap;
			}

			if (material.emissiveMap) {
				uniforms.emissiveMap.value = material.emissiveMap;
			}

			if (material.bumpMap) {
				uniforms.bumpMap.value = material.bumpMap;
				uniforms.bumpScale.value = material.bumpScale;
				if (material.side === BackSide) uniforms.bumpScale.value *= -1;
			}

			if (material.normalMap) {
				uniforms.normalMap.value = material.normalMap;
				uniforms.normalScale.value.copy(material.normalScale);
				if (material.side === BackSide) uniforms.normalScale.value.negate();
			}

			if (material.displacementMap) {
				uniforms.displacementMap.value = material.displacementMap;
				uniforms.displacementScale.value = material.displacementScale;
				uniforms.displacementBias.value = material.displacementBias;
			}

			var envMap = properties.get(material).envMap;

			if (envMap) {
				//uniforms.envMap.value = material.envMap; // part of uniforms common
				uniforms.envMapIntensity.value = material.envMapIntensity;
			}
		}

		function refreshUniformsPhysical(uniforms, material, transmissionRenderTarget) {
			refreshUniformsStandard(uniforms, material);
			uniforms.ior.value = material.ior; // also part of uniforms common

			if (material.sheen > 0) {
				uniforms.sheenTint.value.copy(material.sheenTint).multiplyScalar(material.sheen);
				uniforms.sheenRoughness.value = material.sheenRoughness;
			}

			if (material.clearcoat > 0) {
				uniforms.clearcoat.value = material.clearcoat;
				uniforms.clearcoatRoughness.value = material.clearcoatRoughness;

				if (material.clearcoatMap) {
					uniforms.clearcoatMap.value = material.clearcoatMap;
				}

				if (material.clearcoatRoughnessMap) {
					uniforms.clearcoatRoughnessMap.value = material.clearcoatRoughnessMap;
				}

				if (material.clearcoatNormalMap) {
					uniforms.clearcoatNormalScale.value.copy(material.clearcoatNormalScale);
					uniforms.clearcoatNormalMap.value = material.clearcoatNormalMap;

					if (material.side === BackSide) {
						uniforms.clearcoatNormalScale.value.negate();
					}
				}
			}

			if (material.transmission > 0) {
				uniforms.transmission.value = material.transmission;
				uniforms.transmissionSamplerMap.value = transmissionRenderTarget.texture;
				uniforms.transmissionSamplerSize.value.set(transmissionRenderTarget.width, transmissionRenderTarget.height);

				if (material.transmissionMap) {
					uniforms.transmissionMap.value = material.transmissionMap;
				}

				uniforms.thickness.value = material.thickness;

				if (material.thicknessMap) {
					uniforms.thicknessMap.value = material.thicknessMap;
				}

				uniforms.attenuationDistance.value = material.attenuationDistance;
				uniforms.attenuationTint.value.copy(material.attenuationTint);
			}

			uniforms.specularIntensity.value = material.specularIntensity;
			uniforms.specularTint.value.copy(material.specularTint);

			if (material.specularIntensityMap) {
				uniforms.specularIntensityMap.value = material.specularIntensityMap;
			}

			if (material.specularTintMap) {
				uniforms.specularTintMap.value = material.specularTintMap;
			}
		}

		function refreshUniformsMatcap(uniforms, material) {
			if (material.matcap) {
				uniforms.matcap.value = material.matcap;
			}

			if (material.bumpMap) {
				uniforms.bumpMap.value = material.bumpMap;
				uniforms.bumpScale.value = material.bumpScale;
				if (material.side === BackSide) uniforms.bumpScale.value *= -1;
			}

			if (material.normalMap) {
				uniforms.normalMap.value = material.normalMap;
				uniforms.normalScale.value.copy(material.normalScale);
				if (material.side === BackSide) uniforms.normalScale.value.negate();
			}

			if (material.displacementMap) {
				uniforms.displacementMap.value = material.displacementMap;
				uniforms.displacementScale.value = material.displacementScale;
				uniforms.displacementBias.value = material.displacementBias;
			}
		}

		function refreshUniformsDepth(uniforms, material) {
			if (material.displacementMap) {
				uniforms.displacementMap.value = material.displacementMap;
				uniforms.displacementScale.value = material.displacementScale;
				uniforms.displacementBias.value = material.displacementBias;
			}
		}

		function refreshUniformsDistance(uniforms, material) {
			if (material.displacementMap) {
				uniforms.displacementMap.value = material.displacementMap;
				uniforms.displacementScale.value = material.displacementScale;
				uniforms.displacementBias.value = material.displacementBias;
			}

			uniforms.referencePosition.value.copy(material.referencePosition);
			uniforms.nearDistance.value = material.nearDistance;
			uniforms.farDistance.value = material.farDistance;
		}

		function refreshUniformsNormal(uniforms, material) {
			if (material.bumpMap) {
				uniforms.bumpMap.value = material.bumpMap;
				uniforms.bumpScale.value = material.bumpScale;
				if (material.side === BackSide) uniforms.bumpScale.value *= -1;
			}

			if (material.normalMap) {
				uniforms.normalMap.value = material.normalMap;
				uniforms.normalScale.value.copy(material.normalScale);
				if (material.side === BackSide) uniforms.normalScale.value.negate();
			}

			if (material.displacementMap) {
				uniforms.displacementMap.value = material.displacementMap;
				uniforms.displacementScale.value = material.displacementScale;
				uniforms.displacementBias.value = material.displacementBias;
			}
		}

		return {
			refreshFogUniforms: refreshFogUniforms,
			refreshMaterialUniforms: refreshMaterialUniforms
		};
	}

	function createCanvasElement() {
		var canvas = createElementNS('canvas');
		canvas.style.display = 'block';
		return canvas;
	}

	function WebGLRenderer(parameters) {
		if (parameters === void 0) {
			parameters = {};
		}

		var _canvas = parameters.canvas !== undefined ? parameters.canvas : createCanvasElement(),
				_context = parameters.context !== undefined ? parameters.context : null,
				_alpha = parameters.alpha !== undefined ? parameters.alpha : false,
				_depth = parameters.depth !== undefined ? parameters.depth : true,
				_stencil = parameters.stencil !== undefined ? parameters.stencil : true,
				_antialias = parameters.antialias !== undefined ? parameters.antialias : false,
				_premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,
				_preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false,
				_powerPreference = parameters.powerPreference !== undefined ? parameters.powerPreference : 'default',
				_failIfMajorPerformanceCaveat = parameters.failIfMajorPerformanceCaveat !== undefined ? parameters.failIfMajorPerformanceCaveat : false;

		var currentRenderList = null;
		var currentRenderState = null; // render() can be called from within a callback triggered by another render.
		// We track this so that the nested render call gets its list and state isolated from the parent render call.

		var renderListStack = [];
		var renderStateStack = []; // public properties

		this.domElement = _canvas; // Debug configuration container

		this.debug = {
			/**
			 * Enables error checking and reporting when shader programs are being compiled
			 * @type {boolean}
			 */
			checkShaderErrors: true
		}; // clearing

		this.autoClear = true;
		this.autoClearColor = true;
		this.autoClearDepth = true;
		this.autoClearStencil = true; // scene graph

		this.sortObjects = true; // user-defined clipping

		this.clippingPlanes = [];
		this.localClippingEnabled = false; // physically based shading

		this.gammaFactor = 2.0; // for backwards compatibility

		this.outputEncoding = LinearEncoding; // physical lights

		this.physicallyCorrectLights = false; // tone mapping

		this.toneMapping = NoToneMapping;
		this.toneMappingExposure = 1.0; // internal properties

		var _this = this;

		var _isContextLost = false; // internal state cache

		var _currentActiveCubeFace = 0;
		var _currentActiveMipmapLevel = 0;
		var _currentRenderTarget = null;

		var _currentMaterialId = -1;

		var _currentCamera = null;

		var _currentViewport = new Vector4();

		var _currentScissor = new Vector4();

		var _currentScissorTest = null; //

		var _width = _canvas.width;
		var _height = _canvas.height;
		var _pixelRatio = 1;
		var _opaqueSort = null;
		var _transparentSort = null;

		var _viewport = new Vector4(0, 0, _width, _height);

		var _scissor = new Vector4(0, 0, _width, _height);

		var _scissorTest = false; //

		var _currentDrawBuffers = []; // frustum

		var _frustum = new Frustum(); // clipping


		var _clippingEnabled = false;
		var _localClippingEnabled = false; // transmission

		var _transmissionRenderTarget = null; // camera matrices cache

		var _projScreenMatrix = new Matrix4();

		var _vector3 = new Vector3();

		var _emptyScene = {
			background: null,
			fog: null,
			environment: null,
			overrideMaterial: null,
			isScene: true
		};

		function getTargetPixelRatio() {
			return _currentRenderTarget === null ? _pixelRatio : 1;
		} // initialize


		var _gl = _context;

		function getContext(contextNames, contextAttributes) {
			for (var i = 0; i < contextNames.length; i++) {
				var contextName = contextNames[i];

				var context = _canvas.getContext(contextName, contextAttributes);

				if (context !== null) return context;
			}

			return null;
		}

		try {
			var contextAttributes = {
				alpha: _alpha,
				depth: _depth,
				stencil: _stencil,
				antialias: _antialias,
				premultipliedAlpha: _premultipliedAlpha,
				preserveDrawingBuffer: _preserveDrawingBuffer,
				powerPreference: _powerPreference,
				failIfMajorPerformanceCaveat: _failIfMajorPerformanceCaveat
			}; // event listeners must be registered before WebGL context is created, see #12753

			_canvas.addEventListener('webglcontextlost', onContextLost, false);

			_canvas.addEventListener('webglcontextrestored', onContextRestore, false);

			if (_gl === null) {
				var contextNames = ['webgl2', 'webgl', 'experimental-webgl'];

				if (_this.isWebGL1Renderer === true) {
					contextNames.shift();
				}

				_gl = getContext(contextNames, contextAttributes);

				if (_gl === null) {
					if (getContext(contextNames)) {
						throw new Error('Error creating WebGL context with your selected attributes.');
					} else {
						throw new Error('Error creating WebGL context.');
					}
				}
			} // Some experimental-webgl implementations do not have getShaderPrecisionFormat


			if (_gl.getShaderPrecisionFormat === undefined) {
				_gl.getShaderPrecisionFormat = function () {
					return {
						'rangeMin': 1,
						'rangeMax': 1,
						'precision': 1
					};
				};
			}
		} catch (error) {
			console.error('THREE.WebGLRenderer: ' + error.message);
			throw error;
		}

		var extensions, capabilities, state, info;
		var properties, textures, cubemaps, cubeuvmaps, attributes, geometries, objects;
		var programCache, materials, renderLists, renderStates, clipping, shadowMap;
		var background, morphtargets, bufferRenderer, indexedBufferRenderer;
		var utils, bindingStates;

		function initGLContext() {
			extensions = new WebGLExtensions(_gl);
			capabilities = new WebGLCapabilities(_gl, extensions, parameters);
			extensions.init(capabilities);
			utils = new WebGLUtils(_gl, extensions, capabilities);
			state = new WebGLState(_gl, extensions, capabilities);
			_currentDrawBuffers[0] = _gl.BACK;
			info = new WebGLInfo(_gl);
			properties = new WebGLProperties();
			textures = new WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info);
			cubemaps = new WebGLCubeMaps(_this);
			cubeuvmaps = new WebGLCubeUVMaps(_this);
			attributes = new WebGLAttributes(_gl, capabilities);
			bindingStates = new WebGLBindingStates(_gl, extensions, attributes, capabilities);
			geometries = new WebGLGeometries(_gl, attributes, info, bindingStates);
			objects = new WebGLObjects(_gl, geometries, attributes, info);
			morphtargets = new WebGLMorphtargets(_gl, capabilities, textures);
			clipping = new WebGLClipping(properties);
			programCache = new WebGLPrograms(_this, cubemaps, cubeuvmaps, extensions, capabilities, bindingStates, clipping);
			materials = new WebGLMaterials(properties);
			renderLists = new WebGLRenderLists(properties);
			renderStates = new WebGLRenderStates(extensions, capabilities);
			background = new WebGLBackground(_this, cubemaps, state, objects, _premultipliedAlpha);
			shadowMap = new WebGLShadowMap(_this, objects, capabilities);
			bufferRenderer = new WebGLBufferRenderer(_gl, extensions, info, capabilities);
			indexedBufferRenderer = new WebGLIndexedBufferRenderer(_gl, extensions, info, capabilities);
			info.programs = programCache.programs;
			_this.capabilities = capabilities;
			_this.extensions = extensions;
			_this.properties = properties;
			_this.renderLists = renderLists;
			_this.shadowMap = shadowMap;
			_this.state = state;
			_this.info = info;
		}

		initGLContext(); // xr

		var xr = new WebXRManager(_this, _gl);
		this.xr = xr; // API

		this.getContext = function () {
			return _gl;
		};

		this.getContextAttributes = function () {
			return _gl.getContextAttributes();
		};

		this.forceContextLoss = function () {
			var extension = extensions.get('WEBGL_lose_context');
			if (extension) extension.loseContext();
		};

		this.forceContextRestore = function () {
			var extension = extensions.get('WEBGL_lose_context');
			if (extension) extension.restoreContext();
		};

		this.getPixelRatio = function () {
			return _pixelRatio;
		};

		this.setPixelRatio = function (value) {
			if (value === undefined) return;
			_pixelRatio = value;
			this.setSize(_width, _height, false);
		};

		this.getSize = function (target) {
			return target.set(_width, _height);
		};

		this.setSize = function (width, height, updateStyle) {
			if (xr.isPresenting) {
				console.warn('THREE.WebGLRenderer: Can\'t change size while VR device is presenting.');
				return;
			}

			_width = width;
			_height = height;
			_canvas.width = Math.floor(width * _pixelRatio);
			_canvas.height = Math.floor(height * _pixelRatio);

			if (updateStyle !== false) {
				_canvas.style.width = width + 'px';
				_canvas.style.height = height + 'px';
			}

			this.setViewport(0, 0, width, height);
		};

		this.getDrawingBufferSize = function (target) {
			return target.set(_width * _pixelRatio, _height * _pixelRatio).floor();
		};

		this.setDrawingBufferSize = function (width, height, pixelRatio) {
			_width = width;
			_height = height;
			_pixelRatio = pixelRatio;
			_canvas.width = Math.floor(width * pixelRatio);
			_canvas.height = Math.floor(height * pixelRatio);
			this.setViewport(0, 0, width, height);
		};

		this.getCurrentViewport = function (target) {
			return target.copy(_currentViewport);
		};

		this.getViewport = function (target) {
			return target.copy(_viewport);
		};

		this.setViewport = function (x, y, width, height) {
			if (x.isVector4) {
				_viewport.set(x.x, x.y, x.z, x.w);
			} else {
				_viewport.set(x, y, width, height);
			}

			state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor());
		};

		this.getScissor = function (target) {
			return target.copy(_scissor);
		};

		this.setScissor = function (x, y, width, height) {
			if (x.isVector4) {
				_scissor.set(x.x, x.y, x.z, x.w);
			} else {
				_scissor.set(x, y, width, height);
			}

			state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor());
		};

		this.getScissorTest = function () {
			return _scissorTest;
		};

		this.setScissorTest = function (boolean) {
			state.setScissorTest(_scissorTest = boolean);
		};

		this.setOpaqueSort = function (method) {
			_opaqueSort = method;
		};

		this.setTransparentSort = function (method) {
			_transparentSort = method;
		}; // Clearing


		this.getClearColor = function (target) {
			return target.copy(background.getClearColor());
		};

		this.setClearColor = function () {
			background.setClearColor.apply(background, arguments);
		};

		this.getClearAlpha = function () {
			return background.getClearAlpha();
		};

		this.setClearAlpha = function () {
			background.setClearAlpha.apply(background, arguments);
		};

		this.clear = function (color, depth, stencil) {
			var bits = 0;
			if (color === undefined || color) bits |= _gl.COLOR_BUFFER_BIT;
			if (depth === undefined || depth) bits |= _gl.DEPTH_BUFFER_BIT;
			if (stencil === undefined || stencil) bits |= _gl.STENCIL_BUFFER_BIT;

			_gl.clear(bits);
		};

		this.clearColor = function () {
			this.clear(true, false, false);
		};

		this.clearDepth = function () {
			this.clear(false, true, false);
		};

		this.clearStencil = function () {
			this.clear(false, false, true);
		}; //


		this.dispose = function () {
			_canvas.removeEventListener('webglcontextlost', onContextLost, false);

			_canvas.removeEventListener('webglcontextrestored', onContextRestore, false);

			renderLists.dispose();
			renderStates.dispose();
			properties.dispose();
			cubemaps.dispose();
			cubeuvmaps.dispose();
			objects.dispose();
			bindingStates.dispose();
			xr.dispose();
			xr.removeEventListener('sessionstart', onXRSessionStart);
			xr.removeEventListener('sessionend', onXRSessionEnd);

			if (_transmissionRenderTarget) {
				_transmissionRenderTarget.dispose();

				_transmissionRenderTarget = null;
			}

			animation.stop();
		}; // Events


		function onContextLost(event) {
			event.preventDefault();
			console.log('THREE.WebGLRenderer: Context Lost.');
			_isContextLost = true;
		}

		function onContextRestore()
		/* event */
		{
			console.log('THREE.WebGLRenderer: Context Restored.');
			_isContextLost = false;
			var infoAutoReset = info.autoReset;
			var shadowMapEnabled = shadowMap.enabled;
			var shadowMapAutoUpdate = shadowMap.autoUpdate;
			var shadowMapNeedsUpdate = shadowMap.needsUpdate;
			var shadowMapType = shadowMap.type;
			initGLContext();
			info.autoReset = infoAutoReset;
			shadowMap.enabled = shadowMapEnabled;
			shadowMap.autoUpdate = shadowMapAutoUpdate;
			shadowMap.needsUpdate = shadowMapNeedsUpdate;
			shadowMap.type = shadowMapType;
		}

		function onMaterialDispose(event) {
			var material = event.target;
			material.removeEventListener('dispose', onMaterialDispose);
			deallocateMaterial(material);
		} // Buffer deallocation


		function deallocateMaterial(material) {
			releaseMaterialProgramReferences(material);
			properties.remove(material);
		}

		function releaseMaterialProgramReferences(material) {
			var programs = properties.get(material).programs;

			if (programs !== undefined) {
				programs.forEach(function (program) {
					programCache.releaseProgram(program);
				});
			}
		} // Buffer rendering


		function renderObjectImmediate(object, program) {
			object.render(function (object) {
				_this.renderBufferImmediate(object, program);
			});
		}

		this.renderBufferImmediate = function (object, program) {
			bindingStates.initAttributes();
			var buffers = properties.get(object);
			if (object.hasPositions && !buffers.position) buffers.position = _gl.createBuffer();
			if (object.hasNormals && !buffers.normal) buffers.normal = _gl.createBuffer();
			if (object.hasUvs && !buffers.uv) buffers.uv = _gl.createBuffer();
			if (object.hasColors && !buffers.color) buffers.color = _gl.createBuffer();
			var programAttributes = program.getAttributes();

			if (object.hasPositions) {
				_gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.position);

				_gl.bufferData(_gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW);

				bindingStates.enableAttribute(programAttributes.position.location);

				_gl.vertexAttribPointer(programAttributes.position.location, 3, _gl.FLOAT, false, 0, 0);
			}

			if (object.hasNormals) {
				_gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.normal);

				_gl.bufferData(_gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW);

				bindingStates.enableAttribute(programAttributes.normal.location);

				_gl.vertexAttribPointer(programAttributes.normal.location, 3, _gl.FLOAT, false, 0, 0);
			}

			if (object.hasUvs) {
				_gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.uv);

				_gl.bufferData(_gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW);

				bindingStates.enableAttribute(programAttributes.uv.location);

				_gl.vertexAttribPointer(programAttributes.uv.location, 2, _gl.FLOAT, false, 0, 0);
			}

			if (object.hasColors) {
				_gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.color);

				_gl.bufferData(_gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW);

				bindingStates.enableAttribute(programAttributes.color.location);

				_gl.vertexAttribPointer(programAttributes.color.location, 3, _gl.FLOAT, false, 0, 0);
			}

			bindingStates.disableUnusedAttributes();

			_gl.drawArrays(_gl.TRIANGLES, 0, object.count);

			object.count = 0;
		};

		this.renderBufferDirect = function (camera, scene, geometry, material, object, group) {
			if (scene === null) scene = _emptyScene; // renderBufferDirect second parameter used to be fog (could be null)

			var frontFaceCW = object.isMesh && object.matrixWorld.determinant() < 0;
			var program = setProgram(camera, scene, geometry, material, object);
			state.setMaterial(material, frontFaceCW); //

			var index = geometry.index;
			var position = geometry.attributes.position; //

			if (index === null) {
				if (position === undefined || position.count === 0) return;
			} else if (index.count === 0) {
				return;
			} //


			var rangeFactor = 1;

			if (material.wireframe === true) {
				index = geometries.getWireframeAttribute(geometry);
				rangeFactor = 2;
			}

			bindingStates.setup(object, material, program, geometry, index);
			var attribute;
			var renderer = bufferRenderer;

			if (index !== null) {
				attribute = attributes.get(index);
				renderer = indexedBufferRenderer;
				renderer.setIndex(attribute);
			} //


			var dataCount = index !== null ? index.count : position.count;
			var rangeStart = geometry.drawRange.start * rangeFactor;
			var rangeCount = geometry.drawRange.count * rangeFactor;
			var groupStart = group !== null ? group.start * rangeFactor : 0;
			var groupCount = group !== null ? group.count * rangeFactor : Infinity;
			var drawStart = Math.max(rangeStart, groupStart);
			var drawEnd = Math.min(dataCount, rangeStart + rangeCount, groupStart + groupCount) - 1;
			var drawCount = Math.max(0, drawEnd - drawStart + 1);
			if (drawCount === 0) return; //

			if (object.isMesh) {
				if (material.wireframe === true) {
					state.setLineWidth(material.wireframeLinewidth * getTargetPixelRatio());
					renderer.setMode(_gl.LINES);
				} else {
					renderer.setMode(_gl.TRIANGLES);
				}
			} else if (object.isLine) {
				var lineWidth = material.linewidth;
				if (lineWidth === undefined) lineWidth = 1; // Not using Line*Material

				state.setLineWidth(lineWidth * getTargetPixelRatio());

				if (object.isLineSegments) {
					renderer.setMode(_gl.LINES);
				} else if (object.isLineLoop) {
					renderer.setMode(_gl.LINE_LOOP);
				} else {
					renderer.setMode(_gl.LINE_STRIP);
				}
			} else if (object.isPoints) {
				renderer.setMode(_gl.POINTS);
			} else if (object.isSprite) {
				renderer.setMode(_gl.TRIANGLES);
			}

			if (object.isInstancedMesh) {
				renderer.renderInstances(drawStart, drawCount, object.count);
			} else if (geometry.isInstancedBufferGeometry) {
				var instanceCount = Math.min(geometry.instanceCount, geometry._maxInstanceCount);
				renderer.renderInstances(drawStart, drawCount, instanceCount);
			} else {
				renderer.render(drawStart, drawCount);
			}
		}; // Compile


		this.compile = function (scene, camera) {
			currentRenderState = renderStates.get(scene);
			currentRenderState.init();
			renderStateStack.push(currentRenderState);
			scene.traverseVisible(function (object) {
				if (object.isLight && object.layers.test(camera.layers)) {
					currentRenderState.pushLight(object);

					if (object.castShadow) {
						currentRenderState.pushShadow(object);
					}
				}
			});
			currentRenderState.setupLights(_this.physicallyCorrectLights);
			scene.traverse(function (object) {
				var material = object.material;

				if (material) {
					if (Array.isArray(material)) {
						for (var i = 0; i < material.length; i++) {
							var material2 = material[i];
							getProgram(material2, scene, object);
						}
					} else {
						getProgram(material, scene, object);
					}
				}
			});
			renderStateStack.pop();
			currentRenderState = null;
		}; // Animation Loop


		var onAnimationFrameCallback = null;

		function onAnimationFrame(time) {
			if (onAnimationFrameCallback) onAnimationFrameCallback(time);
		}

		function onXRSessionStart() {
			animation.stop();
		}

		function onXRSessionEnd() {
			animation.start();
		}

		var animation = new WebGLAnimation();
		animation.setAnimationLoop(onAnimationFrame);
		if (typeof window !== 'undefined') animation.setContext(window);

		this.setAnimationLoop = function (callback) {
			onAnimationFrameCallback = callback;
			xr.setAnimationLoop(callback);
			callback === null ? animation.stop() : animation.start();
		};

		xr.addEventListener('sessionstart', onXRSessionStart);
		xr.addEventListener('sessionend', onXRSessionEnd); // Rendering

		this.render = function (scene, camera) {
			if (camera !== undefined && camera.isCamera !== true) {
				console.error('THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.');
				return;
			}

			if (_isContextLost === true) return; // update scene graph

			if (scene.autoUpdate === true) scene.updateMatrixWorld(); // update camera matrices and frustum

			if (camera.parent === null) camera.updateMatrixWorld();

			if (xr.enabled === true && xr.isPresenting === true) {
				if (xr.cameraAutoUpdate === true) xr.updateCamera(camera);
				camera = xr.getCamera(); // use XR camera for rendering
			} //


			if (scene.isScene === true) scene.onBeforeRender(_this, scene, camera, _currentRenderTarget);
			currentRenderState = renderStates.get(scene, renderStateStack.length);
			currentRenderState.init();
			renderStateStack.push(currentRenderState);

			_projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);

			_frustum.setFromProjectionMatrix(_projScreenMatrix);

			_localClippingEnabled = this.localClippingEnabled;
			_clippingEnabled = clipping.init(this.clippingPlanes, _localClippingEnabled, camera);
			currentRenderList = renderLists.get(scene, renderListStack.length);
			currentRenderList.init();
			renderListStack.push(currentRenderList);
			projectObject(scene, camera, 0, _this.sortObjects);
			currentRenderList.finish();

			if (_this.sortObjects === true) {
				currentRenderList.sort(_opaqueSort, _transparentSort);
			} //


			if (_clippingEnabled === true) clipping.beginShadows();
			var shadowsArray = currentRenderState.state.shadowsArray;
			shadowMap.render(shadowsArray, scene, camera);
			if (_clippingEnabled === true) clipping.endShadows(); //

			if (this.info.autoReset === true) this.info.reset(); //

			background.render(currentRenderList, scene); // render scene

			currentRenderState.setupLights(_this.physicallyCorrectLights);

			if (camera.isArrayCamera) {
				var cameras = camera.cameras;

				for (var i = 0, l = cameras.length; i < l; i++) {
					var camera2 = cameras[i];
					renderScene(currentRenderList, scene, camera2, camera2.viewport);
				}
			} else {
				renderScene(currentRenderList, scene, camera);
			} //


			if (_currentRenderTarget !== null) {
				// resolve multisample renderbuffers to a single-sample texture if necessary
				textures.updateMultisampleRenderTarget(_currentRenderTarget); // Generate mipmap if we're using any kind of mipmap filtering

				textures.updateRenderTargetMipmap(_currentRenderTarget);
			} //


			if (scene.isScene === true) scene.onAfterRender(_this, scene, camera); // Ensure depth buffer writing is enabled so it can be cleared on next render

			state.buffers.depth.setTest(true);
			state.buffers.depth.setMask(true);
			state.buffers.color.setMask(true);
			state.setPolygonOffset(false); // _gl.finish();

			bindingStates.resetDefaultState();
			_currentMaterialId = -1;
			_currentCamera = null;
			renderStateStack.pop();

			if (renderStateStack.length > 0) {
				currentRenderState = renderStateStack[renderStateStack.length - 1];
			} else {
				currentRenderState = null;
			}

			renderListStack.pop();

			if (renderListStack.length > 0) {
				currentRenderList = renderListStack[renderListStack.length - 1];
			} else {
				currentRenderList = null;
			}
		};

		function projectObject(object, camera, groupOrder, sortObjects) {
			if (object.visible === false) return;
			var visible = object.layers.test(camera.layers);

			if (visible) {
				if (object.isGroup) {
					groupOrder = object.renderOrder;
				} else if (object.isLOD) {
					if (object.autoUpdate === true) object.update(camera);
				} else if (object.isLight) {
					currentRenderState.pushLight(object);

					if (object.castShadow) {
						currentRenderState.pushShadow(object);
					}
				} else if (object.isSprite) {
					if (!object.frustumCulled || _frustum.intersectsSprite(object)) {
						if (sortObjects) {
							_vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);
						}

						var geometry = objects.update(object);
						var material = object.material;

						if (material.visible) {
							currentRenderList.push(object, geometry, material, groupOrder, _vector3.z, null);
						}
					}
				} else if (object.isImmediateRenderObject) {
					if (sortObjects) {
						_vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);
					}

					currentRenderList.push(object, null, object.material, groupOrder, _vector3.z, null);
				} else if (object.isMesh || object.isLine || object.isPoints) {
					if (object.isSkinnedMesh) {
						// update skeleton only once in a frame
						if (object.skeleton.frame !== info.render.frame) {
							object.skeleton.update();
							object.skeleton.frame = info.render.frame;
						}
					}

					if (!object.frustumCulled || _frustum.intersectsObject(object)) {
						if (sortObjects) {
							_vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);
						}

						var _geometry = objects.update(object);

						var _material = object.material;

						if (Array.isArray(_material)) {
							var groups = _geometry.groups;

							for (var i = 0, l = groups.length; i < l; i++) {
								var group = groups[i];
								var groupMaterial = _material[group.materialIndex];

								if (groupMaterial && groupMaterial.visible) {
									currentRenderList.push(object, _geometry, groupMaterial, groupOrder, _vector3.z, group);
								}
							}
						} else if (_material.visible) {
							currentRenderList.push(object, _geometry, _material, groupOrder, _vector3.z, null);
						}
					}
				}
			}

			var children = object.children;

			for (var _i = 0, _l = children.length; _i < _l; _i++) {
				projectObject(children[_i], camera, groupOrder, sortObjects);
			}
		}

		function renderScene(currentRenderList, scene, camera, viewport) {
			var opaqueObjects = currentRenderList.opaque;
			var transmissiveObjects = currentRenderList.transmissive;
			var transparentObjects = currentRenderList.transparent;
			currentRenderState.setupLightsView(camera);
			if (transmissiveObjects.length > 0) renderTransmissionPass(opaqueObjects, scene, camera);
			if (viewport) state.viewport(_currentViewport.copy(viewport));
			if (opaqueObjects.length > 0) renderObjects(opaqueObjects, scene, camera);
			if (transmissiveObjects.length > 0) renderObjects(transmissiveObjects, scene, camera);
			if (transparentObjects.length > 0) renderObjects(transparentObjects, scene, camera);
		}

		function renderTransmissionPass(opaqueObjects, scene, camera) {
			if (_transmissionRenderTarget === null) {
				var needsAntialias = _antialias === true && capabilities.isWebGL2 === true;
				var renderTargetType = needsAntialias ? WebGLMultisampleRenderTarget : WebGLRenderTarget;
				_transmissionRenderTarget = new renderTargetType(1024, 1024, {
					generateMipmaps: true,
					type: utils.convert(HalfFloatType) !== null ? HalfFloatType : UnsignedByteType,
					minFilter: LinearMipmapLinearFilter,
					magFilter: NearestFilter,
					wrapS: ClampToEdgeWrapping,
					wrapT: ClampToEdgeWrapping
				});
			}

			var currentRenderTarget = _this.getRenderTarget();

			_this.setRenderTarget(_transmissionRenderTarget);

			_this.clear(); // Turn off the features which can affect the frag color for opaque objects pass.
			// Otherwise they are applied twice in opaque objects pass and transmission objects pass.


			var currentToneMapping = _this.toneMapping;
			_this.toneMapping = NoToneMapping;
			renderObjects(opaqueObjects, scene, camera);
			_this.toneMapping = currentToneMapping;
			textures.updateMultisampleRenderTarget(_transmissionRenderTarget);
			textures.updateRenderTargetMipmap(_transmissionRenderTarget);

			_this.setRenderTarget(currentRenderTarget);
		}

		function renderObjects(renderList, scene, camera) {
			var overrideMaterial = scene.isScene === true ? scene.overrideMaterial : null;

			for (var i = 0, l = renderList.length; i < l; i++) {
				var renderItem = renderList[i];
				var object = renderItem.object;
				var geometry = renderItem.geometry;
				var material = overrideMaterial === null ? renderItem.material : overrideMaterial;
				var group = renderItem.group;

				if (object.layers.test(camera.layers)) {
					renderObject(object, scene, camera, geometry, material, group);
				}
			}
		}

		function renderObject(object, scene, camera, geometry, material, group) {
			object.onBeforeRender(_this, scene, camera, geometry, material, group);
			object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);
			object.normalMatrix.getNormalMatrix(object.modelViewMatrix);
			material.onBeforeRender(_this, scene, camera, geometry, object, group);

			if (object.isImmediateRenderObject) {
				var program = setProgram(camera, scene, geometry, material, object);
				state.setMaterial(material);
				bindingStates.reset();
				renderObjectImmediate(object, program);
			} else {
				if (material.transparent === true && material.side === DoubleSide) {
					material.side = BackSide;
					material.needsUpdate = true;

					_this.renderBufferDirect(camera, scene, geometry, material, object, group);

					material.side = FrontSide;
					material.needsUpdate = true;

					_this.renderBufferDirect(camera, scene, geometry, material, object, group);

					material.side = DoubleSide;
				} else {
					_this.renderBufferDirect(camera, scene, geometry, material, object, group);
				}
			}

			object.onAfterRender(_this, scene, camera, geometry, material, group);
		}

		function getProgram(material, scene, object) {
			if (scene.isScene !== true) scene = _emptyScene; // scene could be a Mesh, Line, Points, ...

			var materialProperties = properties.get(material);
			var lights = currentRenderState.state.lights;
			var shadowsArray = currentRenderState.state.shadowsArray;
			var lightsStateVersion = lights.state.version;
			var parameters = programCache.getParameters(material, lights.state, shadowsArray, scene, object);
			var programCacheKey = programCache.getProgramCacheKey(parameters);
			var programs = materialProperties.programs; // always update environment and fog - changing these trigger an getProgram call, but it's possible that the program doesn't change

			materialProperties.environment = material.isMeshStandardMaterial ? scene.environment : null;
			materialProperties.fog = scene.fog;
			materialProperties.envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || materialProperties.environment);

			if (programs === undefined) {
				// new material
				material.addEventListener('dispose', onMaterialDispose);
				programs = new Map();
				materialProperties.programs = programs;
			}

			var program = programs.get(programCacheKey);

			if (program !== undefined) {
				// early out if program and light state is identical
				if (materialProperties.currentProgram === program && materialProperties.lightsStateVersion === lightsStateVersion) {
					updateCommonMaterialProperties(material, parameters);
					return program;
				}
			} else {
				parameters.uniforms = programCache.getUniforms(material);
				material.onBuild(parameters, _this);
				material.onBeforeCompile(parameters, _this);
				program = programCache.acquireProgram(parameters, programCacheKey);
				programs.set(programCacheKey, program);
				materialProperties.uniforms = parameters.uniforms;
			}

			var uniforms = materialProperties.uniforms;

			if (!material.isShaderMaterial && !material.isRawShaderMaterial || material.clipping === true) {
				uniforms.clippingPlanes = clipping.uniform;
			}

			updateCommonMaterialProperties(material, parameters); // store the light setup it was created for

			materialProperties.needsLights = materialNeedsLights(material);
			materialProperties.lightsStateVersion = lightsStateVersion;

			if (materialProperties.needsLights) {
				// wire up the material to this renderer's lighting state
				uniforms.ambientLightColor.value = lights.state.ambient;
				uniforms.lightProbe.value = lights.state.probe;
				uniforms.directionalLights.value = lights.state.directional;
				uniforms.directionalLightShadows.value = lights.state.directionalShadow;
				uniforms.spotLights.value = lights.state.spot;
				uniforms.spotLightShadows.value = lights.state.spotShadow;
				uniforms.rectAreaLights.value = lights.state.rectArea;
				uniforms.ltc_1.value = lights.state.rectAreaLTC1;
				uniforms.ltc_2.value = lights.state.rectAreaLTC2;
				uniforms.pointLights.value = lights.state.point;
				uniforms.pointLightShadows.value = lights.state.pointShadow;
				uniforms.hemisphereLights.value = lights.state.hemi;
				uniforms.directionalShadowMap.value = lights.state.directionalShadowMap;
				uniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;
				uniforms.spotShadowMap.value = lights.state.spotShadowMap;
				uniforms.spotShadowMatrix.value = lights.state.spotShadowMatrix;
				uniforms.pointShadowMap.value = lights.state.pointShadowMap;
				uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix; // TODO (abelnation): add area lights shadow info to uniforms
			}

			var progUniforms = program.getUniforms();
			var uniformsList = WebGLUniforms.seqWithValue(progUniforms.seq, uniforms);
			materialProperties.currentProgram = program;
			materialProperties.uniformsList = uniformsList;
			return program;
		}

		function updateCommonMaterialProperties(material, parameters) {
			var materialProperties = properties.get(material);
			materialProperties.outputEncoding = parameters.outputEncoding;
			materialProperties.instancing = parameters.instancing;
			materialProperties.skinning = parameters.skinning;
			materialProperties.morphTargets = parameters.morphTargets;
			materialProperties.morphNormals = parameters.morphNormals;
			materialProperties.morphTargetsCount = parameters.morphTargetsCount;
			materialProperties.numClippingPlanes = parameters.numClippingPlanes;
			materialProperties.numIntersection = parameters.numClipIntersection;
			materialProperties.vertexAlphas = parameters.vertexAlphas;
			materialProperties.vertexTangents = parameters.vertexTangents;
		}

		function setProgram(camera, scene, geometry, material, object) {
			if (scene.isScene !== true) scene = _emptyScene; // scene could be a Mesh, Line, Points, ...

			textures.resetTextureUnits();
			var fog = scene.fog;
			var environment = material.isMeshStandardMaterial ? scene.environment : null;
			var encoding = _currentRenderTarget === null ? _this.outputEncoding : _currentRenderTarget.texture.encoding;
			var envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || environment);
			var vertexAlphas = material.vertexColors === true && !!geometry && !!geometry.attributes.color && geometry.attributes.color.itemSize === 4;
			var vertexTangents = !!material.normalMap && !!geometry && !!geometry.attributes.tangent;
			var morphTargets = !!geometry && !!geometry.morphAttributes.position;
			var morphNormals = !!geometry && !!geometry.morphAttributes.normal;
			var morphTargetsCount = !!geometry && !!geometry.morphAttributes.position ? geometry.morphAttributes.position.length : 0;
			var materialProperties = properties.get(material);
			var lights = currentRenderState.state.lights;

			if (_clippingEnabled === true) {
				if (_localClippingEnabled === true || camera !== _currentCamera) {
					var useCache = camera === _currentCamera && material.id === _currentMaterialId; // we might want to call this function with some ClippingGroup
					// object instead of the material, once it becomes feasible
					// (#8465, #8379)

					clipping.setState(material, camera, useCache);
				}
			} //


			var needsProgramChange = false;

			if (material.version === materialProperties.__version) {
				if (materialProperties.needsLights && materialProperties.lightsStateVersion !== lights.state.version) {
					needsProgramChange = true;
				} else if (materialProperties.outputEncoding !== encoding) {
					needsProgramChange = true;
				} else if (object.isInstancedMesh && materialProperties.instancing === false) {
					needsProgramChange = true;
				} else if (!object.isInstancedMesh && materialProperties.instancing === true) {
					needsProgramChange = true;
				} else if (object.isSkinnedMesh && materialProperties.skinning === false) {
					needsProgramChange = true;
				} else if (!object.isSkinnedMesh && materialProperties.skinning === true) {
					needsProgramChange = true;
				} else if (materialProperties.envMap !== envMap) {
					needsProgramChange = true;
				} else if (material.fog && materialProperties.fog !== fog) {
					needsProgramChange = true;
				} else if (materialProperties.numClippingPlanes !== undefined && (materialProperties.numClippingPlanes !== clipping.numPlanes || materialProperties.numIntersection !== clipping.numIntersection)) {
					needsProgramChange = true;
				} else if (materialProperties.vertexAlphas !== vertexAlphas) {
					needsProgramChange = true;
				} else if (materialProperties.vertexTangents !== vertexTangents) {
					needsProgramChange = true;
				} else if (materialProperties.morphTargets !== morphTargets) {
					needsProgramChange = true;
				} else if (materialProperties.morphNormals !== morphNormals) {
					needsProgramChange = true;
				} else if (capabilities.isWebGL2 === true && materialProperties.morphTargetsCount !== morphTargetsCount) {
					needsProgramChange = true;
				}
			} else {
				needsProgramChange = true;
				materialProperties.__version = material.version;
			} //


			var program = materialProperties.currentProgram;

			if (needsProgramChange === true) {
				program = getProgram(material, scene, object);
			}

			var refreshProgram = false;
			var refreshMaterial = false;
			var refreshLights = false;
			var p_uniforms = program.getUniforms(),
					m_uniforms = materialProperties.uniforms;

			if (state.useProgram(program.program)) {
				refreshProgram = true;
				refreshMaterial = true;
				refreshLights = true;
			}

			if (material.id !== _currentMaterialId) {
				_currentMaterialId = material.id;
				refreshMaterial = true;
			}

			if (refreshProgram || _currentCamera !== camera) {
				p_uniforms.setValue(_gl, 'projectionMatrix', camera.projectionMatrix);

				if (capabilities.logarithmicDepthBuffer) {
					p_uniforms.setValue(_gl, 'logDepthBufFC', 2.0 / (Math.log(camera.far + 1.0) / Math.LN2));
				}

				if (_currentCamera !== camera) {
					_currentCamera = camera; // lighting uniforms depend on the camera so enforce an update
					// now, in case this material supports lights - or later, when
					// the next material that does gets activated:

					refreshMaterial = true; // set to true on material change

					refreshLights = true; // remains set until update done
				} // load material specific uniforms
				// (shader material also gets them for the sake of genericity)


				if (material.isShaderMaterial || material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshStandardMaterial || material.envMap) {
					var uCamPos = p_uniforms.map.cameraPosition;

					if (uCamPos !== undefined) {
						uCamPos.setValue(_gl, _vector3.setFromMatrixPosition(camera.matrixWorld));
					}
				}

				if (material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial) {
					p_uniforms.setValue(_gl, 'isOrthographic', camera.isOrthographicCamera === true);
				}

				if (material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial || material.isShadowMaterial || object.isSkinnedMesh) {
					p_uniforms.setValue(_gl, 'viewMatrix', camera.matrixWorldInverse);
				}
			} // skinning and morph target uniforms must be set even if material didn't change
			// auto-setting of texture unit for bone and morph texture must go before other textures
			// otherwise textures used for skinning and morphing can take over texture units reserved for other material textures


			if (object.isSkinnedMesh) {
				p_uniforms.setOptional(_gl, object, 'bindMatrix');
				p_uniforms.setOptional(_gl, object, 'bindMatrixInverse');
				var skeleton = object.skeleton;

				if (skeleton) {
					if (capabilities.floatVertexTextures) {
						if (skeleton.boneTexture === null) skeleton.computeBoneTexture();
						p_uniforms.setValue(_gl, 'boneTexture', skeleton.boneTexture, textures);
						p_uniforms.setValue(_gl, 'boneTextureSize', skeleton.boneTextureSize);
					} else {
						p_uniforms.setOptional(_gl, skeleton, 'boneMatrices');
					}
				}
			}

			if (!!geometry && (geometry.morphAttributes.position !== undefined || geometry.morphAttributes.normal !== undefined)) {
				morphtargets.update(object, geometry, material, program);
			}

			if (refreshMaterial || materialProperties.receiveShadow !== object.receiveShadow) {
				materialProperties.receiveShadow = object.receiveShadow;
				p_uniforms.setValue(_gl, 'receiveShadow', object.receiveShadow);
			}

			if (refreshMaterial) {
				p_uniforms.setValue(_gl, 'toneMappingExposure', _this.toneMappingExposure);

				if (materialProperties.needsLights) {
					// the current material requires lighting info
					// note: all lighting uniforms are always set correctly
					// they simply reference the renderer's state for their
					// values
					//
					// use the current material's .needsUpdate flags to set
					// the GL state when required
					markUniformsLightsNeedsUpdate(m_uniforms, refreshLights);
				} // refresh uniforms common to several materials


				if (fog && material.fog) {
					materials.refreshFogUniforms(m_uniforms, fog);
				}

				materials.refreshMaterialUniforms(m_uniforms, material, _pixelRatio, _height, _transmissionRenderTarget);
				WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, textures);
			}

			if (material.isShaderMaterial && material.uniformsNeedUpdate === true) {
				WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, textures);
				material.uniformsNeedUpdate = false;
			}

			if (material.isSpriteMaterial) {
				p_uniforms.setValue(_gl, 'center', object.center);
			} // common matrices


			p_uniforms.setValue(_gl, 'modelViewMatrix', object.modelViewMatrix);
			p_uniforms.setValue(_gl, 'normalMatrix', object.normalMatrix);
			p_uniforms.setValue(_gl, 'modelMatrix', object.matrixWorld);
			return program;
		} // If uniforms are marked as clean, they don't need to be loaded to the GPU.


		function markUniformsLightsNeedsUpdate(uniforms, value) {
			uniforms.ambientLightColor.needsUpdate = value;
			uniforms.lightProbe.needsUpdate = value;
			uniforms.directionalLights.needsUpdate = value;
			uniforms.directionalLightShadows.needsUpdate = value;
			uniforms.pointLights.needsUpdate = value;
			uniforms.pointLightShadows.needsUpdate = value;
			uniforms.spotLights.needsUpdate = value;
			uniforms.spotLightShadows.needsUpdate = value;
			uniforms.rectAreaLights.needsUpdate = value;
			uniforms.hemisphereLights.needsUpdate = value;
		}

		function materialNeedsLights(material) {
			return material.isMeshLambertMaterial || material.isMeshToonMaterial || material.isMeshPhongMaterial || material.isMeshStandardMaterial || material.isShadowMaterial || material.isShaderMaterial && material.lights === true;
		}

		this.getActiveCubeFace = function () {
			return _currentActiveCubeFace;
		};

		this.getActiveMipmapLevel = function () {
			return _currentActiveMipmapLevel;
		};

		this.getRenderTarget = function () {
			return _currentRenderTarget;
		};

		this.setRenderTarget = function (renderTarget, activeCubeFace, activeMipmapLevel) {
			if (activeCubeFace === void 0) {
				activeCubeFace = 0;
			}

			if (activeMipmapLevel === void 0) {
				activeMipmapLevel = 0;
			}

			_currentRenderTarget = renderTarget;
			_currentActiveCubeFace = activeCubeFace;
			_currentActiveMipmapLevel = activeMipmapLevel;

			if (renderTarget && properties.get(renderTarget).__webglFramebuffer === undefined) {
				textures.setupRenderTarget(renderTarget);
			}

			var framebuffer = null;
			var isCube = false;
			var isRenderTarget3D = false;

			if (renderTarget) {
				var texture = renderTarget.texture;

				if (texture.isDataTexture3D || texture.isDataTexture2DArray) {
					isRenderTarget3D = true;
				}

				var __webglFramebuffer = properties.get(renderTarget).__webglFramebuffer;

				if (renderTarget.isWebGLCubeRenderTarget) {
					framebuffer = __webglFramebuffer[activeCubeFace];
					isCube = true;
				} else if (renderTarget.isWebGLMultisampleRenderTarget) {
					framebuffer = properties.get(renderTarget).__webglMultisampledFramebuffer;
				} else {
					framebuffer = __webglFramebuffer;
				}

				_currentViewport.copy(renderTarget.viewport);

				_currentScissor.copy(renderTarget.scissor);

				_currentScissorTest = renderTarget.scissorTest;
			} else {
				_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor();

				_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor();

				_currentScissorTest = _scissorTest;
			}

			var framebufferBound = state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);

			if (framebufferBound && capabilities.drawBuffers) {
				var needsUpdate = false;

				if (renderTarget) {
					if (renderTarget.isWebGLMultipleRenderTargets) {
						var _textures = renderTarget.texture;

						if (_currentDrawBuffers.length !== _textures.length || _currentDrawBuffers[0] !== _gl.COLOR_ATTACHMENT0) {
							for (var i = 0, il = _textures.length; i < il; i++) {
								_currentDrawBuffers[i] = _gl.COLOR_ATTACHMENT0 + i;
							}

							_currentDrawBuffers.length = _textures.length;
							needsUpdate = true;
						}
					} else {
						if (_currentDrawBuffers.length !== 1 || _currentDrawBuffers[0] !== _gl.COLOR_ATTACHMENT0) {
							_currentDrawBuffers[0] = _gl.COLOR_ATTACHMENT0;
							_currentDrawBuffers.length = 1;
							needsUpdate = true;
						}
					}
				} else {
					if (_currentDrawBuffers.length !== 1 || _currentDrawBuffers[0] !== _gl.BACK) {
						_currentDrawBuffers[0] = _gl.BACK;
						_currentDrawBuffers.length = 1;
						needsUpdate = true;
					}
				}

				if (needsUpdate) {
					if (capabilities.isWebGL2) {
						_gl.drawBuffers(_currentDrawBuffers);
					} else {
						extensions.get('WEBGL_draw_buffers').drawBuffersWEBGL(_currentDrawBuffers);
					}
				}
			}

			state.viewport(_currentViewport);
			state.scissor(_currentScissor);
			state.setScissorTest(_currentScissorTest);

			if (isCube) {
				var textureProperties = properties.get(renderTarget.texture);

				_gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + activeCubeFace, textureProperties.__webglTexture, activeMipmapLevel);
			} else if (isRenderTarget3D) {
				var _textureProperties = properties.get(renderTarget.texture);

				var layer = activeCubeFace || 0;

				_gl.framebufferTextureLayer(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _textureProperties.__webglTexture, activeMipmapLevel || 0, layer);
			}

			_currentMaterialId = -1; // reset current material to ensure correct uniform bindings
		};

		this.readRenderTargetPixels = function (renderTarget, x, y, width, height, buffer, activeCubeFaceIndex) {
			if (!(renderTarget && renderTarget.isWebGLRenderTarget)) {
				console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.');
				return;
			}

			var framebuffer = properties.get(renderTarget).__webglFramebuffer;

			if (renderTarget.isWebGLCubeRenderTarget && activeCubeFaceIndex !== undefined) {
				framebuffer = framebuffer[activeCubeFaceIndex];
			}

			if (framebuffer) {
				state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);

				try {
					var texture = renderTarget.texture;
					var textureFormat = texture.format;
					var textureType = texture.type;

					if (textureFormat !== RGBAFormat && utils.convert(textureFormat) !== _gl.getParameter(_gl.IMPLEMENTATION_COLOR_READ_FORMAT)) {
						console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.');
						return;
					}

					var halfFloatSupportedByExt = textureType === HalfFloatType && (extensions.has('EXT_color_buffer_half_float') || capabilities.isWebGL2 && extensions.has('EXT_color_buffer_float'));

					if (textureType !== UnsignedByteType && utils.convert(textureType) !== _gl.getParameter(_gl.IMPLEMENTATION_COLOR_READ_TYPE) && // Edge and Chrome Mac < 52 (#9513)
					!(textureType === FloatType && (capabilities.isWebGL2 || extensions.has('OES_texture_float') || extensions.has('WEBGL_color_buffer_float'))) && // Chrome Mac >= 52 and Firefox
					!halfFloatSupportedByExt) {
						console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.');
						return;
					}

					if (_gl.checkFramebufferStatus(_gl.FRAMEBUFFER) === _gl.FRAMEBUFFER_COMPLETE) {
						// the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)
						if (x >= 0 && x <= renderTarget.width - width && y >= 0 && y <= renderTarget.height - height) {
							_gl.readPixels(x, y, width, height, utils.convert(textureFormat), utils.convert(textureType), buffer);
						}
					} else {
						console.error('THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.');
					}
				} finally {
					// restore framebuffer of current render target if necessary
					var _framebuffer = _currentRenderTarget !== null ? properties.get(_currentRenderTarget).__webglFramebuffer : null;

					state.bindFramebuffer(_gl.FRAMEBUFFER, _framebuffer);
				}
			}
		};

		this.copyFramebufferToTexture = function (position, texture, level) {
			if (level === void 0) {
				level = 0;
			}

			var levelScale = Math.pow(2, -level);
			var width = Math.floor(texture.image.width * levelScale);
			var height = Math.floor(texture.image.height * levelScale);
			var glFormat = utils.convert(texture.format);

			if (capabilities.isWebGL2) {
				// Workaround for https://bugs.chromium.org/p/chromium/issues/detail?id=1120100
				// Not needed in Chrome 93+
				if (glFormat === _gl.RGB) glFormat = _gl.RGB8;
				if (glFormat === _gl.RGBA) glFormat = _gl.RGBA8;
			}

			textures.setTexture2D(texture, 0);

			_gl.copyTexImage2D(_gl.TEXTURE_2D, level, glFormat, position.x, position.y, width, height, 0);

			state.unbindTexture();
		};

		this.copyTextureToTexture = function (position, srcTexture, dstTexture, level) {
			if (level === void 0) {
				level = 0;
			}

			var width = srcTexture.image.width;
			var height = srcTexture.image.height;
			var glFormat = utils.convert(dstTexture.format);
			var glType = utils.convert(dstTexture.type);
			textures.setTexture2D(dstTexture, 0); // As another texture upload may have changed pixelStorei
			// parameters, make sure they are correct for the dstTexture

			_gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, dstTexture.flipY);

			_gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, dstTexture.premultiplyAlpha);

			_gl.pixelStorei(_gl.UNPACK_ALIGNMENT, dstTexture.unpackAlignment);

			if (srcTexture.isDataTexture) {
				_gl.texSubImage2D(_gl.TEXTURE_2D, level, position.x, position.y, width, height, glFormat, glType, srcTexture.image.data);
			} else {
				if (srcTexture.isCompressedTexture) {
					_gl.compressedTexSubImage2D(_gl.TEXTURE_2D, level, position.x, position.y, srcTexture.mipmaps[0].width, srcTexture.mipmaps[0].height, glFormat, srcTexture.mipmaps[0].data);
				} else {
					_gl.texSubImage2D(_gl.TEXTURE_2D, level, position.x, position.y, glFormat, glType, srcTexture.image);
				}
			} // Generate mipmaps only when copying level 0


			if (level === 0 && dstTexture.generateMipmaps) _gl.generateMipmap(_gl.TEXTURE_2D);
			state.unbindTexture();
		};

		this.copyTextureToTexture3D = function (sourceBox, position, srcTexture, dstTexture, level) {
			if (level === void 0) {
				level = 0;
			}

			if (_this.isWebGL1Renderer) {
				console.warn('THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.');
				return;
			}

			var width = sourceBox.max.x - sourceBox.min.x + 1;
			var height = sourceBox.max.y - sourceBox.min.y + 1;
			var depth = sourceBox.max.z - sourceBox.min.z + 1;
			var glFormat = utils.convert(dstTexture.format);
			var glType = utils.convert(dstTexture.type);
			var glTarget;

			if (dstTexture.isDataTexture3D) {
				textures.setTexture3D(dstTexture, 0);
				glTarget = _gl.TEXTURE_3D;
			} else if (dstTexture.isDataTexture2DArray) {
				textures.setTexture2DArray(dstTexture, 0);
				glTarget = _gl.TEXTURE_2D_ARRAY;
			} else {
				console.warn('THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.');
				return;
			}

			_gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, dstTexture.flipY);

			_gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, dstTexture.premultiplyAlpha);

			_gl.pixelStorei(_gl.UNPACK_ALIGNMENT, dstTexture.unpackAlignment);

			var unpackRowLen = _gl.getParameter(_gl.UNPACK_ROW_LENGTH);

			var unpackImageHeight = _gl.getParameter(_gl.UNPACK_IMAGE_HEIGHT);

			var unpackSkipPixels = _gl.getParameter(_gl.UNPACK_SKIP_PIXELS);

			var unpackSkipRows = _gl.getParameter(_gl.UNPACK_SKIP_ROWS);

			var unpackSkipImages = _gl.getParameter(_gl.UNPACK_SKIP_IMAGES);

			var image = srcTexture.isCompressedTexture ? srcTexture.mipmaps[0] : srcTexture.image;

			_gl.pixelStorei(_gl.UNPACK_ROW_LENGTH, image.width);

			_gl.pixelStorei(_gl.UNPACK_IMAGE_HEIGHT, image.height);

			_gl.pixelStorei(_gl.UNPACK_SKIP_PIXELS, sourceBox.min.x);

			_gl.pixelStorei(_gl.UNPACK_SKIP_ROWS, sourceBox.min.y);

			_gl.pixelStorei(_gl.UNPACK_SKIP_IMAGES, sourceBox.min.z);

			if (srcTexture.isDataTexture || srcTexture.isDataTexture3D) {
				_gl.texSubImage3D(glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, glType, image.data);
			} else {
				if (srcTexture.isCompressedTexture) {
					console.warn('THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture.');

					_gl.compressedTexSubImage3D(glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, image.data);
				} else {
					_gl.texSubImage3D(glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, glType, image);
				}
			}

			_gl.pixelStorei(_gl.UNPACK_ROW_LENGTH, unpackRowLen);

			_gl.pixelStorei(_gl.UNPACK_IMAGE_HEIGHT, unpackImageHeight);

			_gl.pixelStorei(_gl.UNPACK_SKIP_PIXELS, unpackSkipPixels);

			_gl.pixelStorei(_gl.UNPACK_SKIP_ROWS, unpackSkipRows);

			_gl.pixelStorei(_gl.UNPACK_SKIP_IMAGES, unpackSkipImages); // Generate mipmaps only when copying level 0


			if (level === 0 && dstTexture.generateMipmaps) _gl.generateMipmap(glTarget);
			state.unbindTexture();
		};

		this.initTexture = function (texture) {
			textures.setTexture2D(texture, 0);
			state.unbindTexture();
		};

		this.resetState = function () {
			_currentActiveCubeFace = 0;
			_currentActiveMipmapLevel = 0;
			_currentRenderTarget = null;
			state.reset();
			bindingStates.reset();
		};

		if (typeof __THREE_DEVTOOLS__ !== 'undefined') {
			__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('observe', {
				detail: this
			})); // eslint-disable-line no-undef

		}
	}

	var WebGL1Renderer = /*#__PURE__*/function (_WebGLRenderer) {
		_inheritsLoose(WebGL1Renderer, _WebGLRenderer);

		function WebGL1Renderer() {
			return _WebGLRenderer.apply(this, arguments) || this;
		}

		return WebGL1Renderer;
	}(WebGLRenderer);

	WebGL1Renderer.prototype.isWebGL1Renderer = true;

	var FogExp2 = /*#__PURE__*/function () {
		function FogExp2(color, density) {
			if (density === void 0) {
				density = 0.00025;
			}

			this.name = '';
			this.color = new Color(color);
			this.density = density;
		}

		var _proto = FogExp2.prototype;

		_proto.clone = function clone() {
			return new FogExp2(this.color, this.density);
		};

		_proto.toJSON = function toJSON()
		/* meta */
		{
			return {
				type: 'FogExp2',
				color: this.color.getHex(),
				density: this.density
			};
		};

		return FogExp2;
	}();

	FogExp2.prototype.isFogExp2 = true;

	var Fog = /*#__PURE__*/function () {
		function Fog(color, near, far) {
			if (near === void 0) {
				near = 1;
			}

			if (far === void 0) {
				far = 1000;
			}

			this.name = '';
			this.color = new Color(color);
			this.near = near;
			this.far = far;
		}

		var _proto = Fog.prototype;

		_proto.clone = function clone() {
			return new Fog(this.color, this.near, this.far);
		};

		_proto.toJSON = function toJSON()
		/* meta */
		{
			return {
				type: 'Fog',
				color: this.color.getHex(),
				near: this.near,
				far: this.far
			};
		};

		return Fog;
	}();

	Fog.prototype.isFog = true;

	var Scene = /*#__PURE__*/function (_Object3D) {
		_inheritsLoose(Scene, _Object3D);

		function Scene() {
			var _this;

			_this = _Object3D.call(this) || this;
			_this.type = 'Scene';
			_this.background = null;
			_this.environment = null;
			_this.fog = null;
			_this.overrideMaterial = null;
			_this.autoUpdate = true; // checked by the renderer

			if (typeof __THREE_DEVTOOLS__ !== 'undefined') {
				__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('observe', {
					detail: _assertThisInitialized(_this)
				})); // eslint-disable-line no-undef

			}

			return _this;
		}

		var _proto = Scene.prototype;

		_proto.copy = function copy(source, recursive) {
			_Object3D.prototype.copy.call(this, source, recursive);

			if (source.background !== null) this.background = source.background.clone();
			if (source.environment !== null) this.environment = source.environment.clone();
			if (source.fog !== null) this.fog = source.fog.clone();
			if (source.overrideMaterial !== null) this.overrideMaterial = source.overrideMaterial.clone();
			this.autoUpdate = source.autoUpdate;
			this.matrixAutoUpdate = source.matrixAutoUpdate;
			return this;
		};

		_proto.toJSON = function toJSON(meta) {
			var data = _Object3D.prototype.toJSON.call(this, meta);

			if (this.fog !== null) data.object.fog = this.fog.toJSON();
			return data;
		};

		return Scene;
	}(Object3D);

	Scene.prototype.isScene = true;

	var InterleavedBuffer = /*#__PURE__*/function () {
		function InterleavedBuffer(array, stride) {
			this.array = array;
			this.stride = stride;
			this.count = array !== undefined ? array.length / stride : 0;
			this.usage = StaticDrawUsage;
			this.updateRange = {
				offset: 0,
				count: -1
			};
			this.version = 0;
			this.uuid = generateUUID();
		}

		var _proto = InterleavedBuffer.prototype;

		_proto.onUploadCallback = function onUploadCallback() {};

		_proto.setUsage = function setUsage(value) {
			this.usage = value;
			return this;
		};

		_proto.copy = function copy(source) {
			this.array = new source.array.constructor(source.array);
			this.count = source.count;
			this.stride = source.stride;
			this.usage = source.usage;
			return this;
		};

		_proto.copyAt = function copyAt(index1, attribute, index2) {
			index1 *= this.stride;
			index2 *= attribute.stride;

			for (var i = 0, l = this.stride; i < l; i++) {
				this.array[index1 + i] = attribute.array[index2 + i];
			}

			return this;
		};

		_proto.set = function set(value, offset) {
			if (offset === void 0) {
				offset = 0;
			}

			this.array.set(value, offset);
			return this;
		};

		_proto.clone = function clone(data) {
			if (data.arrayBuffers === undefined) {
				data.arrayBuffers = {};
			}

			if (this.array.buffer._uuid === undefined) {
				this.array.buffer._uuid = generateUUID();
			}

			if (data.arrayBuffers[this.array.buffer._uuid] === undefined) {
				data.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer;
			}

			var array = new this.array.constructor(data.arrayBuffers[this.array.buffer._uuid]);
			var ib = new this.constructor(array, this.stride);
			ib.setUsage(this.usage);
			return ib;
		};

		_proto.onUpload = function onUpload(callback) {
			this.onUploadCallback = callback;
			return this;
		};

		_proto.toJSON = function toJSON(data) {
			if (data.arrayBuffers === undefined) {
				data.arrayBuffers = {};
			} // generate UUID for array buffer if necessary


			if (this.array.buffer._uuid === undefined) {
				this.array.buffer._uuid = generateUUID();
			}

			if (data.arrayBuffers[this.array.buffer._uuid] === undefined) {
				data.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(new Uint32Array(this.array.buffer));
			} //


			return {
				uuid: this.uuid,
				buffer: this.array.buffer._uuid,
				type: this.array.constructor.name,
				stride: this.stride
			};
		};

		_createClass(InterleavedBuffer, [{
			key: "needsUpdate",
			set: function set(value) {
				if (value === true) this.version++;
			}
		}]);

		return InterleavedBuffer;
	}();

	InterleavedBuffer.prototype.isInterleavedBuffer = true;

	var _vector$6 = /*@__PURE__*/new Vector3();

	var InterleavedBufferAttribute = /*#__PURE__*/function () {
		function InterleavedBufferAttribute(interleavedBuffer, itemSize, offset, normalized) {
			if (normalized === void 0) {
				normalized = false;
			}

			this.name = '';
			this.data = interleavedBuffer;
			this.itemSize = itemSize;
			this.offset = offset;
			this.normalized = normalized === true;
		}

		var _proto = InterleavedBufferAttribute.prototype;

		_proto.applyMatrix4 = function applyMatrix4(m) {
			for (var i = 0, l = this.data.count; i < l; i++) {
				_vector$6.x = this.getX(i);
				_vector$6.y = this.getY(i);
				_vector$6.z = this.getZ(i);

				_vector$6.applyMatrix4(m);

				this.setXYZ(i, _vector$6.x, _vector$6.y, _vector$6.z);
			}

			return this;
		};

		_proto.applyNormalMatrix = function applyNormalMatrix(m) {
			for (var i = 0, l = this.count; i < l; i++) {
				_vector$6.x = this.getX(i);
				_vector$6.y = this.getY(i);
				_vector$6.z = this.getZ(i);

				_vector$6.applyNormalMatrix(m);

				this.setXYZ(i, _vector$6.x, _vector$6.y, _vector$6.z);
			}

			return this;
		};

		_proto.transformDirection = function transformDirection(m) {
			for (var i = 0, l = this.count; i < l; i++) {
				_vector$6.x = this.getX(i);
				_vector$6.y = this.getY(i);
				_vector$6.z = this.getZ(i);

				_vector$6.transformDirection(m);

				this.setXYZ(i, _vector$6.x, _vector$6.y, _vector$6.z);
			}

			return this;
		};

		_proto.setX = function setX(index, x) {
			this.data.array[index * this.data.stride + this.offset] = x;
			return this;
		};

		_proto.setY = function setY(index, y) {
			this.data.array[index * this.data.stride + this.offset + 1] = y;
			return this;
		};

		_proto.setZ = function setZ(index, z) {
			this.data.array[index * this.data.stride + this.offset + 2] = z;
			return this;
		};

		_proto.setW = function setW(index, w) {
			this.data.array[index * this.data.stride + this.offset + 3] = w;
			return this;
		};

		_proto.getX = function getX(index) {
			return this.data.array[index * this.data.stride + this.offset];
		};

		_proto.getY = function getY(index) {
			return this.data.array[index * this.data.stride + this.offset + 1];
		};

		_proto.getZ = function getZ(index) {
			return this.data.array[index * this.data.stride + this.offset + 2];
		};

		_proto.getW = function getW(index) {
			return this.data.array[index * this.data.stride + this.offset + 3];
		};

		_proto.setXY = function setXY(index, x, y) {
			index = index * this.data.stride + this.offset;
			this.data.array[index + 0] = x;
			this.data.array[index + 1] = y;
			return this;
		};

		_proto.setXYZ = function setXYZ(index, x, y, z) {
			index = index * this.data.stride + this.offset;
			this.data.array[index + 0] = x;
			this.data.array[index + 1] = y;
			this.data.array[index + 2] = z;
			return this;
		};

		_proto.setXYZW = function setXYZW(index, x, y, z, w) {
			index = index * this.data.stride + this.offset;
			this.data.array[index + 0] = x;
			this.data.array[index + 1] = y;
			this.data.array[index + 2] = z;
			this.data.array[index + 3] = w;
			return this;
		};

		_proto.clone = function clone(data) {
			if (data === undefined) {
				console.log('THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.');
				var array = [];

				for (var i = 0; i < this.count; i++) {
					var index = i * this.data.stride + this.offset;

					for (var j = 0; j < this.itemSize; j++) {
						array.push(this.data.array[index + j]);
					}
				}

				return new BufferAttribute(new this.array.constructor(array), this.itemSize, this.normalized);
			} else {
				if (data.interleavedBuffers === undefined) {
					data.interleavedBuffers = {};
				}

				if (data.interleavedBuffers[this.data.uuid] === undefined) {
					data.interleavedBuffers[this.data.uuid] = this.data.clone(data);
				}

				return new InterleavedBufferAttribute(data.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
			}
		};

		_proto.toJSON = function toJSON(data) {
			if (data === undefined) {
				console.log('THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.');
				var array = [];

				for (var i = 0; i < this.count; i++) {
					var index = i * this.data.stride + this.offset;

					for (var j = 0; j < this.itemSize; j++) {
						array.push(this.data.array[index + j]);
					}
				} // deinterleave data and save it as an ordinary buffer attribute for now


				return {
					itemSize: this.itemSize,
					type: this.array.constructor.name,
					array: array,
					normalized: this.normalized
				};
			} else {
				// save as true interlaved attribtue
				if (data.interleavedBuffers === undefined) {
					data.interleavedBuffers = {};
				}

				if (data.interleavedBuffers[this.data.uuid] === undefined) {
					data.interleavedBuffers[this.data.uuid] = this.data.toJSON(data);
				}

				return {
					isInterleavedBufferAttribute: true,
					itemSize: this.itemSize,
					data: this.data.uuid,
					offset: this.offset,
					normalized: this.normalized
				};
			}
		};

		_createClass(InterleavedBufferAttribute, [{
			key: "count",
			get: function get() {
				return this.data.count;
			}
		}, {
			key: "array",
			get: function get() {
				return this.data.array;
			}
		}, {
			key: "needsUpdate",
			set: function set(value) {
				this.data.needsUpdate = value;
			}
		}]);

		return InterleavedBufferAttribute;
	}();

	InterleavedBufferAttribute.prototype.isInterleavedBufferAttribute = true;

	/**
	 * parameters = {
	 *	color: <hex>,
	 *	map: new THREE.Texture( <Image> ),
	 *	alphaMap: new THREE.Texture( <Image> ),
	 *	rotation: <float>,
	 *	sizeAttenuation: <bool>
	 * }
	 */

	var SpriteMaterial = /*#__PURE__*/function (_Material) {
		_inheritsLoose(SpriteMaterial, _Material);

		function SpriteMaterial(parameters) {
			var _this;

			_this = _Material.call(this) || this;
			_this.type = 'SpriteMaterial';
			_this.color = new Color(0xffffff);
			_this.map = null;
			_this.alphaMap = null;
			_this.rotation = 0;
			_this.sizeAttenuation = true;
			_this.transparent = true;

			_this.setValues(parameters);

			return _this;
		}

		var _proto = SpriteMaterial.prototype;

		_proto.copy = function copy(source) {
			_Material.prototype.copy.call(this, source);

			this.color.copy(source.color);
			this.map = source.map;
			this.alphaMap = source.alphaMap;
			this.rotation = source.rotation;
			this.sizeAttenuation = source.sizeAttenuation;
			return this;
		};

		return SpriteMaterial;
	}(Material);

	SpriteMaterial.prototype.isSpriteMaterial = true;

	var _geometry;

	var _intersectPoint = /*@__PURE__*/new Vector3();

	var _worldScale = /*@__PURE__*/new Vector3();

	var _mvPosition = /*@__PURE__*/new Vector3();

	var _alignedPosition = /*@__PURE__*/new Vector2();

	var _rotatedPosition = /*@__PURE__*/new Vector2();

	var _viewWorldMatrix = /*@__PURE__*/new Matrix4();

	var _vA$1 = /*@__PURE__*/new Vector3();

	var _vB$1 = /*@__PURE__*/new Vector3();

	var _vC$1 = /*@__PURE__*/new Vector3();

	var _uvA$1 = /*@__PURE__*/new Vector2();

	var _uvB$1 = /*@__PURE__*/new Vector2();

	var _uvC$1 = /*@__PURE__*/new Vector2();

	var Sprite = /*#__PURE__*/function (_Object3D) {
		_inheritsLoose(Sprite, _Object3D);

		function Sprite(material) {
			var _this;

			_this = _Object3D.call(this) || this;
			_this.type = 'Sprite';

			if (_geometry === undefined) {
				_geometry = new BufferGeometry();
				var float32Array = new Float32Array([-0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 1, -0.5, 0.5, 0, 0, 1]);
				var interleavedBuffer = new InterleavedBuffer(float32Array, 5);

				_geometry.setIndex([0, 1, 2, 0, 2, 3]);

				_geometry.setAttribute('position', new InterleavedBufferAttribute(interleavedBuffer, 3, 0, false));

				_geometry.setAttribute('uv', new InterleavedBufferAttribute(interleavedBuffer, 2, 3, false));
			}

			_this.geometry = _geometry;
			_this.material = material !== undefined ? material : new SpriteMaterial();
			_this.center = new Vector2(0.5, 0.5);
			return _this;
		}

		var _proto = Sprite.prototype;

		_proto.raycast = function raycast(raycaster, intersects) {
			if (raycaster.camera === null) {
				console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.');
			}

			_worldScale.setFromMatrixScale(this.matrixWorld);

			_viewWorldMatrix.copy(raycaster.camera.matrixWorld);

			this.modelViewMatrix.multiplyMatrices(raycaster.camera.matrixWorldInverse, this.matrixWorld);

			_mvPosition.setFromMatrixPosition(this.modelViewMatrix);

			if (raycaster.camera.isPerspectiveCamera && this.material.sizeAttenuation === false) {
				_worldScale.multiplyScalar(-_mvPosition.z);
			}

			var rotation = this.material.rotation;
			var sin, cos;

			if (rotation !== 0) {
				cos = Math.cos(rotation);
				sin = Math.sin(rotation);
			}

			var center = this.center;
			transformVertex(_vA$1.set(-0.5, -0.5, 0), _mvPosition, center, _worldScale, sin, cos);
			transformVertex(_vB$1.set(0.5, -0.5, 0), _mvPosition, center, _worldScale, sin, cos);
			transformVertex(_vC$1.set(0.5, 0.5, 0), _mvPosition, center, _worldScale, sin, cos);

			_uvA$1.set(0, 0);

			_uvB$1.set(1, 0);

			_uvC$1.set(1, 1); // check first triangle


			var intersect = raycaster.ray.intersectTriangle(_vA$1, _vB$1, _vC$1, false, _intersectPoint);

			if (intersect === null) {
				// check second triangle
				transformVertex(_vB$1.set(-0.5, 0.5, 0), _mvPosition, center, _worldScale, sin, cos);

				_uvB$1.set(0, 1);

				intersect = raycaster.ray.intersectTriangle(_vA$1, _vC$1, _vB$1, false, _intersectPoint);

				if (intersect === null) {
					return;
				}
			}

			var distance = raycaster.ray.origin.distanceTo(_intersectPoint);
			if (distance < raycaster.near || distance > raycaster.far) return;
			intersects.push({
				distance: distance,
				point: _intersectPoint.clone(),
				uv: Triangle.getUV(_intersectPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2()),
				face: null,
				object: this
			});
		};

		_proto.copy = function copy(source) {
			_Object3D.prototype.copy.call(this, source);

			if (source.center !== undefined) this.center.copy(source.center);
			this.material = source.material;
			return this;
		};

		return Sprite;
	}(Object3D);

	Sprite.prototype.isSprite = true;

	function transformVertex(vertexPosition, mvPosition, center, scale, sin, cos) {
		// compute position in camera space
		_alignedPosition.subVectors(vertexPosition, center).addScalar(0.5).multiply(scale); // to check if rotation is not zero


		if (sin !== undefined) {
			_rotatedPosition.x = cos * _alignedPosition.x - sin * _alignedPosition.y;
			_rotatedPosition.y = sin * _alignedPosition.x + cos * _alignedPosition.y;
		} else {
			_rotatedPosition.copy(_alignedPosition);
		}

		vertexPosition.copy(mvPosition);
		vertexPosition.x += _rotatedPosition.x;
		vertexPosition.y += _rotatedPosition.y; // transform to world space

		vertexPosition.applyMatrix4(_viewWorldMatrix);
	}

	var _v1$5 = /*@__PURE__*/new Vector3();

	var _v2$2 = /*@__PURE__*/new Vector3();

	var LOD = /*#__PURE__*/function (_Object3D) {
		_inheritsLoose(LOD, _Object3D);

		function LOD() {
			var _this;

			_this = _Object3D.call(this) || this;
			_this._currentLevel = 0;
			_this.type = 'LOD';
			Object.defineProperties(_assertThisInitialized(_this), {
				levels: {
					enumerable: true,
					value: []
				},
				isLOD: {
					value: true
				}
			});
			_this.autoUpdate = true;
			return _this;
		}

		var _proto = LOD.prototype;

		_proto.copy = function copy(source) {
			_Object3D.prototype.copy.call(this, source, false);

			var levels = source.levels;

			for (var i = 0, l = levels.length; i < l; i++) {
				var level = levels[i];
				this.addLevel(level.object.clone(), level.distance);
			}

			this.autoUpdate = source.autoUpdate;
			return this;
		};

		_proto.addLevel = function addLevel(object, distance) {
			if (distance === void 0) {
				distance = 0;
			}

			distance = Math.abs(distance);
			var levels = this.levels;
			var l;

			for (l = 0; l < levels.length; l++) {
				if (distance < levels[l].distance) {
					break;
				}
			}

			levels.splice(l, 0, {
				distance: distance,
				object: object
			});
			this.add(object);
			return this;
		};

		_proto.getCurrentLevel = function getCurrentLevel() {
			return this._currentLevel;
		};

		_proto.getObjectForDistance = function getObjectForDistance(distance) {
			var levels = this.levels;

			if (levels.length > 0) {
				var i, l;

				for (i = 1, l = levels.length; i < l; i++) {
					if (distance < levels[i].distance) {
						break;
					}
				}

				return levels[i - 1].object;
			}

			return null;
		};

		_proto.raycast = function raycast(raycaster, intersects) {
			var levels = this.levels;

			if (levels.length > 0) {
				_v1$5.setFromMatrixPosition(this.matrixWorld);

				var distance = raycaster.ray.origin.distanceTo(_v1$5);
				this.getObjectForDistance(distance).raycast(raycaster, intersects);
			}
		};

		_proto.update = function update(camera) {
			var levels = this.levels;

			if (levels.length > 1) {
				_v1$5.setFromMatrixPosition(camera.matrixWorld);

				_v2$2.setFromMatrixPosition(this.matrixWorld);

				var distance = _v1$5.distanceTo(_v2$2) / camera.zoom;
				levels[0].object.visible = true;
				var i, l;

				for (i = 1, l = levels.length; i < l; i++) {
					if (distance >= levels[i].distance) {
						levels[i - 1].object.visible = false;
						levels[i].object.visible = true;
					} else {
						break;
					}
				}

				this._currentLevel = i - 1;

				for (; i < l; i++) {
					levels[i].object.visible = false;
				}
			}
		};

		_proto.toJSON = function toJSON(meta) {
			var data = _Object3D.prototype.toJSON.call(this, meta);

			if (this.autoUpdate === false) data.object.autoUpdate = false;
			data.object.levels = [];
			var levels = this.levels;

			for (var i = 0, l = levels.length; i < l; i++) {
				var level = levels[i];
				data.object.levels.push({
					object: level.object.uuid,
					distance: level.distance
				});
			}

			return data;
		};

		return LOD;
	}(Object3D);

	var _basePosition = /*@__PURE__*/new Vector3();

	var _skinIndex = /*@__PURE__*/new Vector4();

	var _skinWeight = /*@__PURE__*/new Vector4();

	var _vector$7 = /*@__PURE__*/new Vector3();

	var _matrix$1 = /*@__PURE__*/new Matrix4();

	var SkinnedMesh = /*#__PURE__*/function (_Mesh) {
		_inheritsLoose(SkinnedMesh, _Mesh);

		function SkinnedMesh(geometry, material) {
			var _this;

			_this = _Mesh.call(this, geometry, material) || this;
			_this.type = 'SkinnedMesh';
			_this.bindMode = 'attached';
			_this.bindMatrix = new Matrix4();
			_this.bindMatrixInverse = new Matrix4();
			return _this;
		}

		var _proto = SkinnedMesh.prototype;

		_proto.copy = function copy(source) {
			_Mesh.prototype.copy.call(this, source);

			this.bindMode = source.bindMode;
			this.bindMatrix.copy(source.bindMatrix);
			this.bindMatrixInverse.copy(source.bindMatrixInverse);
			this.skeleton = source.skeleton;
			return this;
		};

		_proto.bind = function bind(skeleton, bindMatrix) {
			this.skeleton = skeleton;

			if (bindMatrix === undefined) {
				this.updateMatrixWorld(true);
				this.skeleton.calculateInverses();
				bindMatrix = this.matrixWorld;
			}

			this.bindMatrix.copy(bindMatrix);
			this.bindMatrixInverse.copy(bindMatrix).invert();
		};

		_proto.pose = function pose() {
			this.skeleton.pose();
		};

		_proto.normalizeSkinWeights = function normalizeSkinWeights() {
			var vector = new Vector4();
			var skinWeight = this.geometry.attributes.skinWeight;

			for (var i = 0, l = skinWeight.count; i < l; i++) {
				vector.x = skinWeight.getX(i);
				vector.y = skinWeight.getY(i);
				vector.z = skinWeight.getZ(i);
				vector.w = skinWeight.getW(i);
				var scale = 1.0 / vector.manhattanLength();

				if (scale !== Infinity) {
					vector.multiplyScalar(scale);
				} else {
					vector.set(1, 0, 0, 0); // do something reasonable
				}

				skinWeight.setXYZW(i, vector.x, vector.y, vector.z, vector.w);
			}
		};

		_proto.updateMatrixWorld = function updateMatrixWorld(force) {
			_Mesh.prototype.updateMatrixWorld.call(this, force);

			if (this.bindMode === 'attached') {
				this.bindMatrixInverse.copy(this.matrixWorld).invert();
			} else if (this.bindMode === 'detached') {
				this.bindMatrixInverse.copy(this.bindMatrix).invert();
			} else {
				console.warn('THREE.SkinnedMesh: Unrecognized bindMode: ' + this.bindMode);
			}
		};

		_proto.boneTransform = function boneTransform(index, target) {
			var skeleton = this.skeleton;
			var geometry = this.geometry;

			_skinIndex.fromBufferAttribute(geometry.attributes.skinIndex, index);

			_skinWeight.fromBufferAttribute(geometry.attributes.skinWeight, index);

			_basePosition.copy(target).applyMatrix4(this.bindMatrix);

			target.set(0, 0, 0);

			for (var i = 0; i < 4; i++) {
				var weight = _skinWeight.getComponent(i);

				if (weight !== 0) {
					var boneIndex = _skinIndex.getComponent(i);

					_matrix$1.multiplyMatrices(skeleton.bones[boneIndex].matrixWorld, skeleton.boneInverses[boneIndex]);

					target.addScaledVector(_vector$7.copy(_basePosition).applyMatrix4(_matrix$1), weight);
				}
			}

			return target.applyMatrix4(this.bindMatrixInverse);
		};

		return SkinnedMesh;
	}(Mesh);

	SkinnedMesh.prototype.isSkinnedMesh = true;

	var Bone = /*#__PURE__*/function (_Object3D) {
		_inheritsLoose(Bone, _Object3D);

		function Bone() {
			var _this;

			_this = _Object3D.call(this) || this;
			_this.type = 'Bone';
			return _this;
		}

		return Bone;
	}(Object3D);

	Bone.prototype.isBone = true;

	var DataTexture = /*#__PURE__*/function (_Texture) {
		_inheritsLoose(DataTexture, _Texture);

		function DataTexture(data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding) {
			var _this;

			if (data === void 0) {
				data = null;
			}

			if (width === void 0) {
				width = 1;
			}

			if (height === void 0) {
				height = 1;
			}

			if (magFilter === void 0) {
				magFilter = NearestFilter;
			}

			if (minFilter === void 0) {
				minFilter = NearestFilter;
			}

			_this = _Texture.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding) || this;
			_this.image = {
				data: data,
				width: width,
				height: height
			};
			_this.magFilter = magFilter;
			_this.minFilter = minFilter;
			_this.generateMipmaps = false;
			_this.flipY = false;
			_this.unpackAlignment = 1;
			_this.needsUpdate = true;
			return _this;
		}

		return DataTexture;
	}(Texture);

	DataTexture.prototype.isDataTexture = true;

	var _offsetMatrix = /*@__PURE__*/new Matrix4();

	var _identityMatrix = /*@__PURE__*/new Matrix4();

	var Skeleton = /*#__PURE__*/function () {
		function Skeleton(bones, boneInverses) {
			if (bones === void 0) {
				bones = [];
			}

			if (boneInverses === void 0) {
				boneInverses = [];
			}

			this.uuid = generateUUID();
			this.bones = bones.slice(0);
			this.boneInverses = boneInverses;
			this.boneMatrices = null;
			this.boneTexture = null;
			this.boneTextureSize = 0;
			this.frame = -1;
			this.init();
		}

		var _proto = Skeleton.prototype;

		_proto.init = function init() {
			var bones = this.bones;
			var boneInverses = this.boneInverses;
			this.boneMatrices = new Float32Array(bones.length * 16); // calculate inverse bone matrices if necessary

			if (boneInverses.length === 0) {
				this.calculateInverses();
			} else {
				// handle special case
				if (bones.length !== boneInverses.length) {
					console.warn('THREE.Skeleton: Number of inverse bone matrices does not match amount of bones.');
					this.boneInverses = [];

					for (var i = 0, il = this.bones.length; i < il; i++) {
						this.boneInverses.push(new Matrix4());
					}
				}
			}
		};

		_proto.calculateInverses = function calculateInverses() {
			this.boneInverses.length = 0;

			for (var i = 0, il = this.bones.length; i < il; i++) {
				var inverse = new Matrix4();

				if (this.bones[i]) {
					inverse.copy(this.bones[i].matrixWorld).invert();
				}

				this.boneInverses.push(inverse);
			}
		};

		_proto.pose = function pose() {
			// recover the bind-time world matrices
			for (var i = 0, il = this.bones.length; i < il; i++) {
				var bone = this.bones[i];

				if (bone) {
					bone.matrixWorld.copy(this.boneInverses[i]).invert();
				}
			} // compute the local matrices, positions, rotations and scales


			for (var _i = 0, _il = this.bones.length; _i < _il; _i++) {
				var _bone = this.bones[_i];

				if (_bone) {
					if (_bone.parent && _bone.parent.isBone) {
						_bone.matrix.copy(_bone.parent.matrixWorld).invert();

						_bone.matrix.multiply(_bone.matrixWorld);
					} else {
						_bone.matrix.copy(_bone.matrixWorld);
					}

					_bone.matrix.decompose(_bone.position, _bone.quaternion, _bone.scale);
				}
			}
		};

		_proto.update = function update() {
			var bones = this.bones;
			var boneInverses = this.boneInverses;
			var boneMatrices = this.boneMatrices;
			var boneTexture = this.boneTexture; // flatten bone matrices to array

			for (var i = 0, il = bones.length; i < il; i++) {
				// compute the offset between the current and the original transform
				var matrix = bones[i] ? bones[i].matrixWorld : _identityMatrix;

				_offsetMatrix.multiplyMatrices(matrix, boneInverses[i]);

				_offsetMatrix.toArray(boneMatrices, i * 16);
			}

			if (boneTexture !== null) {
				boneTexture.needsUpdate = true;
			}
		};

		_proto.clone = function clone() {
			return new Skeleton(this.bones, this.boneInverses);
		};

		_proto.computeBoneTexture = function computeBoneTexture() {
			// layout (1 matrix = 4 pixels)
			//			RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
			//	with	8x8	pixel texture max	 16 bones * 4 pixels =	(8 * 8)
			//			 16x16 pixel texture max	 64 bones * 4 pixels = (16 * 16)
			//			 32x32 pixel texture max	256 bones * 4 pixels = (32 * 32)
			//			 64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)
			var size = Math.sqrt(this.bones.length * 4); // 4 pixels needed for 1 matrix

			size = ceilPowerOfTwo(size);
			size = Math.max(size, 4);
			var boneMatrices = new Float32Array(size * size * 4); // 4 floats per RGBA pixel

			boneMatrices.set(this.boneMatrices); // copy current values

			var boneTexture = new DataTexture(boneMatrices, size, size, RGBAFormat, FloatType);
			this.boneMatrices = boneMatrices;
			this.boneTexture = boneTexture;
			this.boneTextureSize = size;
			return this;
		};

		_proto.getBoneByName = function getBoneByName(name) {
			for (var i = 0, il = this.bones.length; i < il; i++) {
				var bone = this.bones[i];

				if (bone.name === name) {
					return bone;
				}
			}

			return undefined;
		};

		_proto.dispose = function dispose() {
			if (this.boneTexture !== null) {
				this.boneTexture.dispose();
				this.boneTexture = null;
			}
		};

		_proto.fromJSON = function fromJSON(json, bones) {
			this.uuid = json.uuid;

			for (var i = 0, l = json.bones.length; i < l; i++) {
				var uuid = json.bones[i];
				var bone = bones[uuid];

				if (bone === undefined) {
					console.warn('THREE.Skeleton: No bone found with UUID:', uuid);
					bone = new Bone();
				}

				this.bones.push(bone);
				this.boneInverses.push(new Matrix4().fromArray(json.boneInverses[i]));
			}

			this.init();
			return this;
		};

		_proto.toJSON = function toJSON() {
			var data = {
				metadata: {
					version: 4.5,
					type: 'Skeleton',
					generator: 'Skeleton.toJSON'
				},
				bones: [],
				boneInverses: []
			};
			data.uuid = this.uuid;
			var bones = this.bones;
			var boneInverses = this.boneInverses;

			for (var i = 0, l = bones.length; i < l; i++) {
				var bone = bones[i];
				data.bones.push(bone.uuid);
				var boneInverse = boneInverses[i];
				data.boneInverses.push(boneInverse.toArray());
			}

			return data;
		};

		return Skeleton;
	}();

	var InstancedBufferAttribute = /*#__PURE__*/function (_BufferAttribute) {
		_inheritsLoose(InstancedBufferAttribute, _BufferAttribute);

		function InstancedBufferAttribute(array, itemSize, normalized, meshPerAttribute) {
			var _this;

			if (meshPerAttribute === void 0) {
				meshPerAttribute = 1;
			}

			if (typeof normalized === 'number') {
				meshPerAttribute = normalized;
				normalized = false;
				console.error('THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.');
			}

			_this = _BufferAttribute.call(this, array, itemSize, normalized) || this;
			_this.meshPerAttribute = meshPerAttribute;
			return _this;
		}

		var _proto = InstancedBufferAttribute.prototype;

		_proto.copy = function copy(source) {
			_BufferAttribute.prototype.copy.call(this, source);

			this.meshPerAttribute = source.meshPerAttribute;
			return this;
		};

		_proto.toJSON = function toJSON() {
			var data = _BufferAttribute.prototype.toJSON.call(this);

			data.meshPerAttribute = this.meshPerAttribute;
			data.isInstancedBufferAttribute = true;
			return data;
		};

		return InstancedBufferAttribute;
	}(BufferAttribute);

	InstancedBufferAttribute.prototype.isInstancedBufferAttribute = true;

	var _instanceLocalMatrix = /*@__PURE__*/new Matrix4();

	var _instanceWorldMatrix = /*@__PURE__*/new Matrix4();

	var _instanceIntersects = [];

	var _mesh = /*@__PURE__*/new Mesh();

	var InstancedMesh = /*#__PURE__*/function (_Mesh) {
		_inheritsLoose(InstancedMesh, _Mesh);

		function InstancedMesh(geometry, material, count) {
			var _this;

			_this = _Mesh.call(this, geometry, material) || this;
			_this.instanceMatrix = new InstancedBufferAttribute(new Float32Array(count * 16), 16);
			_this.instanceColor = null;
			_this.count = count;
			_this.frustumCulled = false;
			return _this;
		}

		var _proto = InstancedMesh.prototype;

		_proto.copy = function copy(source) {
			_Mesh.prototype.copy.call(this, source);

			this.instanceMatrix.copy(source.instanceMatrix);
			if (source.instanceColor !== null) this.instanceColor = source.instanceColor.clone();
			this.count = source.count;
			return this;
		};

		_proto.getColorAt = function getColorAt(index, color) {
			color.fromArray(this.instanceColor.array, index * 3);
		};

		_proto.getMatrixAt = function getMatrixAt(index, matrix) {
			matrix.fromArray(this.instanceMatrix.array, index * 16);
		};

		_proto.raycast = function raycast(raycaster, intersects) {
			var matrixWorld = this.matrixWorld;
			var raycastTimes = this.count;
			_mesh.geometry = this.geometry;
			_mesh.material = this.material;
			if (_mesh.material === undefined) return;

			for (var instanceId = 0; instanceId < raycastTimes; instanceId++) {
				// calculate the world matrix for each instance
				this.getMatrixAt(instanceId, _instanceLocalMatrix);

				_instanceWorldMatrix.multiplyMatrices(matrixWorld, _instanceLocalMatrix); // the mesh represents this single instance


				_mesh.matrixWorld = _instanceWorldMatrix;

				_mesh.raycast(raycaster, _instanceIntersects); // process the result of raycast


				for (var i = 0, l = _instanceIntersects.length; i < l; i++) {
					var intersect = _instanceIntersects[i];
					intersect.instanceId = instanceId;
					intersect.object = this;
					intersects.push(intersect);
				}

				_instanceIntersects.length = 0;
			}
		};

		_proto.setColorAt = function setColorAt(index, color) {
			if (this.instanceColor === null) {
				this.instanceColor = new InstancedBufferAttribute(new Float32Array(this.instanceMatrix.count * 3), 3);
			}

			color.toArray(this.instanceColor.array, index * 3);
		};

		_proto.setMatrixAt = function setMatrixAt(index, matrix) {
			matrix.toArray(this.instanceMatrix.array, index * 16);
		};

		_proto.updateMorphTargets = function updateMorphTargets() {};

		_proto.dispose = function dispose() {
			this.dispatchEvent({
				type: 'dispose'
			});
		};

		return InstancedMesh;
	}(Mesh);

	InstancedMesh.prototype.isInstancedMesh = true;

	/**
	 * parameters = {
	 *	color: <hex>,
	 *	opacity: <float>,
	 *
	 *	linewidth: <float>,
	 *	linecap: "round",
	 *	linejoin: "round"
	 * }
	 */

	var LineBasicMaterial = /*#__PURE__*/function (_Material) {
		_inheritsLoose(LineBasicMaterial, _Material);

		function LineBasicMaterial(parameters) {
			var _this;

			_this = _Material.call(this) || this;
			_this.type = 'LineBasicMaterial';
			_this.color = new Color(0xffffff);
			_this.linewidth = 1;
			_this.linecap = 'round';
			_this.linejoin = 'round';

			_this.setValues(parameters);

			return _this;
		}

		var _proto = LineBasicMaterial.prototype;

		_proto.copy = function copy(source) {
			_Material.prototype.copy.call(this, source);

			this.color.copy(source.color);
			this.linewidth = source.linewidth;
			this.linecap = source.linecap;
			this.linejoin = source.linejoin;
			return this;
		};

		return LineBasicMaterial;
	}(Material);

	LineBasicMaterial.prototype.isLineBasicMaterial = true;

	var _start = /*@__PURE__*/new Vector3();

	var _end = /*@__PURE__*/new Vector3();

	var _inverseMatrix$1 = /*@__PURE__*/new Matrix4();

	var _ray$1 = /*@__PURE__*/new Ray();

	var _sphere$2 = /*@__PURE__*/new Sphere();

	var Line = /*#__PURE__*/function (_Object3D) {
		_inheritsLoose(Line, _Object3D);

		function Line(geometry, material) {
			var _this;

			if (geometry === void 0) {
				geometry = new BufferGeometry();
			}

			if (material === void 0) {
				material = new LineBasicMaterial();
			}

			_this = _Object3D.call(this) || this;
			_this.type = 'Line';
			_this.geometry = geometry;
			_this.material = material;

			_this.updateMorphTargets();

			return _this;
		}

		var _proto = Line.prototype;

		_proto.copy = function copy(source) {
			_Object3D.prototype.copy.call(this, source);

			this.material = source.material;
			this.geometry = source.geometry;
			return this;
		};

		_proto.computeLineDistances = function computeLineDistances() {
			var geometry = this.geometry;

			if (geometry.isBufferGeometry) {
				// we assume non-indexed geometry
				if (geometry.index === null) {
					var positionAttribute = geometry.attributes.position;
					var lineDistances = [0];

					for (var i = 1, l = positionAttribute.count; i < l; i++) {
						_start.fromBufferAttribute(positionAttribute, i - 1);

						_end.fromBufferAttribute(positionAttribute, i);

						lineDistances[i] = lineDistances[i - 1];
						lineDistances[i] += _start.distanceTo(_end);
					}

					geometry.setAttribute('lineDistance', new Float32BufferAttribute(lineDistances, 1));
				} else {
					console.warn('THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.');
				}
			} else if (geometry.isGeometry) {
				console.error('THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');
			}

			return this;
		};

		_proto.raycast = function raycast(raycaster, intersects) {
			var geometry = this.geometry;
			var matrixWorld = this.matrixWorld;
			var threshold = raycaster.params.Line.threshold;
			var drawRange = geometry.drawRange; // Checking boundingSphere distance to ray

			if (geometry.boundingSphere === null) geometry.computeBoundingSphere();

			_sphere$2.copy(geometry.boundingSphere);

			_sphere$2.applyMatrix4(matrixWorld);

			_sphere$2.radius += threshold;
			if (raycaster.ray.intersectsSphere(_sphere$2) === false) return; //

			_inverseMatrix$1.copy(matrixWorld).invert();

			_ray$1.copy(raycaster.ray).applyMatrix4(_inverseMatrix$1);

			var localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
			var localThresholdSq = localThreshold * localThreshold;
			var vStart = new Vector3();
			var vEnd = new Vector3();
			var interSegment = new Vector3();
			var interRay = new Vector3();
			var step = this.isLineSegments ? 2 : 1;

			if (geometry.isBufferGeometry) {
				var index = geometry.index;
				var attributes = geometry.attributes;
				var positionAttribute = attributes.position;

				if (index !== null) {
					var start = Math.max(0, drawRange.start);
					var end = Math.min(index.count, drawRange.start + drawRange.count);

					for (var i = start, l = end - 1; i < l; i += step) {
						var a = index.getX(i);
						var b = index.getX(i + 1);
						vStart.fromBufferAttribute(positionAttribute, a);
						vEnd.fromBufferAttribute(positionAttribute, b);

						var distSq = _ray$1.distanceSqToSegment(vStart, vEnd, interRay, interSegment);

						if (distSq > localThresholdSq) continue;
						interRay.applyMatrix4(this.matrixWorld); //Move back to world space for distance calculation

						var distance = raycaster.ray.origin.distanceTo(interRay);
						if (distance < raycaster.near || distance > raycaster.far) continue;
						intersects.push({
							distance: distance,
							// What do we want? intersection point on the ray or on the segment??
							// point: raycaster.ray.at( distance ),
							point: interSegment.clone().applyMatrix4(this.matrixWorld),
							index: i,
							face: null,
							faceIndex: null,
							object: this
						});
					}
				} else {
					var _start2 = Math.max(0, drawRange.start);

					var _end2 = Math.min(positionAttribute.count, drawRange.start + drawRange.count);

					for (var _i = _start2, _l = _end2 - 1; _i < _l; _i += step) {
						vStart.fromBufferAttribute(positionAttribute, _i);
						vEnd.fromBufferAttribute(positionAttribute, _i + 1);

						var _distSq = _ray$1.distanceSqToSegment(vStart, vEnd, interRay, interSegment);

						if (_distSq > localThresholdSq) continue;
						interRay.applyMatrix4(this.matrixWorld); //Move back to world space for distance calculation

						var _distance = raycaster.ray.origin.distanceTo(interRay);

						if (_distance < raycaster.near || _distance > raycaster.far) continue;
						intersects.push({
							distance: _distance,
							// What do we want? intersection point on the ray or on the segment??
							// point: raycaster.ray.at( distance ),
							point: interSegment.clone().applyMatrix4(this.matrixWorld),
							index: _i,
							face: null,
							faceIndex: null,
							object: this
						});
					}
				}
			} else if (geometry.isGeometry) {
				console.error('THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');
			}
		};

		_proto.updateMorphTargets = function updateMorphTargets() {
			var geometry = this.geometry;

			if (geometry.isBufferGeometry) {
				var morphAttributes = geometry.morphAttributes;
				var keys = Object.keys(morphAttributes);

				if (keys.length > 0) {
					var morphAttribute = morphAttributes[keys[0]];

					if (morphAttribute !== undefined) {
						this.morphTargetInfluences = [];
						this.morphTargetDictionary = {};

						for (var m = 0, ml = morphAttribute.length; m < ml; m++) {
							var name = morphAttribute[m].name || String(m);
							this.morphTargetInfluences.push(0);
							this.morphTargetDictionary[name] = m;
						}
					}
				}
			} else {
				var morphTargets = geometry.morphTargets;

				if (morphTargets !== undefined && morphTargets.length > 0) {
					console.error('THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.');
				}
			}
		};

		return Line;
	}(Object3D);

	Line.prototype.isLine = true;

	var _start$1 = /*@__PURE__*/new Vector3();

	var _end$1 = /*@__PURE__*/new Vector3();

	var LineSegments = /*#__PURE__*/function (_Line) {
		_inheritsLoose(LineSegments, _Line);

		function LineSegments(geometry, material) {
			var _this;

			_this = _Line.call(this, geometry, material) || this;
			_this.type = 'LineSegments';
			return _this;
		}

		var _proto = LineSegments.prototype;

		_proto.computeLineDistances = function computeLineDistances() {
			var geometry = this.geometry;

			if (geometry.isBufferGeometry) {
				// we assume non-indexed geometry
				if (geometry.index === null) {
					var positionAttribute = geometry.attributes.position;
					var lineDistances = [];

					for (var i = 0, l = positionAttribute.count; i < l; i += 2) {
						_start$1.fromBufferAttribute(positionAttribute, i);

						_end$1.fromBufferAttribute(positionAttribute, i + 1);

						lineDistances[i] = i === 0 ? 0 : lineDistances[i - 1];
						lineDistances[i + 1] = lineDistances[i] + _start$1.distanceTo(_end$1);
					}

					geometry.setAttribute('lineDistance', new Float32BufferAttribute(lineDistances, 1));
				} else {
					console.warn('THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.');
				}
			} else if (geometry.isGeometry) {
				console.error('THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');
			}

			return this;
		};

		return LineSegments;
	}(Line);

	LineSegments.prototype.isLineSegments = true;

	var LineLoop = /*#__PURE__*/function (_Line) {
		_inheritsLoose(LineLoop, _Line);

		function LineLoop(geometry, material) {
			var _this;

			_this = _Line.call(this, geometry, material) || this;
			_this.type = 'LineLoop';
			return _this;
		}

		return LineLoop;
	}(Line);

	LineLoop.prototype.isLineLoop = true;

	/**
	 * parameters = {
	 *	color: <hex>,
	 *	opacity: <float>,
	 *	map: new THREE.Texture( <Image> ),
	 *	alphaMap: new THREE.Texture( <Image> ),
	 *
	 *	size: <float>,
	 *	sizeAttenuation: <bool>
	 *
	 * }
	 */

	var PointsMaterial = /*#__PURE__*/function (_Material) {
		_inheritsLoose(PointsMaterial, _Material);

		function PointsMaterial(parameters) {
			var _this;

			_this = _Material.call(this) || this;
			_this.type = 'PointsMaterial';
			_this.color = new Color(0xffffff);
			_this.map = null;
			_this.alphaMap = null;
			_this.size = 1;
			_this.sizeAttenuation = true;

			_this.setValues(parameters);

			return _this;
		}

		var _proto = PointsMaterial.prototype;

		_proto.copy = function copy(source) {
			_Material.prototype.copy.call(this, source);

			this.color.copy(source.color);
			this.map = source.map;
			this.alphaMap = source.alphaMap;
			this.size = source.size;
			this.sizeAttenuation = source.sizeAttenuation;
			return this;
		};

		return PointsMaterial;
	}(Material);

	PointsMaterial.prototype.isPointsMaterial = true;

	var _inverseMatrix$2 = /*@__PURE__*/new Matrix4();

	var _ray$2 = /*@__PURE__*/new Ray();

	var _sphere$3 = /*@__PURE__*/new Sphere();

	var _position$1 = /*@__PURE__*/new Vector3();

	var Points = /*#__PURE__*/function (_Object3D) {
		_inheritsLoose(Points, _Object3D);

		function Points(geometry, material) {
			var _this;

			if (geometry === void 0) {
				geometry = new BufferGeometry();
			}

			if (material === void 0) {
				material = new PointsMaterial();
			}

			_this = _Object3D.call(this) || this;
			_this.type = 'Points';
			_this.geometry = geometry;
			_this.material = material;

			_this.updateMorphTargets();

			return _this;
		}

		var _proto = Points.prototype;

		_proto.copy = function copy(source) {
			_Object3D.prototype.copy.call(this, source);

			this.material = source.material;
			this.geometry = source.geometry;
			return this;
		};

		_proto.raycast = function raycast(raycaster, intersects) {
			var geometry = this.geometry;
			var matrixWorld = this.matrixWorld;
			var threshold = raycaster.params.Points.threshold;
			var drawRange = geometry.drawRange; // Checking boundingSphere distance to ray

			if (geometry.boundingSphere === null) geometry.computeBoundingSphere();

			_sphere$3.copy(geometry.boundingSphere);

			_sphere$3.applyMatrix4(matrixWorld);

			_sphere$3.radius += threshold;
			if (raycaster.ray.intersectsSphere(_sphere$3) === false) return; //

			_inverseMatrix$2.copy(matrixWorld).invert();

			_ray$2.copy(raycaster.ray).applyMatrix4(_inverseMatrix$2);

			var localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
			var localThresholdSq = localThreshold * localThreshold;

			if (geometry.isBufferGeometry) {
				var index = geometry.index;
				var attributes = geometry.attributes;
				var positionAttribute = attributes.position;

				if (index !== null) {
					var start = Math.max(0, drawRange.start);
					var end = Math.min(index.count, drawRange.start + drawRange.count);

					for (var i = start, il = end; i < il; i++) {
						var a = index.getX(i);

						_position$1.fromBufferAttribute(positionAttribute, a);

						testPoint(_position$1, a, localThresholdSq, matrixWorld, raycaster, intersects, this);
					}
				} else {
					var _start = Math.max(0, drawRange.start);

					var _end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);

					for (var _i = _start, l = _end; _i < l; _i++) {
						_position$1.fromBufferAttribute(positionAttribute, _i);

						testPoint(_position$1, _i, localThresholdSq, matrixWorld, raycaster, intersects, this);
					}
				}
			} else {
				console.error('THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');
			}
		};

		_proto.updateMorphTargets = function updateMorphTargets() {
			var geometry = this.geometry;

			if (geometry.isBufferGeometry) {
				var morphAttributes = geometry.morphAttributes;
				var keys = Object.keys(morphAttributes);

				if (keys.length > 0) {
					var morphAttribute = morphAttributes[keys[0]];

					if (morphAttribute !== undefined) {
						this.morphTargetInfluences = [];
						this.morphTargetDictionary = {};

						for (var m = 0, ml = morphAttribute.length; m < ml; m++) {
							var name = morphAttribute[m].name || String(m);
							this.morphTargetInfluences.push(0);
							this.morphTargetDictionary[name] = m;
						}
					}
				}
			} else {
				var morphTargets = geometry.morphTargets;

				if (morphTargets !== undefined && morphTargets.length > 0) {
					console.error('THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.');
				}
			}
		};

		return Points;
	}(Object3D);

	Points.prototype.isPoints = true;

	function testPoint(point, index, localThresholdSq, matrixWorld, raycaster, intersects, object) {
		var rayPointDistanceSq = _ray$2.distanceSqToPoint(point);

		if (rayPointDistanceSq < localThresholdSq) {
			var intersectPoint = new Vector3();

			_ray$2.closestPointToPoint(point, intersectPoint);

			intersectPoint.applyMatrix4(matrixWorld);
			var distance = raycaster.ray.origin.distanceTo(intersectPoint);
			if (distance < raycaster.near || distance > raycaster.far) return;
			intersects.push({
				distance: distance,
				distanceToRay: Math.sqrt(rayPointDistanceSq),
				point: intersectPoint,
				index: index,
				face: null,
				object: object
			});
		}
	}

	var VideoTexture = /*#__PURE__*/function (_Texture) {
		_inheritsLoose(VideoTexture, _Texture);

		function VideoTexture(video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
			var _this;

			_this = _Texture.call(this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) || this;
			_this.format = format !== undefined ? format : RGBFormat;
			_this.minFilter = minFilter !== undefined ? minFilter : LinearFilter;
			_this.magFilter = magFilter !== undefined ? magFilter : LinearFilter;
			_this.generateMipmaps = false;

			var scope = _assertThisInitialized(_this);

			function updateVideo() {
				scope.needsUpdate = true;
				video.requestVideoFrameCallback(updateVideo);
			}

			if ('requestVideoFrameCallback' in video) {
				video.requestVideoFrameCallback(updateVideo);
			}

			return _this;
		}

		var _proto = VideoTexture.prototype;

		_proto.clone = function clone() {
			return new this.constructor(this.image).copy(this);
		};

		_proto.update = function update() {
			var video = this.image;
			var hasVideoFrameCallback = ('requestVideoFrameCallback' in video);

			if (hasVideoFrameCallback === false && video.readyState >= video.HAVE_CURRENT_DATA) {
				this.needsUpdate = true;
			}
		};

		return VideoTexture;
	}(Texture);

	VideoTexture.prototype.isVideoTexture = true;

	var CompressedTexture = /*#__PURE__*/function (_Texture) {
		_inheritsLoose(CompressedTexture, _Texture);

		function CompressedTexture(mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding) {
			var _this;

			_this = _Texture.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding) || this;
			_this.image = {
				width: width,
				height: height
			};
			_this.mipmaps = mipmaps; // no flipping for cube textures
			// (also flipping doesn't work for compressed textures )

			_this.flipY = false; // can't generate mipmaps for compressed textures
			// mips must be embedded in DDS files

			_this.generateMipmaps = false;
			return _this;
		}

		return CompressedTexture;
	}(Texture);

	CompressedTexture.prototype.isCompressedTexture = true;

	var CanvasTexture = /*#__PURE__*/function (_Texture) {
		_inheritsLoose(CanvasTexture, _Texture);

		function CanvasTexture(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
			var _this;

			_this = _Texture.call(this, canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) || this;
			_this.needsUpdate = true;
			return _this;
		}

		return CanvasTexture;
	}(Texture);

	CanvasTexture.prototype.isCanvasTexture = true;

	var DepthTexture = /*#__PURE__*/function (_Texture) {
		_inheritsLoose(DepthTexture, _Texture);

		function DepthTexture(width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format) {
			var _this;

			format = format !== undefined ? format : DepthFormat;

			if (format !== DepthFormat && format !== DepthStencilFormat) {
				throw new Error('DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat');
			}

			if (type === undefined && format === DepthFormat) type = UnsignedShortType;
			if (type === undefined && format === DepthStencilFormat) type = UnsignedInt248Type;
			_this = _Texture.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) || this;
			_this.image = {
				width: width,
				height: height
			};
			_this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
			_this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;
			_this.flipY = false;
			_this.generateMipmaps = false;
			return _this;
		}

		return DepthTexture;
	}(Texture);

	DepthTexture.prototype.isDepthTexture = true;

	var CircleGeometry = /*#__PURE__*/function (_BufferGeometry) {
		_inheritsLoose(CircleGeometry, _BufferGeometry);

		function CircleGeometry(radius, segments, thetaStart, thetaLength) {
			var _this;

			if (radius === void 0) {
				radius = 1;
			}

			if (segments === void 0) {
				segments = 8;
			}

			if (thetaStart === void 0) {
				thetaStart = 0;
			}

			if (thetaLength === void 0) {
				thetaLength = Math.PI * 2;
			}

			_this = _BufferGeometry.call(this) || this;
			_this.type = 'CircleGeometry';
			_this.parameters = {
				radius: radius,
				segments: segments,
				thetaStart: thetaStart,
				thetaLength: thetaLength
			};
			segments = Math.max(3, segments); // buffers

			var indices = [];
			var vertices = [];
			var normals = [];
			var uvs = []; // helper variables

			var vertex = new Vector3();
			var uv = new Vector2(); // center point

			vertices.push(0, 0, 0);
			normals.push(0, 0, 1);
			uvs.push(0.5, 0.5);

			for (var s = 0, i = 3; s <= segments; s++, i += 3) {
				var segment = thetaStart + s / segments * thetaLength; // vertex

				vertex.x = radius * Math.cos(segment);
				vertex.y = radius * Math.sin(segment);
				vertices.push(vertex.x, vertex.y, vertex.z); // normal

				normals.push(0, 0, 1); // uvs

				uv.x = (vertices[i] / radius + 1) / 2;
				uv.y = (vertices[i + 1] / radius + 1) / 2;
				uvs.push(uv.x, uv.y);
			} // indices


			for (var _i = 1; _i <= segments; _i++) {
				indices.push(_i, _i + 1, 0);
			} // build geometry


			_this.setIndex(indices);

			_this.setAttribute('position', new Float32BufferAttribute(vertices, 3));

			_this.setAttribute('normal', new Float32BufferAttribute(normals, 3));

			_this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));

			return _this;
		}

		CircleGeometry.fromJSON = function fromJSON(data) {
			return new CircleGeometry(data.radius, data.segments, data.thetaStart, data.thetaLength);
		};

		return CircleGeometry;
	}(BufferGeometry);

	var CylinderGeometry = /*#__PURE__*/function (_BufferGeometry) {
		_inheritsLoose(CylinderGeometry, _BufferGeometry);

		function CylinderGeometry(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
			var _this;

			if (radiusTop === void 0) {
				radiusTop = 1;
			}

			if (radiusBottom === void 0) {
				radiusBottom = 1;
			}

			if (height === void 0) {
				height = 1;
			}

			if (radialSegments === void 0) {
				radialSegments = 8;
			}

			if (heightSegments === void 0) {
				heightSegments = 1;
			}

			if (openEnded === void 0) {
				openEnded = false;
			}

			if (thetaStart === void 0) {
				thetaStart = 0;
			}

			if (thetaLength === void 0) {
				thetaLength = Math.PI * 2;
			}

			_this = _BufferGeometry.call(this) || this;
			_this.type = 'CylinderGeometry';
			_this.parameters = {
				radiusTop: radiusTop,
				radiusBottom: radiusBottom,
				height: height,
				radialSegments: radialSegments,
				heightSegments: heightSegments,
				openEnded: openEnded,
				thetaStart: thetaStart,
				thetaLength: thetaLength
			};

			var scope = _assertThisInitialized(_this);

			radialSegments = Math.floor(radialSegments);
			heightSegments = Math.floor(heightSegments); // buffers

			var indices = [];
			var vertices = [];
			var normals = [];
			var uvs = []; // helper variables

			var index = 0;
			var indexArray = [];
			var halfHeight = height / 2;
			var groupStart = 0; // generate geometry

			generateTorso();

			if (openEnded === false) {
				if (radiusTop > 0) generateCap(true);
				if (radiusBottom > 0) generateCap(false);
			} // build geometry


			_this.setIndex(indices);

			_this.setAttribute('position', new Float32BufferAttribute(vertices, 3));

			_this.setAttribute('normal', new Float32BufferAttribute(normals, 3));

			_this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));

			function generateTorso() {
				var normal = new Vector3();
				var vertex = new Vector3();
				var groupCount = 0; // this will be used to calculate the normal

				var slope = (radiusBottom - radiusTop) / height; // generate vertices, normals and uvs

				for (var y = 0; y <= heightSegments; y++) {
					var indexRow = [];
					var v = y / heightSegments; // calculate the radius of the current row

					var radius = v * (radiusBottom - radiusTop) + radiusTop;

					for (var x = 0; x <= radialSegments; x++) {
						var u = x / radialSegments;
						var theta = u * thetaLength + thetaStart;
						var sinTheta = Math.sin(theta);
						var cosTheta = Math.cos(theta); // vertex

						vertex.x = radius * sinTheta;
						vertex.y = -v * height + halfHeight;
						vertex.z = radius * cosTheta;
						vertices.push(vertex.x, vertex.y, vertex.z); // normal

						normal.set(sinTheta, slope, cosTheta).normalize();
						normals.push(normal.x, normal.y, normal.z); // uv

						uvs.push(u, 1 - v); // save index of vertex in respective row

						indexRow.push(index++);
					} // now save vertices of the row in our index array


					indexArray.push(indexRow);
				} // generate indices


				for (var _x = 0; _x < radialSegments; _x++) {
					for (var _y = 0; _y < heightSegments; _y++) {
						// we use the index array to access the correct indices
						var a = indexArray[_y][_x];
						var b = indexArray[_y + 1][_x];
						var c = indexArray[_y + 1][_x + 1];
						var d = indexArray[_y][_x + 1]; // faces

						indices.push(a, b, d);
						indices.push(b, c, d); // update group counter

						groupCount += 6;
					}
				} // add a group to the geometry. this will ensure multi material support


				scope.addGroup(groupStart, groupCount, 0); // calculate new start value for groups

				groupStart += groupCount;
			}

			function generateCap(top) {
				// save the index of the first center vertex
				var centerIndexStart = index;
				var uv = new Vector2();
				var vertex = new Vector3();
				var groupCount = 0;
				var radius = top === true ? radiusTop : radiusBottom;
				var sign = top === true ? 1 : -1; // first we generate the center vertex data of the cap.
				// because the geometry needs one set of uvs per face,
				// we must generate a center vertex per face/segment

				for (var x = 1; x <= radialSegments; x++) {
					// vertex
					vertices.push(0, halfHeight * sign, 0); // normal

					normals.push(0, sign, 0); // uv

					uvs.push(0.5, 0.5); // increase index

					index++;
				} // save the index of the last center vertex


				var centerIndexEnd = index; // now we generate the surrounding vertices, normals and uvs

				for (var _x2 = 0; _x2 <= radialSegments; _x2++) {
					var u = _x2 / radialSegments;
					var theta = u * thetaLength + thetaStart;
					var cosTheta = Math.cos(theta);
					var sinTheta = Math.sin(theta); // vertex

					vertex.x = radius * sinTheta;
					vertex.y = halfHeight * sign;
					vertex.z = radius * cosTheta;
					vertices.push(vertex.x, vertex.y, vertex.z); // normal

					normals.push(0, sign, 0); // uv

					uv.x = cosTheta * 0.5 + 0.5;
					uv.y = sinTheta * 0.5 * sign + 0.5;
					uvs.push(uv.x, uv.y); // increase index

					index++;
				} // generate indices


				for (var _x3 = 0; _x3 < radialSegments; _x3++) {
					var c = centerIndexStart + _x3;
					var i = centerIndexEnd + _x3;

					if (top === true) {
						// face top
						indices.push(i, i + 1, c);
					} else {
						// face bottom
						indices.push(i + 1, i, c);
					}

					groupCount += 3;
				} // add a group to the geometry. this will ensure multi material support


				scope.addGroup(groupStart, groupCount, top === true ? 1 : 2); // calculate new start value for groups

				groupStart += groupCount;
			}

			return _this;
		}

		CylinderGeometry.fromJSON = function fromJSON(data) {
			return new CylinderGeometry(data.radiusTop, data.radiusBottom, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);
		};

		return CylinderGeometry;
	}(BufferGeometry);

	var ConeGeometry = /*#__PURE__*/function (_CylinderGeometry) {
		_inheritsLoose(ConeGeometry, _CylinderGeometry);

		function ConeGeometry(radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
			var _this;

			if (radius === void 0) {
				radius = 1;
			}

			if (height === void 0) {
				height = 1;
			}

			if (radialSegments === void 0) {
				radialSegments = 8;
			}

			if (heightSegments === void 0) {
				heightSegments = 1;
			}

			if (openEnded === void 0) {
				openEnded = false;
			}

			if (thetaStart === void 0) {
				thetaStart = 0;
			}

			if (thetaLength === void 0) {
				thetaLength = Math.PI * 2;
			}

			_this = _CylinderGeometry.call(this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) || this;
			_this.type = 'ConeGeometry';
			_this.parameters = {
				radius: radius,
				height: height,
				radialSegments: radialSegments,
				heightSegments: heightSegments,
				openEnded: openEnded,
				thetaStart: thetaStart,
				thetaLength: thetaLength
			};
			return _this;
		}

		ConeGeometry.fromJSON = function fromJSON(data) {
			return new ConeGeometry(data.radius, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);
		};

		return ConeGeometry;
	}(CylinderGeometry);

	var PolyhedronGeometry = /*#__PURE__*/function (_BufferGeometry) {
		_inheritsLoose(PolyhedronGeometry, _BufferGeometry);

		function PolyhedronGeometry(vertices, indices, radius, detail) {
			var _this;

			if (vertices === void 0) {
				vertices = [];
			}

			if (indices === void 0) {
				indices = [];
			}

			if (radius === void 0) {
				radius = 1;
			}

			if (detail === void 0) {
				detail = 0;
			}

			_this = _BufferGeometry.call(this) || this;
			_this.type = 'PolyhedronGeometry';
			_this.parameters = {
				vertices: vertices,
				indices: indices,
				radius: radius,
				detail: detail
			}; // default buffer data

			var vertexBuffer = [];
			var uvBuffer = []; // the subdivision creates the vertex buffer data

			subdivide(detail); // all vertices should lie on a conceptual sphere with a given radius

			applyRadius(radius); // finally, create the uv data

			generateUVs(); // build non-indexed geometry

			_this.setAttribute('position', new Float32BufferAttribute(vertexBuffer, 3));

			_this.setAttribute('normal', new Float32BufferAttribute(vertexBuffer.slice(), 3));

			_this.setAttribute('uv', new Float32BufferAttribute(uvBuffer, 2));

			if (detail === 0) {
				_this.computeVertexNormals(); // flat normals

			} else {
				_this.normalizeNormals(); // smooth normals

			} // helper functions


			function subdivide(detail) {
				var a = new Vector3();
				var b = new Vector3();
				var c = new Vector3(); // iterate over all faces and apply a subdivison with the given detail value

				for (var i = 0; i < indices.length; i += 3) {
					// get the vertices of the face
					getVertexByIndex(indices[i + 0], a);
					getVertexByIndex(indices[i + 1], b);
					getVertexByIndex(indices[i + 2], c); // perform subdivision

					subdivideFace(a, b, c, detail);
				}
			}

			function subdivideFace(a, b, c, detail) {
				var cols = detail + 1; // we use this multidimensional array as a data structure for creating the subdivision

				var v = []; // construct all of the vertices for this subdivision

				for (var i = 0; i <= cols; i++) {
					v[i] = [];
					var aj = a.clone().lerp(c, i / cols);
					var bj = b.clone().lerp(c, i / cols);
					var rows = cols - i;

					for (var j = 0; j <= rows; j++) {
						if (j === 0 && i === cols) {
							v[i][j] = aj;
						} else {
							v[i][j] = aj.clone().lerp(bj, j / rows);
						}
					}
				} // construct all of the faces


				for (var _i = 0; _i < cols; _i++) {
					for (var _j = 0; _j < 2 * (cols - _i) - 1; _j++) {
						var k = Math.floor(_j / 2);

						if (_j % 2 === 0) {
							pushVertex(v[_i][k + 1]);
							pushVertex(v[_i + 1][k]);
							pushVertex(v[_i][k]);
						} else {
							pushVertex(v[_i][k + 1]);
							pushVertex(v[_i + 1][k + 1]);
							pushVertex(v[_i + 1][k]);
						}
					}
				}
			}

			function applyRadius(radius) {
				var vertex = new Vector3(); // iterate over the entire buffer and apply the radius to each vertex

				for (var i = 0; i < vertexBuffer.length; i += 3) {
					vertex.x = vertexBuffer[i + 0];
					vertex.y = vertexBuffer[i + 1];
					vertex.z = vertexBuffer[i + 2];
					vertex.normalize().multiplyScalar(radius);
					vertexBuffer[i + 0] = vertex.x;
					vertexBuffer[i + 1] = vertex.y;
					vertexBuffer[i + 2] = vertex.z;
				}
			}

			function generateUVs() {
				var vertex = new Vector3();

				for (var i = 0; i < vertexBuffer.length; i += 3) {
					vertex.x = vertexBuffer[i + 0];
					vertex.y = vertexBuffer[i + 1];
					vertex.z = vertexBuffer[i + 2];
					var u = azimuth(vertex) / 2 / Math.PI + 0.5;
					var v = inclination(vertex) / Math.PI + 0.5;
					uvBuffer.push(u, 1 - v);
				}

				correctUVs();
				correctSeam();
			}

			function correctSeam() {
				// handle case when face straddles the seam, see #3269
				for (var i = 0; i < uvBuffer.length; i += 6) {
					// uv data of a single face
					var x0 = uvBuffer[i + 0];
					var x1 = uvBuffer[i + 2];
					var x2 = uvBuffer[i + 4];
					var max = Math.max(x0, x1, x2);
					var min = Math.min(x0, x1, x2); // 0.9 is somewhat arbitrary

					if (max > 0.9 && min < 0.1) {
						if (x0 < 0.2) uvBuffer[i + 0] += 1;
						if (x1 < 0.2) uvBuffer[i + 2] += 1;
						if (x2 < 0.2) uvBuffer[i + 4] += 1;
					}
				}
			}

			function pushVertex(vertex) {
				vertexBuffer.push(vertex.x, vertex.y, vertex.z);
			}

			function getVertexByIndex(index, vertex) {
				var stride = index * 3;
				vertex.x = vertices[stride + 0];
				vertex.y = vertices[stride + 1];
				vertex.z = vertices[stride + 2];
			}

			function correctUVs() {
				var a = new Vector3();
				var b = new Vector3();
				var c = new Vector3();
				var centroid = new Vector3();
				var uvA = new Vector2();
				var uvB = new Vector2();
				var uvC = new Vector2();

				for (var i = 0, j = 0; i < vertexBuffer.length; i += 9, j += 6) {
					a.set(vertexBuffer[i + 0], vertexBuffer[i + 1], vertexBuffer[i + 2]);
					b.set(vertexBuffer[i + 3], vertexBuffer[i + 4], vertexBuffer[i + 5]);
					c.set(vertexBuffer[i + 6], vertexBuffer[i + 7], vertexBuffer[i + 8]);
					uvA.set(uvBuffer[j + 0], uvBuffer[j + 1]);
					uvB.set(uvBuffer[j + 2], uvBuffer[j + 3]);
					uvC.set(uvBuffer[j + 4], uvBuffer[j + 5]);
					centroid.copy(a).add(b).add(c).divideScalar(3);
					var azi = azimuth(centroid);
					correctUV(uvA, j + 0, a, azi);
					correctUV(uvB, j + 2, b, azi);
					correctUV(uvC, j + 4, c, azi);
				}
			}

			function correctUV(uv, stride, vector, azimuth) {
				if (azimuth < 0 && uv.x === 1) {
					uvBuffer[stride] = uv.x - 1;
				}

				if (vector.x === 0 && vector.z === 0) {
					uvBuffer[stride] = azimuth / 2 / Math.PI + 0.5;
				}
			} // Angle around the Y axis, counter-clockwise when looking from above.


			function azimuth(vector) {
				return Math.atan2(vector.z, -vector.x);
			} // Angle above the XZ plane.


			function inclination(vector) {
				return Math.atan2(-vector.y, Math.sqrt(vector.x * vector.x + vector.z * vector.z));
			}

			return _this;
		}

		PolyhedronGeometry.fromJSON = function fromJSON(data) {
			return new PolyhedronGeometry(data.vertices, data.indices, data.radius, data.details);
		};

		return PolyhedronGeometry;
	}(BufferGeometry);

	var DodecahedronGeometry = /*#__PURE__*/function (_PolyhedronGeometry) {
		_inheritsLoose(DodecahedronGeometry, _PolyhedronGeometry);

		function DodecahedronGeometry(radius, detail) {
			var _this;

			if (radius === void 0) {
				radius = 1;
			}

			if (detail === void 0) {
				detail = 0;
			}

			var t = (1 + Math.sqrt(5)) / 2;
			var r = 1 / t;
			var vertices = [// (±1, ±1, ±1)
			-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, // (0, ±1/φ, ±φ)
			0, -r, -t, 0, -r, t, 0, r, -t, 0, r, t, // (±1/φ, ±φ, 0)
			-r, -t, 0, -r, t, 0, r, -t, 0, r, t, 0, // (±φ, 0, ±1/φ)
			-t, 0, -r, t, 0, -r, -t, 0, r, t, 0, r];
			var indices = [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9];
			_this = _PolyhedronGeometry.call(this, vertices, indices, radius, detail) || this;
			_this.type = 'DodecahedronGeometry';
			_this.parameters = {
				radius: radius,
				detail: detail
			};
			return _this;
		}

		DodecahedronGeometry.fromJSON = function fromJSON(data) {
			return new DodecahedronGeometry(data.radius, data.detail);
		};

		return DodecahedronGeometry;
	}(PolyhedronGeometry);

	var _v0$2 = new Vector3();

	var _v1$6 = new Vector3();

	var _normal$1 = new Vector3();

	var _triangle = new Triangle();

	var EdgesGeometry = /*#__PURE__*/function (_BufferGeometry) {
		_inheritsLoose(EdgesGeometry, _BufferGeometry);

		function EdgesGeometry(geometry, thresholdAngle) {
			var _this;

			if (geometry === void 0) {
				geometry = null;
			}

			if (thresholdAngle === void 0) {
				thresholdAngle = 1;
			}

			_this = _BufferGeometry.call(this) || this;
			_this.type = 'EdgesGeometry';
			_this.parameters = {
				geometry: geometry,
				thresholdAngle: thresholdAngle
			};

			if (geometry !== null) {
				var precisionPoints = 4;
				var precision = Math.pow(10, precisionPoints);
				var thresholdDot = Math.cos(DEG2RAD * thresholdAngle);
				var indexAttr = geometry.getIndex();
				var positionAttr = geometry.getAttribute('position');
				var indexCount = indexAttr ? indexAttr.count : positionAttr.count;
				var indexArr = [0, 0, 0];
				var vertKeys = ['a', 'b', 'c'];
				var hashes = new Array(3);
				var edgeData = {};
				var vertices = [];

				for (var i = 0; i < indexCount; i += 3) {
					if (indexAttr) {
						indexArr[0] = indexAttr.getX(i);
						indexArr[1] = indexAttr.getX(i + 1);
						indexArr[2] = indexAttr.getX(i + 2);
					} else {
						indexArr[0] = i;
						indexArr[1] = i + 1;
						indexArr[2] = i + 2;
					}

					var a = _triangle.a,
							b = _triangle.b,
							c = _triangle.c;
					a.fromBufferAttribute(positionAttr, indexArr[0]);
					b.fromBufferAttribute(positionAttr, indexArr[1]);
					c.fromBufferAttribute(positionAttr, indexArr[2]);

					_triangle.getNormal(_normal$1); // create hashes for the edge from the vertices


					hashes[0] = Math.round(a.x * precision) + "," + Math.round(a.y * precision) + "," + Math.round(a.z * precision);
					hashes[1] = Math.round(b.x * precision) + "," + Math.round(b.y * precision) + "," + Math.round(b.z * precision);
					hashes[2] = Math.round(c.x * precision) + "," + Math.round(c.y * precision) + "," + Math.round(c.z * precision); // skip degenerate triangles

					if (hashes[0] === hashes[1] || hashes[1] === hashes[2] || hashes[2] === hashes[0]) {
						continue;
					} // iterate over every edge


					for (var j = 0; j < 3; j++) {
						// get the first and next vertex making up the edge
						var jNext = (j + 1) % 3;
						var vecHash0 = hashes[j];
						var vecHash1 = hashes[jNext];
						var v0 = _triangle[vertKeys[j]];
						var v1 = _triangle[vertKeys[jNext]];
						var hash = vecHash0 + "_" + vecHash1;
						var reverseHash = vecHash1 + "_" + vecHash0;

						if (reverseHash in edgeData && edgeData[reverseHash]) {
							// if we found a sibling edge add it into the vertex array if
							// it meets the angle threshold and delete the edge from the map.
							if (_normal$1.dot(edgeData[reverseHash].normal) <= thresholdDot) {
								vertices.push(v0.x, v0.y, v0.z);
								vertices.push(v1.x, v1.y, v1.z);
							}

							edgeData[reverseHash] = null;
						} else if (!(hash in edgeData)) {
							// if we've already got an edge here then skip adding a new one
							edgeData[hash] = {
								index0: indexArr[j],
								index1: indexArr[jNext],
								normal: _normal$1.clone()
							};
						}
					}
				} // iterate over all remaining, unmatched edges and add them to the vertex array


				for (var key in edgeData) {
					if (edgeData[key]) {
						var _edgeData$key = edgeData[key],
								index0 = _edgeData$key.index0,
								index1 = _edgeData$key.index1;

						_v0$2.fromBufferAttribute(positionAttr, index0);

						_v1$6.fromBufferAttribute(positionAttr, index1);

						vertices.push(_v0$2.x, _v0$2.y, _v0$2.z);
						vertices.push(_v1$6.x, _v1$6.y, _v1$6.z);
					}
				}

				_this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
			}

			return _this;
		}

		return EdgesGeometry;
	}(BufferGeometry);

	/**
	 * Extensible curve object.
	 *
	 * Some common of curve methods:
	 * .getPoint( t, optionalTarget ), .getTangent( t, optionalTarget )
	 * .getPointAt( u, optionalTarget ), .getTangentAt( u, optionalTarget )
	 * .getPoints(), .getSpacedPoints()
	 * .getLength()
	 * .updateArcLengths()
	 *
	 * This following curves inherit from THREE.Curve:
	 *
	 * -- 2D curves --
	 * THREE.ArcCurve
	 * THREE.CubicBezierCurve
	 * THREE.EllipseCurve
	 * THREE.LineCurve
	 * THREE.QuadraticBezierCurve
	 * THREE.SplineCurve
	 *
	 * -- 3D curves --
	 * THREE.CatmullRomCurve3
	 * THREE.CubicBezierCurve3
	 * THREE.LineCurve3
	 * THREE.QuadraticBezierCurve3
	 *
	 * A series of curves can be represented as a THREE.CurvePath.
	 *
	 **/

	var Curve = /*#__PURE__*/function () {
		function Curve() {
			this.type = 'Curve';
			this.arcLengthDivisions = 200;
		} // Virtual base class method to overwrite and implement in subclasses
		//	- t [0 .. 1]


		var _proto = Curve.prototype;

		_proto.getPoint = function getPoint()
		/* t, optionalTarget */
		{
			console.warn('THREE.Curve: .getPoint() not implemented.');
			return null;
		} // Get point at relative position in curve according to arc length
		// - u [0 .. 1]
		;

		_proto.getPointAt = function getPointAt(u, optionalTarget) {
			var t = this.getUtoTmapping(u);
			return this.getPoint(t, optionalTarget);
		} // Get sequence of points using getPoint( t )
		;

		_proto.getPoints = function getPoints(divisions) {
			if (divisions === void 0) {
				divisions = 5;
			}

			var points = [];

			for (var d = 0; d <= divisions; d++) {
				points.push(this.getPoint(d / divisions));
			}

			return points;
		} // Get sequence of points using getPointAt( u )
		;

		_proto.getSpacedPoints = function getSpacedPoints(divisions) {
			if (divisions === void 0) {
				divisions = 5;
			}

			var points = [];

			for (var d = 0; d <= divisions; d++) {
				points.push(this.getPointAt(d / divisions));
			}

			return points;
		} // Get total curve arc length
		;

		_proto.getLength = function getLength() {
			var lengths = this.getLengths();
			return lengths[lengths.length - 1];
		} // Get list of cumulative segment lengths
		;

		_proto.getLengths = function getLengths(divisions) {
			if (divisions === void 0) {
				divisions = this.arcLengthDivisions;
			}

			if (this.cacheArcLengths && this.cacheArcLengths.length === divisions + 1 && !this.needsUpdate) {
				return this.cacheArcLengths;
			}

			this.needsUpdate = false;
			var cache = [];
			var current,
					last = this.getPoint(0);
			var sum = 0;
			cache.push(0);

			for (var p = 1; p <= divisions; p++) {
				current = this.getPoint(p / divisions);
				sum += current.distanceTo(last);
				cache.push(sum);
				last = current;
			}

			this.cacheArcLengths = cache;
			return cache; // { sums: cache, sum: sum }; Sum is in the last element.
		};

		_proto.updateArcLengths = function updateArcLengths() {
			this.needsUpdate = true;
			this.getLengths();
		} // Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant
		;

		_proto.getUtoTmapping = function getUtoTmapping(u, distance) {
			var arcLengths = this.getLengths();
			var i = 0;
			var il = arcLengths.length;
			var targetArcLength; // The targeted u distance value to get

			if (distance) {
				targetArcLength = distance;
			} else {
				targetArcLength = u * arcLengths[il - 1];
			} // binary search for the index with largest value smaller than target u distance


			var low = 0,
					high = il - 1,
					comparison;

			while (low <= high) {
				i = Math.floor(low + (high - low) / 2); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats

				comparison = arcLengths[i] - targetArcLength;

				if (comparison < 0) {
					low = i + 1;
				} else if (comparison > 0) {
					high = i - 1;
				} else {
					high = i;
					break; // DONE
				}
			}

			i = high;

			if (arcLengths[i] === targetArcLength) {
				return i / (il - 1);
			} // we could get finer grain at lengths, or use simple interpolation between two points


			var lengthBefore = arcLengths[i];
			var lengthAfter = arcLengths[i + 1];
			var segmentLength = lengthAfter - lengthBefore; // determine where we are between the 'before' and 'after' points

			var segmentFraction = (targetArcLength - lengthBefore) / segmentLength; // add that fractional amount to t

			var t = (i + segmentFraction) / (il - 1);
			return t;
		} // Returns a unit vector tangent at t
		// In case any sub curve does not implement its tangent derivation,
		// 2 points a small delta apart will be used to find its gradient
		// which seems to give a reasonable approximation
		;

		_proto.getTangent = function getTangent(t, optionalTarget) {
			var delta = 0.0001;
			var t1 = t - delta;
			var t2 = t + delta; // Capping in case of danger

			if (t1 < 0) t1 = 0;
			if (t2 > 1) t2 = 1;
			var pt1 = this.getPoint(t1);
			var pt2 = this.getPoint(t2);
			var tangent = optionalTarget || (pt1.isVector2 ? new Vector2() : new Vector3());
			tangent.copy(pt2).sub(pt1).normalize();
			return tangent;
		};

		_proto.getTangentAt = function getTangentAt(u, optionalTarget) {
			var t = this.getUtoTmapping(u);
			return this.getTangent(t, optionalTarget);
		};

		_proto.computeFrenetFrames = function computeFrenetFrames(segments, closed) {
			// see http://www.cs.indiana.edu/pub/techreports/TR425.pdf
			var normal = new Vector3();
			var tangents = [];
			var normals = [];
			var binormals = [];
			var vec = new Vector3();
			var mat = new Matrix4(); // compute the tangent vectors for each segment on the curve

			for (var i = 0; i <= segments; i++) {
				var u = i / segments;
				tangents[i] = this.getTangentAt(u, new Vector3());
			} // select an initial normal vector perpendicular to the first tangent vector,
			// and in the direction of the minimum tangent xyz component


			normals[0] = new Vector3();
			binormals[0] = new Vector3();
			var min = Number.MAX_VALUE;
			var tx = Math.abs(tangents[0].x);
			var ty = Math.abs(tangents[0].y);
			var tz = Math.abs(tangents[0].z);

			if (tx <= min) {
				min = tx;
				normal.set(1, 0, 0);
			}

			if (ty <= min) {
				min = ty;
				normal.set(0, 1, 0);
			}

			if (tz <= min) {
				normal.set(0, 0, 1);
			}

			vec.crossVectors(tangents[0], normal).normalize();
			normals[0].crossVectors(tangents[0], vec);
			binormals[0].crossVectors(tangents[0], normals[0]); // compute the slowly-varying normal and binormal vectors for each segment on the curve

			for (var _i = 1; _i <= segments; _i++) {
				normals[_i] = normals[_i - 1].clone();
				binormals[_i] = binormals[_i - 1].clone();
				vec.crossVectors(tangents[_i - 1], tangents[_i]);

				if (vec.length() > Number.EPSILON) {
					vec.normalize();
					var theta = Math.acos(clamp(tangents[_i - 1].dot(tangents[_i]), -1, 1)); // clamp for floating pt errors

					normals[_i].applyMatrix4(mat.makeRotationAxis(vec, theta));
				}

				binormals[_i].crossVectors(tangents[_i], normals[_i]);
			} // if the curve is closed, postprocess the vectors so the first and last normal vectors are the same


			if (closed === true) {
				var _theta = Math.acos(clamp(normals[0].dot(normals[segments]), -1, 1));

				_theta /= segments;

				if (tangents[0].dot(vec.crossVectors(normals[0], normals[segments])) > 0) {
					_theta = -_theta;
				}

				for (var _i2 = 1; _i2 <= segments; _i2++) {
					// twist a little...
					normals[_i2].applyMatrix4(mat.makeRotationAxis(tangents[_i2], _theta * _i2));

					binormals[_i2].crossVectors(tangents[_i2], normals[_i2]);
				}
			}

			return {
				tangents: tangents,
				normals: normals,
				binormals: binormals
			};
		};

		_proto.clone = function clone() {
			return new this.constructor().copy(this);
		};

		_proto.copy = function copy(source) {
			this.arcLengthDivisions = source.arcLengthDivisions;
			return this;
		};

		_proto.toJSON = function toJSON() {
			var data = {
				metadata: {
					version: 4.5,
					type: 'Curve',
					generator: 'Curve.toJSON'
				}
			};
			data.arcLengthDivisions = this.arcLengthDivisions;
			data.type = this.type;
			return data;
		};

		_proto.fromJSON = function fromJSON(json) {
			this.arcLengthDivisions = json.arcLengthDivisions;
			return this;
		};

		return Curve;
	}();

	var EllipseCurve = /*#__PURE__*/function (_Curve) {
		_inheritsLoose(EllipseCurve, _Curve);

		function EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
			var _this;

			if (aX === void 0) {
				aX = 0;
			}

			if (aY === void 0) {
				aY = 0;
			}

			if (xRadius === void 0) {
				xRadius = 1;
			}

			if (yRadius === void 0) {
				yRadius = 1;
			}

			if (aStartAngle === void 0) {
				aStartAngle = 0;
			}

			if (aEndAngle === void 0) {
				aEndAngle = Math.PI * 2;
			}

			if (aClockwise === void 0) {
				aClockwise = false;
			}

			if (aRotation === void 0) {
				aRotation = 0;
			}

			_this = _Curve.call(this) || this;
			_this.type = 'EllipseCurve';
			_this.aX = aX;
			_this.aY = aY;
			_this.xRadius = xRadius;
			_this.yRadius = yRadius;
			_this.aStartAngle = aStartAngle;
			_this.aEndAngle = aEndAngle;
			_this.aClockwise = aClockwise;
			_this.aRotation = aRotation;
			return _this;
		}

		var _proto = EllipseCurve.prototype;

		_proto.getPoint = function getPoint(t, optionalTarget) {
			var point = optionalTarget || new Vector2();
			var twoPi = Math.PI * 2;
			var deltaAngle = this.aEndAngle - this.aStartAngle;
			var samePoints = Math.abs(deltaAngle) < Number.EPSILON; // ensures that deltaAngle is 0 .. 2 PI

			while (deltaAngle < 0) {
				deltaAngle += twoPi;
			}

			while (deltaAngle > twoPi) {
				deltaAngle -= twoPi;
			}

			if (deltaAngle < Number.EPSILON) {
				if (samePoints) {
					deltaAngle = 0;
				} else {
					deltaAngle = twoPi;
				}
			}

			if (this.aClockwise === true && !samePoints) {
				if (deltaAngle === twoPi) {
					deltaAngle = -twoPi;
				} else {
					deltaAngle = deltaAngle - twoPi;
				}
			}

			var angle = this.aStartAngle + t * deltaAngle;
			var x = this.aX + this.xRadius * Math.cos(angle);
			var y = this.aY + this.yRadius * Math.sin(angle);

			if (this.aRotation !== 0) {
				var cos = Math.cos(this.aRotation);
				var sin = Math.sin(this.aRotation);
				var tx = x - this.aX;
				var ty = y - this.aY; // Rotate the point about the center of the ellipse.

				x = tx * cos - ty * sin + this.aX;
				y = tx * sin + ty * cos + this.aY;
			}

			return point.set(x, y);
		};

		_proto.copy = function copy(source) {
			_Curve.prototype.copy.call(this, source);

			this.aX = source.aX;
			this.aY = source.aY;
			this.xRadius = source.xRadius;
			this.yRadius = source.yRadius;
			this.aStartAngle = source.aStartAngle;
			this.aEndAngle = source.aEndAngle;
			this.aClockwise = source.aClockwise;
			this.aRotation = source.aRotation;
			return this;
		};

		_proto.toJSON = function toJSON() {
			var data = _Curve.prototype.toJSON.call(this);

			data.aX = this.aX;
			data.aY = this.aY;
			data.xRadius = this.xRadius;
			data.yRadius = this.yRadius;
			data.aStartAngle = this.aStartAngle;
			data.aEndAngle = this.aEndAngle;
			data.aClockwise = this.aClockwise;
			data.aRotation = this.aRotation;
			return data;
		};

		_proto.fromJSON = function fromJSON(json) {
			_Curve.prototype.fromJSON.call(this, json);

			this.aX = json.aX;
			this.aY = json.aY;
			this.xRadius = json.xRadius;
			this.yRadius = json.yRadius;
			this.aStartAngle = json.aStartAngle;
			this.aEndAngle = json.aEndAngle;
			this.aClockwise = json.aClockwise;
			this.aRotation = json.aRotation;
			return this;
		};

		return EllipseCurve;
	}(Curve);

	EllipseCurve.prototype.isEllipseCurve = true;

	var ArcCurve = /*#__PURE__*/function (_EllipseCurve) {
		_inheritsLoose(ArcCurve, _EllipseCurve);

		function ArcCurve(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
			var _this;

			_this = _EllipseCurve.call(this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise) || this;
			_this.type = 'ArcCurve';
			return _this;
		}

		return ArcCurve;
	}(EllipseCurve);

	ArcCurve.prototype.isArcCurve = true;

	/**
	 * Centripetal CatmullRom Curve - which is useful for avoiding
	 * cusps and self-intersections in non-uniform catmull rom curves.
	 * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf
	 *
	 * curve.type accepts centripetal(default), chordal and catmullrom
	 * curve.tension is used for catmullrom which defaults to 0.5
	 */

	/*
	Based on an optimized c++ solution in
	 - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/
	 - http://ideone.com/NoEbVM

	This CubicPoly class could be used for reusing some variables and calculations,
	but for three.js curve use, it could be possible inlined and flatten into a single function call
	which can be placed in CurveUtils.
	*/

	function CubicPoly() {
		var c0 = 0,
				c1 = 0,
				c2 = 0,
				c3 = 0;
		/*
		 * Compute coefficients for a cubic polynomial
		 *	 p(s) = c0 + c1*s + c2*s^2 + c3*s^3
		 * such that
		 *	 p(0) = x0, p(1) = x1
		 *	and
		 *	 p'(0) = t0, p'(1) = t1.
		 */

		function init(x0, x1, t0, t1) {
			c0 = x0;
			c1 = t0;
			c2 = -3 * x0 + 3 * x1 - 2 * t0 - t1;
			c3 = 2 * x0 - 2 * x1 + t0 + t1;
		}

		return {
			initCatmullRom: function initCatmullRom(x0, x1, x2, x3, tension) {
				init(x1, x2, tension * (x2 - x0), tension * (x3 - x1));
			},
			initNonuniformCatmullRom: function initNonuniformCatmullRom(x0, x1, x2, x3, dt0, dt1, dt2) {
				// compute tangents when parameterized in [t1,t2]
				var t1 = (x1 - x0) / dt0 - (x2 - x0) / (dt0 + dt1) + (x2 - x1) / dt1;
				var t2 = (x2 - x1) / dt1 - (x3 - x1) / (dt1 + dt2) + (x3 - x2) / dt2; // rescale tangents for parametrization in [0,1]

				t1 *= dt1;
				t2 *= dt1;
				init(x1, x2, t1, t2);
			},
			calc: function calc(t) {
				var t2 = t * t;
				var t3 = t2 * t;
				return c0 + c1 * t + c2 * t2 + c3 * t3;
			}
		};
	} //


	var tmp = new Vector3();
	var px = new CubicPoly(),
			py = new CubicPoly(),
			pz = new CubicPoly();

	var CatmullRomCurve3 = /*#__PURE__*/function (_Curve) {
		_inheritsLoose(CatmullRomCurve3, _Curve);

		function CatmullRomCurve3(points, closed, curveType, tension) {
			var _this;

			if (points === void 0) {
				points = [];
			}

			if (closed === void 0) {
				closed = false;
			}

			if (curveType === void 0) {
				curveType = 'centripetal';
			}

			if (tension === void 0) {
				tension = 0.5;
			}

			_this = _Curve.call(this) || this;
			_this.type = 'CatmullRomCurve3';
			_this.points = points;
			_this.closed = closed;
			_this.curveType = curveType;
			_this.tension = tension;
			return _this;
		}

		var _proto = CatmullRomCurve3.prototype;

		_proto.getPoint = function getPoint(t, optionalTarget) {
			if (optionalTarget === void 0) {
				optionalTarget = new Vector3();
			}

			var point = optionalTarget;
			var points = this.points;
			var l = points.length;
			var p = (l - (this.closed ? 0 : 1)) * t;
			var intPoint = Math.floor(p);
			var weight = p - intPoint;

			if (this.closed) {
				intPoint += intPoint > 0 ? 0 : (Math.floor(Math.abs(intPoint) / l) + 1) * l;
			} else if (weight === 0 && intPoint === l - 1) {
				intPoint = l - 2;
				weight = 1;
			}

			var p0, p3; // 4 points (p1 & p2 defined below)

			if (this.closed || intPoint > 0) {
				p0 = points[(intPoint - 1) % l];
			} else {
				// extrapolate first point
				tmp.subVectors(points[0], points[1]).add(points[0]);
				p0 = tmp;
			}

			var p1 = points[intPoint % l];
			var p2 = points[(intPoint + 1) % l];

			if (this.closed || intPoint + 2 < l) {
				p3 = points[(intPoint + 2) % l];
			} else {
				// extrapolate last point
				tmp.subVectors(points[l - 1], points[l - 2]).add(points[l - 1]);
				p3 = tmp;
			}

			if (this.curveType === 'centripetal' || this.curveType === 'chordal') {
				// init Centripetal / Chordal Catmull-Rom
				var pow = this.curveType === 'chordal' ? 0.5 : 0.25;
				var dt0 = Math.pow(p0.distanceToSquared(p1), pow);
				var dt1 = Math.pow(p1.distanceToSquared(p2), pow);
				var dt2 = Math.pow(p2.distanceToSquared(p3), pow); // safety check for repeated points

				if (dt1 < 1e-4) dt1 = 1.0;
				if (dt0 < 1e-4) dt0 = dt1;
				if (dt2 < 1e-4) dt2 = dt1;
				px.initNonuniformCatmullRom(p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2);
				py.initNonuniformCatmullRom(p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2);
				pz.initNonuniformCatmullRom(p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2);
			} else if (this.curveType === 'catmullrom') {
				px.initCatmullRom(p0.x, p1.x, p2.x, p3.x, this.tension);
				py.initCatmullRom(p0.y, p1.y, p2.y, p3.y, this.tension);
				pz.initCatmullRom(p0.z, p1.z, p2.z, p3.z, this.tension);
			}

			point.set(px.calc(weight), py.calc(weight), pz.calc(weight));
			return point;
		};

		_proto.copy = function copy(source) {
			_Curve.prototype.copy.call(this, source);

			this.points = [];

			for (var i = 0, l = source.points.length; i < l; i++) {
				var point = source.points[i];
				this.points.push(point.clone());
			}

			this.closed = source.closed;
			this.curveType = source.curveType;
			this.tension = source.tension;
			return this;
		};

		_proto.toJSON = function toJSON() {
			var data = _Curve.prototype.toJSON.call(this);

			data.points = [];

			for (var i = 0, l = this.points.length; i < l; i++) {
				var point = this.points[i];
				data.points.push(point.toArray());
			}

			data.closed = this.closed;
			data.curveType = this.curveType;
			data.tension = this.tension;
			return data;
		};

		_proto.fromJSON = function fromJSON(json) {
			_Curve.prototype.fromJSON.call(this, json);

			this.points = [];

			for (var i = 0, l = json.points.length; i < l; i++) {
				var point = json.points[i];
				this.points.push(new Vector3().fromArray(point));
			}

			this.closed = json.closed;
			this.curveType = json.curveType;
			this.tension = json.tension;
			return this;
		};

		return CatmullRomCurve3;
	}(Curve);

	CatmullRomCurve3.prototype.isCatmullRomCurve3 = true;

	/**
	 * Bezier Curves formulas obtained from
	 * http://en.wikipedia.org/wiki/Bézier_curve
	 */
	function CatmullRom(t, p0, p1, p2, p3) {
		var v0 = (p2 - p0) * 0.5;
		var v1 = (p3 - p1) * 0.5;
		var t2 = t * t;
		var t3 = t * t2;
		return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;
	} //


	function QuadraticBezierP0(t, p) {
		var k = 1 - t;
		return k * k * p;
	}

	function QuadraticBezierP1(t, p) {
		return 2 * (1 - t) * t * p;
	}

	function QuadraticBezierP2(t, p) {
		return t * t * p;
	}

	function QuadraticBezier(t, p0, p1, p2) {
		return QuadraticBezierP0(t, p0) + QuadraticBezierP1(t, p1) + QuadraticBezierP2(t, p2);
	} //


	function CubicBezierP0(t, p) {
		var k = 1 - t;
		return k * k * k * p;
	}

	function CubicBezierP1(t, p) {
		var k = 1 - t;
		return 3 * k * k * t * p;
	}

	function CubicBezierP2(t, p) {
		return 3 * (1 - t) * t * t * p;
	}

	function CubicBezierP3(t, p) {
		return t * t * t * p;
	}

	function CubicBezier(t, p0, p1, p2, p3) {
		return CubicBezierP0(t, p0) + CubicBezierP1(t, p1) + CubicBezierP2(t, p2) + CubicBezierP3(t, p3);
	}

	var CubicBezierCurve = /*#__PURE__*/function (_Curve) {
		_inheritsLoose(CubicBezierCurve, _Curve);

		function CubicBezierCurve(v0, v1, v2, v3) {
			var _this;

			if (v0 === void 0) {
				v0 = new Vector2();
			}

			if (v1 === void 0) {
				v1 = new Vector2();
			}

			if (v2 === void 0) {
				v2 = new Vector2();
			}

			if (v3 === void 0) {
				v3 = new Vector2();
			}

			_this = _Curve.call(this) || this;
			_this.type = 'CubicBezierCurve';
			_this.v0 = v0;
			_this.v1 = v1;
			_this.v2 = v2;
			_this.v3 = v3;
			return _this;
		}

		var _proto = CubicBezierCurve.prototype;

		_proto.getPoint = function getPoint(t, optionalTarget) {
			if (optionalTarget === void 0) {
				optionalTarget = new Vector2();
			}

			var point = optionalTarget;
			var v0 = this.v0,
					v1 = this.v1,
					v2 = this.v2,
					v3 = this.v3;
			point.set(CubicBezier(t, v0.x, v1.x, v2.x, v3.x), CubicBezier(t, v0.y, v1.y, v2.y, v3.y));
			return point;
		};

		_proto.copy = function copy(source) {
			_Curve.prototype.copy.call(this, source);

			this.v0.copy(source.v0);
			this.v1.copy(source.v1);
			this.v2.copy(source.v2);
			this.v3.copy(source.v3);
			return this;
		};

		_proto.toJSON = function toJSON() {
			var data = _Curve.prototype.toJSON.call(this);

			data.v0 = this.v0.toArray();
			data.v1 = this.v1.toArray();
			data.v2 = this.v2.toArray();
			data.v3 = this.v3.toArray();
			return data;
		};

		_proto.fromJSON = function fromJSON(json) {
			_Curve.prototype.fromJSON.call(this, json);

			this.v0.fromArray(json.v0);
			this.v1.fromArray(json.v1);
			this.v2.fromArray(json.v2);
			this.v3.fromArray(json.v3);
			return this;
		};

		return CubicBezierCurve;
	}(Curve);

	CubicBezierCurve.prototype.isCubicBezierCurve = true;

	var CubicBezierCurve3 = /*#__PURE__*/function (_Curve) {
		_inheritsLoose(CubicBezierCurve3, _Curve);

		function CubicBezierCurve3(v0, v1, v2, v3) {
			var _this;

			if (v0 === void 0) {
				v0 = new Vector3();
			}

			if (v1 === void 0) {
				v1 = new Vector3();
			}

			if (v2 === void 0) {
				v2 = new Vector3();
			}

			if (v3 === void 0) {
				v3 = new Vector3();
			}

			_this = _Curve.call(this) || this;
			_this.type = 'CubicBezierCurve3';
			_this.v0 = v0;
			_this.v1 = v1;
			_this.v2 = v2;
			_this.v3 = v3;
			return _this;
		}

		var _proto = CubicBezierCurve3.prototype;

		_proto.getPoint = function getPoint(t, optionalTarget) {
			if (optionalTarget === void 0) {
				optionalTarget = new Vector3();
			}

			var point = optionalTarget;
			var v0 = this.v0,
					v1 = this.v1,
					v2 = this.v2,
					v3 = this.v3;
			point.set(CubicBezier(t, v0.x, v1.x, v2.x, v3.x), CubicBezier(t, v0.y, v1.y, v2.y, v3.y), CubicBezier(t, v0.z, v1.z, v2.z, v3.z));
			return point;
		};

		_proto.copy = function copy(source) {
			_Curve.prototype.copy.call(this, source);

			this.v0.copy(source.v0);
			this.v1.copy(source.v1);
			this.v2.copy(source.v2);
			this.v3.copy(source.v3);
			return this;
		};

		_proto.toJSON = function toJSON() {
			var data = _Curve.prototype.toJSON.call(this);

			data.v0 = this.v0.toArray();
			data.v1 = this.v1.toArray();
			data.v2 = this.v2.toArray();
			data.v3 = this.v3.toArray();
			return data;
		};

		_proto.fromJSON = function fromJSON(json) {
			_Curve.prototype.fromJSON.call(this, json);

			this.v0.fromArray(json.v0);
			this.v1.fromArray(json.v1);
			this.v2.fromArray(json.v2);
			this.v3.fromArray(json.v3);
			return this;
		};

		return CubicBezierCurve3;
	}(Curve);

	CubicBezierCurve3.prototype.isCubicBezierCurve3 = true;

	var LineCurve = /*#__PURE__*/function (_Curve) {
		_inheritsLoose(LineCurve, _Curve);

		function LineCurve(v1, v2) {
			var _this;

			if (v1 === void 0) {
				v1 = new Vector2();
			}

			if (v2 === void 0) {
				v2 = new Vector2();
			}

			_this = _Curve.call(this) || this;
			_this.type = 'LineCurve';
			_this.v1 = v1;
			_this.v2 = v2;
			return _this;
		}

		var _proto = LineCurve.prototype;

		_proto.getPoint = function getPoint(t, optionalTarget) {
			if (optionalTarget === void 0) {
				optionalTarget = new Vector2();
			}

			var point = optionalTarget;

			if (t === 1) {
				point.copy(this.v2);
			} else {
				point.copy(this.v2).sub(this.v1);
				point.multiplyScalar(t).add(this.v1);
			}

			return point;
		} // Line curve is linear, so we can overwrite default getPointAt
		;

		_proto.getPointAt = function getPointAt(u, optionalTarget) {
			return this.getPoint(u, optionalTarget);
		};

		_proto.getTangent = function getTangent(t, optionalTarget) {
			var tangent = optionalTarget || new Vector2();
			tangent.copy(this.v2).sub(this.v1).normalize();
			return tangent;
		};

		_proto.copy = function copy(source) {
			_Curve.prototype.copy.call(this, source);

			this.v1.copy(source.v1);
			this.v2.copy(source.v2);
			return this;
		};

		_proto.toJSON = function toJSON() {
			var data = _Curve.prototype.toJSON.call(this);

			data.v1 = this.v1.toArray();
			data.v2 = this.v2.toArray();
			return data;
		};

		_proto.fromJSON = function fromJSON(json) {
			_Curve.prototype.fromJSON.call(this, json);

			this.v1.fromArray(json.v1);
			this.v2.fromArray(json.v2);
			return this;
		};

		return LineCurve;
	}(Curve);

	LineCurve.prototype.isLineCurve = true;

	var LineCurve3 = /*#__PURE__*/function (_Curve) {
		_inheritsLoose(LineCurve3, _Curve);

		function LineCurve3(v1, v2) {
			var _this;

			if (v1 === void 0) {
				v1 = new Vector3();
			}

			if (v2 === void 0) {
				v2 = new Vector3();
			}

			_this = _Curve.call(this) || this;
			_this.type = 'LineCurve3';
			_this.isLineCurve3 = true;
			_this.v1 = v1;
			_this.v2 = v2;
			return _this;
		}

		var _proto = LineCurve3.prototype;

		_proto.getPoint = function getPoint(t, optionalTarget) {
			if (optionalTarget === void 0) {
				optionalTarget = new Vector3();
			}

			var point = optionalTarget;

			if (t === 1) {
				point.copy(this.v2);
			} else {
				point.copy(this.v2).sub(this.v1);
				point.multiplyScalar(t).add(this.v1);
			}

			return point;
		} // Line curve is linear, so we can overwrite default getPointAt
		;

		_proto.getPointAt = function getPointAt(u, optionalTarget) {
			return this.getPoint(u, optionalTarget);
		};

		_proto.copy = function copy(source) {
			_Curve.prototype.copy.call(this, source);

			this.v1.copy(source.v1);
			this.v2.copy(source.v2);
			return this;
		};

		_proto.toJSON = function toJSON() {
			var data = _Curve.prototype.toJSON.call(this);

			data.v1 = this.v1.toArray();
			data.v2 = this.v2.toArray();
			return data;
		};

		_proto.fromJSON = function fromJSON(json) {
			_Curve.prototype.fromJSON.call(this, json);

			this.v1.fromArray(json.v1);
			this.v2.fromArray(json.v2);
			return this;
		};

		return LineCurve3;
	}(Curve);

	var QuadraticBezierCurve = /*#__PURE__*/function (_Curve) {
		_inheritsLoose(QuadraticBezierCurve, _Curve);

		function QuadraticBezierCurve(v0, v1, v2) {
			var _this;

			if (v0 === void 0) {
				v0 = new Vector2();
			}

			if (v1 === void 0) {
				v1 = new Vector2();
			}

			if (v2 === void 0) {
				v2 = new Vector2();
			}

			_this = _Curve.call(this) || this;
			_this.type = 'QuadraticBezierCurve';
			_this.v0 = v0;
			_this.v1 = v1;
			_this.v2 = v2;
			return _this;
		}

		var _proto = QuadraticBezierCurve.prototype;

		_proto.getPoint = function getPoint(t, optionalTarget) {
			if (optionalTarget === void 0) {
				optionalTarget = new Vector2();
			}

			var point = optionalTarget;
			var v0 = this.v0,
					v1 = this.v1,
					v2 = this.v2;
			point.set(QuadraticBezier(t, v0.x, v1.x, v2.x), QuadraticBezier(t, v0.y, v1.y, v2.y));
			return point;
		};

		_proto.copy = function copy(source) {
			_Curve.prototype.copy.call(this, source);

			this.v0.copy(source.v0);
			this.v1.copy(source.v1);
			this.v2.copy(source.v2);
			return this;
		};

		_proto.toJSON = function toJSON() {
			var data = _Curve.prototype.toJSON.call(this);

			data.v0 = this.v0.toArray();
			data.v1 = this.v1.toArray();
			data.v2 = this.v2.toArray();
			return data;
		};

		_proto.fromJSON = function fromJSON(json) {
			_Curve.prototype.fromJSON.call(this, json);

			this.v0.fromArray(json.v0);
			this.v1.fromArray(json.v1);
			this.v2.fromArray(json.v2);
			return this;
		};

		return QuadraticBezierCurve;
	}(Curve);

	QuadraticBezierCurve.prototype.isQuadraticBezierCurve = true;

	var QuadraticBezierCurve3 = /*#__PURE__*/function (_Curve) {
		_inheritsLoose(QuadraticBezierCurve3, _Curve);

		function QuadraticBezierCurve3(v0, v1, v2) {
			var _this;

			if (v0 === void 0) {
				v0 = new Vector3();
			}

			if (v1 === void 0) {
				v1 = new Vector3();
			}

			if (v2 === void 0) {
				v2 = new Vector3();
			}

			_this = _Curve.call(this) || this;
			_this.type = 'QuadraticBezierCurve3';
			_this.v0 = v0;
			_this.v1 = v1;
			_this.v2 = v2;
			return _this;
		}

		var _proto = QuadraticBezierCurve3.prototype;

		_proto.getPoint = function getPoint(t, optionalTarget) {
			if (optionalTarget === void 0) {
				optionalTarget = new Vector3();
			}

			var point = optionalTarget;
			var v0 = this.v0,
					v1 = this.v1,
					v2 = this.v2;
			point.set(QuadraticBezier(t, v0.x, v1.x, v2.x), QuadraticBezier(t, v0.y, v1.y, v2.y), QuadraticBezier(t, v0.z, v1.z, v2.z));
			return point;
		};

		_proto.copy = function copy(source) {
			_Curve.prototype.copy.call(this, source);

			this.v0.copy(source.v0);
			this.v1.copy(source.v1);
			this.v2.copy(source.v2);
			return this;
		};

		_proto.toJSON = function toJSON() {
			var data = _Curve.prototype.toJSON.call(this);

			data.v0 = this.v0.toArray();
			data.v1 = this.v1.toArray();
			data.v2 = this.v2.toArray();
			return data;
		};

		_proto.fromJSON = function fromJSON(json) {
			_Curve.prototype.fromJSON.call(this, json);

			this.v0.fromArray(json.v0);
			this.v1.fromArray(json.v1);
			this.v2.fromArray(json.v2);
			return this;
		};

		return QuadraticBezierCurve3;
	}(Curve);

	QuadraticBezierCurve3.prototype.isQuadraticBezierCurve3 = true;

	var SplineCurve = /*#__PURE__*/function (_Curve) {
		_inheritsLoose(SplineCurve, _Curve);

		function SplineCurve(points) {
			var _this;

			if (points === void 0) {
				points = [];
			}

			_this = _Curve.call(this) || this;
			_this.type = 'SplineCurve';
			_this.points = points;
			return _this;
		}

		var _proto = SplineCurve.prototype;

		_proto.getPoint = function getPoint(t, optionalTarget) {
			if (optionalTarget === void 0) {
				optionalTarget = new Vector2();
			}

			var point = optionalTarget;
			var points = this.points;
			var p = (points.length - 1) * t;
			var intPoint = Math.floor(p);
			var weight = p - intPoint;
			var p0 = points[intPoint === 0 ? intPoint : intPoint - 1];
			var p1 = points[intPoint];
			var p2 = points[intPoint > points.length - 2 ? points.length - 1 : intPoint + 1];
			var p3 = points[intPoint > points.length - 3 ? points.length - 1 : intPoint + 2];
			point.set(CatmullRom(weight, p0.x, p1.x, p2.x, p3.x), CatmullRom(weight, p0.y, p1.y, p2.y, p3.y));
			return point;
		};

		_proto.copy = function copy(source) {
			_Curve.prototype.copy.call(this, source);

			this.points = [];

			for (var i = 0, l = source.points.length; i < l; i++) {
				var point = source.points[i];
				this.points.push(point.clone());
			}

			return this;
		};

		_proto.toJSON = function toJSON() {
			var data = _Curve.prototype.toJSON.call(this);

			data.points = [];

			for (var i = 0, l = this.points.length; i < l; i++) {
				var point = this.points[i];
				data.points.push(point.toArray());
			}

			return data;
		};

		_proto.fromJSON = function fromJSON(json) {
			_Curve.prototype.fromJSON.call(this, json);

			this.points = [];

			for (var i = 0, l = json.points.length; i < l; i++) {
				var point = json.points[i];
				this.points.push(new Vector2().fromArray(point));
			}

			return this;
		};

		return SplineCurve;
	}(Curve);

	SplineCurve.prototype.isSplineCurve = true;

	var Curves = /*#__PURE__*/Object.freeze({
		__proto__: null,
		ArcCurve: ArcCurve,
		CatmullRomCurve3: CatmullRomCurve3,
		CubicBezierCurve: CubicBezierCurve,
		CubicBezierCurve3: CubicBezierCurve3,
		EllipseCurve: EllipseCurve,
		LineCurve: LineCurve,
		LineCurve3: LineCurve3,
		QuadraticBezierCurve: QuadraticBezierCurve,
		QuadraticBezierCurve3: QuadraticBezierCurve3,
		SplineCurve: SplineCurve
	});

	/**************************************************************
	 *	Curved Path - a curve path is simply a array of connected
	 *	curves, but retains the api of a curve
	 **************************************************************/

	var CurvePath = /*#__PURE__*/function (_Curve) {
		_inheritsLoose(CurvePath, _Curve);

		function CurvePath() {
			var _this;

			_this = _Curve.call(this) || this;
			_this.type = 'CurvePath';
			_this.curves = [];
			_this.autoClose = false; // Automatically closes the path

			return _this;
		}

		var _proto = CurvePath.prototype;

		_proto.add = function add(curve) {
			this.curves.push(curve);
		};

		_proto.closePath = function closePath() {
			// Add a line curve if start and end of lines are not connected
			var startPoint = this.curves[0].getPoint(0);
			var endPoint = this.curves[this.curves.length - 1].getPoint(1);

			if (!startPoint.equals(endPoint)) {
				this.curves.push(new LineCurve(endPoint, startPoint));
			}
		} // To get accurate point with reference to
		// entire path distance at time t,
		// following has to be done:
		// 1. Length of each sub path have to be known
		// 2. Locate and identify type of curve
		// 3. Get t for the curve
		// 4. Return curve.getPointAt(t')
		;

		_proto.getPoint = function getPoint(t, optionalTarget) {
			var d = t * this.getLength();
			var curveLengths = this.getCurveLengths();
			var i = 0; // To think about boundaries points.

			while (i < curveLengths.length) {
				if (curveLengths[i] >= d) {
					var diff = curveLengths[i] - d;
					var curve = this.curves[i];
					var segmentLength = curve.getLength();
					var u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;
					return curve.getPointAt(u, optionalTarget);
				}

				i++;
			}

			return null; // loop where sum != 0, sum > d , sum+1 <d
		} // We cannot use the default THREE.Curve getPoint() with getLength() because in
		// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
		// getPoint() depends on getLength
		;

		_proto.getLength = function getLength() {
			var lens = this.getCurveLengths();
			return lens[lens.length - 1];
		} // cacheLengths must be recalculated.
		;

		_proto.updateArcLengths = function updateArcLengths() {
			this.needsUpdate = true;
			this.cacheLengths = null;
			this.getCurveLengths();
		} // Compute lengths and cache them
		// We cannot overwrite getLengths() because UtoT mapping uses it.
		;

		_proto.getCurveLengths = function getCurveLengths() {
			// We use cache values if curves and cache array are same length
			if (this.cacheLengths && this.cacheLengths.length === this.curves.length) {
				return this.cacheLengths;
			} // Get length of sub-curve
			// Push sums into cached array


			var lengths = [];
			var sums = 0;

			for (var i = 0, l = this.curves.length; i < l; i++) {
				sums += this.curves[i].getLength();
				lengths.push(sums);
			}

			this.cacheLengths = lengths;
			return lengths;
		};

		_proto.getSpacedPoints = function getSpacedPoints(divisions) {
			if (divisions === void 0) {
				divisions = 40;
			}

			var points = [];

			for (var i = 0; i <= divisions; i++) {
				points.push(this.getPoint(i / divisions));
			}

			if (this.autoClose) {
				points.push(points[0]);
			}

			return points;
		};

		_proto.getPoints = function getPoints(divisions) {
			if (divisions === void 0) {
				divisions = 12;
			}

			var points = [];
			var last;

			for (var i = 0, curves = this.curves; i < curves.length; i++) {
				var curve = curves[i];
				var resolution = curve && curve.isEllipseCurve ? divisions * 2 : curve && (curve.isLineCurve || curve.isLineCurve3) ? 1 : curve && curve.isSplineCurve ? divisions * curve.points.length : divisions;
				var pts = curve.getPoints(resolution);

				for (var j = 0; j < pts.length; j++) {
					var point = pts[j];
					if (last && last.equals(point)) continue; // ensures no consecutive points are duplicates

					points.push(point);
					last = point;
				}
			}

			if (this.autoClose && points.length > 1 && !points[points.length - 1].equals(points[0])) {
				points.push(points[0]);
			}

			return points;
		};

		_proto.copy = function copy(source) {
			_Curve.prototype.copy.call(this, source);

			this.curves = [];

			for (var i = 0, l = source.curves.length; i < l; i++) {
				var curve = source.curves[i];
				this.curves.push(curve.clone());
			}

			this.autoClose = source.autoClose;
			return this;
		};

		_proto.toJSON = function toJSON() {
			var data = _Curve.prototype.toJSON.call(this);

			data.autoClose = this.autoClose;
			data.curves = [];

			for (var i = 0, l = this.curves.length; i < l; i++) {
				var curve = this.curves[i];
				data.curves.push(curve.toJSON());
			}

			return data;
		};

		_proto.fromJSON = function fromJSON(json) {
			_Curve.prototype.fromJSON.call(this, json);

			this.autoClose = json.autoClose;
			this.curves = [];

			for (var i = 0, l = json.curves.length; i < l; i++) {
				var curve = json.curves[i];
				this.curves.push(new Curves[curve.type]().fromJSON(curve));
			}

			return this;
		};

		return CurvePath;
	}(Curve);

	var Path = /*#__PURE__*/function (_CurvePath) {
		_inheritsLoose(Path, _CurvePath);

		function Path(points) {
			var _this;

			_this = _CurvePath.call(this) || this;
			_this.type = 'Path';
			_this.currentPoint = new Vector2();

			if (points) {
				_this.setFromPoints(points);
			}

			return _this;
		}

		var _proto = Path.prototype;

		_proto.setFromPoints = function setFromPoints(points) {
			this.moveTo(points[0].x, points[0].y);

			for (var i = 1, l = points.length; i < l; i++) {
				this.lineTo(points[i].x, points[i].y);
			}

			return this;
		};

		_proto.moveTo = function moveTo(x, y) {
			this.currentPoint.set(x, y); // TODO consider referencing vectors instead of copying?

			return this;
		};

		_proto.lineTo = function lineTo(x, y) {
			var curve = new LineCurve(this.currentPoint.clone(), new Vector2(x, y));
			this.curves.push(curve);
			this.currentPoint.set(x, y);
			return this;
		};

		_proto.quadraticCurveTo = function quadraticCurveTo(aCPx, aCPy, aX, aY) {
			var curve = new QuadraticBezierCurve(this.currentPoint.clone(), new Vector2(aCPx, aCPy), new Vector2(aX, aY));
			this.curves.push(curve);
			this.currentPoint.set(aX, aY);
			return this;
		};

		_proto.bezierCurveTo = function bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
			var curve = new CubicBezierCurve(this.currentPoint.clone(), new Vector2(aCP1x, aCP1y), new Vector2(aCP2x, aCP2y), new Vector2(aX, aY));
			this.curves.push(curve);
			this.currentPoint.set(aX, aY);
			return this;
		};

		_proto.splineThru = function splineThru(pts
		/*Array of Vector*/
		) {
			var npts = [this.currentPoint.clone()].concat(pts);
			var curve = new SplineCurve(npts);
			this.curves.push(curve);
			this.currentPoint.copy(pts[pts.length - 1]);
			return this;
		};

		_proto.arc = function arc(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
			var x0 = this.currentPoint.x;
			var y0 = this.currentPoint.y;
			this.absarc(aX + x0, aY + y0, aRadius, aStartAngle, aEndAngle, aClockwise);
			return this;
		};

		_proto.absarc = function absarc(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
			this.absellipse(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
			return this;
		};

		_proto.ellipse = function ellipse(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
			var x0 = this.currentPoint.x;
			var y0 = this.currentPoint.y;
			this.absellipse(aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
			return this;
		};

		_proto.absellipse = function absellipse(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
			var curve = new EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);

			if (this.curves.length > 0) {
				// if a previous curve is present, attempt to join
				var firstPoint = curve.getPoint(0);

				if (!firstPoint.equals(this.currentPoint)) {
					this.lineTo(firstPoint.x, firstPoint.y);
				}
			}

			this.curves.push(curve);
			var lastPoint = curve.getPoint(1);
			this.currentPoint.copy(lastPoint);
			return this;
		};

		_proto.copy = function copy(source) {
			_CurvePath.prototype.copy.call(this, source);

			this.currentPoint.copy(source.currentPoint);
			return this;
		};

		_proto.toJSON = function toJSON() {
			var data = _CurvePath.prototype.toJSON.call(this);

			data.currentPoint = this.currentPoint.toArray();
			return data;
		};

		_proto.fromJSON = function fromJSON(json) {
			_CurvePath.prototype.fromJSON.call(this, json);

			this.currentPoint.fromArray(json.currentPoint);
			return this;
		};

		return Path;
	}(CurvePath);

	var Shape = /*#__PURE__*/function (_Path) {
		_inheritsLoose(Shape, _Path);

		function Shape(points) {
			var _this;

			_this = _Path.call(this, points) || this;
			_this.uuid = generateUUID();
			_this.type = 'Shape';
			_this.holes = [];
			return _this;
		}

		var _proto = Shape.prototype;

		_proto.getPointsHoles = function getPointsHoles(divisions) {
			var holesPts = [];

			for (var i = 0, l = this.holes.length; i < l; i++) {
				holesPts[i] = this.holes[i].getPoints(divisions);
			}

			return holesPts;
		} // get points of shape and holes (keypoints based on segments parameter)
		;

		_proto.extractPoints = function extractPoints(divisions) {
			return {
				shape: this.getPoints(divisions),
				holes: this.getPointsHoles(divisions)
			};
		};

		_proto.copy = function copy(source) {
			_Path.prototype.copy.call(this, source);

			this.holes = [];

			for (var i = 0, l = source.holes.length; i < l; i++) {
				var hole = source.holes[i];
				this.holes.push(hole.clone());
			}

			return this;
		};

		_proto.toJSON = function toJSON() {
			var data = _Path.prototype.toJSON.call(this);

			data.uuid = this.uuid;
			data.holes = [];

			for (var i = 0, l = this.holes.length; i < l; i++) {
				var hole = this.holes[i];
				data.holes.push(hole.toJSON());
			}

			return data;
		};

		_proto.fromJSON = function fromJSON(json) {
			_Path.prototype.fromJSON.call(this, json);

			this.uuid = json.uuid;
			this.holes = [];

			for (var i = 0, l = json.holes.length; i < l; i++) {
				var hole = json.holes[i];
				this.holes.push(new Path().fromJSON(hole));
			}

			return this;
		};

		return Shape;
	}(Path);

	/**
	 * Port from https://github.com/mapbox/earcut (v2.2.2)
	 */
	var Earcut = {
		triangulate: function triangulate(data, holeIndices, dim) {
			if (dim === void 0) {
				dim = 2;
			}

			var hasHoles = holeIndices && holeIndices.length;
			var outerLen = hasHoles ? holeIndices[0] * dim : data.length;
			var outerNode = linkedList(data, 0, outerLen, dim, true);
			var triangles = [];
			if (!outerNode || outerNode.next === outerNode.prev) return triangles;
			var minX, minY, maxX, maxY, x, y, invSize;
			if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim); // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox

			if (data.length > 80 * dim) {
				minX = maxX = data[0];
				minY = maxY = data[1];

				for (var i = dim; i < outerLen; i += dim) {
					x = data[i];
					y = data[i + 1];
					if (x < minX) minX = x;
					if (y < minY) minY = y;
					if (x > maxX) maxX = x;
					if (y > maxY) maxY = y;
				} // minX, minY and invSize are later used to transform coords into integers for z-order calculation


				invSize = Math.max(maxX - minX, maxY - minY);
				invSize = invSize !== 0 ? 1 / invSize : 0;
			}

			earcutLinked(outerNode, triangles, dim, minX, minY, invSize);
			return triangles;
		}
	}; // create a circular doubly linked list from polygon points in the specified winding order

	function linkedList(data, start, end, dim, clockwise) {
		var i, last;

		if (clockwise === signedArea(data, start, end, dim) > 0) {
			for (i = start; i < end; i += dim) {
				last = insertNode(i, data[i], data[i + 1], last);
			}
		} else {
			for (i = end - dim; i >= start; i -= dim) {
				last = insertNode(i, data[i], data[i + 1], last);
			}
		}

		if (last && equals(last, last.next)) {
			removeNode(last);
			last = last.next;
		}

		return last;
	} // eliminate colinear or duplicate points


	function filterPoints(start, end) {
		if (!start) return start;
		if (!end) end = start;
		var p = start,
				again;

		do {
			again = false;

			if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
				removeNode(p);
				p = end = p.prev;
				if (p === p.next) break;
				again = true;
			} else {
				p = p.next;
			}
		} while (again || p !== end);

		return end;
	} // main ear slicing loop which triangulates a polygon (given as a linked list)


	function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
		if (!ear) return; // interlink polygon nodes in z-order

		if (!pass && invSize) indexCurve(ear, minX, minY, invSize);
		var stop = ear,
				prev,
				next; // iterate through ears, slicing them one by one

		while (ear.prev !== ear.next) {
			prev = ear.prev;
			next = ear.next;

			if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
				// cut off the triangle
				triangles.push(prev.i / dim);
				triangles.push(ear.i / dim);
				triangles.push(next.i / dim);
				removeNode(ear); // skipping the next vertex leads to less sliver triangles

				ear = next.next;
				stop = next.next;
				continue;
			}

			ear = next; // if we looped through the whole remaining polygon and can't find any more ears

			if (ear === stop) {
				// try filtering points and slicing again
				if (!pass) {
					earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1); // if this didn't work, try curing all small self-intersections locally
				} else if (pass === 1) {
					ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
					earcutLinked(ear, triangles, dim, minX, minY, invSize, 2); // as a last resort, try splitting the remaining polygon into two
				} else if (pass === 2) {
					splitEarcut(ear, triangles, dim, minX, minY, invSize);
				}

				break;
			}
		}
	} // check whether a polygon node forms a valid ear with adjacent nodes


	function isEar(ear) {
		var a = ear.prev,
				b = ear,
				c = ear.next;
		if (area(a, b, c) >= 0) return false; // reflex, can't be an ear
		// now make sure we don't have other points inside the potential ear

		var p = ear.next.next;

		while (p !== ear.prev) {
			if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
			p = p.next;
		}

		return true;
	}

	function isEarHashed(ear, minX, minY, invSize) {
		var a = ear.prev,
				b = ear,
				c = ear.next;
		if (area(a, b, c) >= 0) return false; // reflex, can't be an ear
		// triangle bbox; min & max are calculated like this for speed

		var minTX = a.x < b.x ? a.x < c.x ? a.x : c.x : b.x < c.x ? b.x : c.x,
				minTY = a.y < b.y ? a.y < c.y ? a.y : c.y : b.y < c.y ? b.y : c.y,
				maxTX = a.x > b.x ? a.x > c.x ? a.x : c.x : b.x > c.x ? b.x : c.x,
				maxTY = a.y > b.y ? a.y > c.y ? a.y : c.y : b.y > c.y ? b.y : c.y; // z-order range for the current triangle bbox;

		var minZ = zOrder(minTX, minTY, minX, minY, invSize),
				maxZ = zOrder(maxTX, maxTY, minX, minY, invSize);
		var p = ear.prevZ,
				n = ear.nextZ; // look for points inside the triangle in both directions

		while (p && p.z >= minZ && n && n.z <= maxZ) {
			if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
			p = p.prevZ;
			if (n !== ear.prev && n !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
			n = n.nextZ;
		} // look for remaining points in decreasing z-order


		while (p && p.z >= minZ) {
			if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
			p = p.prevZ;
		} // look for remaining points in increasing z-order


		while (n && n.z <= maxZ) {
			if (n !== ear.prev && n !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
			n = n.nextZ;
		}

		return true;
	} // go through all polygon nodes and cure small local self-intersections


	function cureLocalIntersections(start, triangles, dim) {
		var p = start;

		do {
			var a = p.prev,
					b = p.next.next;

			if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {
				triangles.push(a.i / dim);
				triangles.push(p.i / dim);
				triangles.push(b.i / dim); // remove two nodes involved

				removeNode(p);
				removeNode(p.next);
				p = start = b;
			}

			p = p.next;
		} while (p !== start);

		return filterPoints(p);
	} // try splitting polygon into two and triangulate them independently


	function splitEarcut(start, triangles, dim, minX, minY, invSize) {
		// look for a valid diagonal that divides the polygon into two
		var a = start;

		do {
			var b = a.next.next;

			while (b !== a.prev) {
				if (a.i !== b.i && isValidDiagonal(a, b)) {
					// split the polygon in two by the diagonal
					var c = splitPolygon(a, b); // filter colinear points around the cuts

					a = filterPoints(a, a.next);
					c = filterPoints(c, c.next); // run earcut on each half

					earcutLinked(a, triangles, dim, minX, minY, invSize);
					earcutLinked(c, triangles, dim, minX, minY, invSize);
					return;
				}

				b = b.next;
			}

			a = a.next;
		} while (a !== start);
	} // link every hole into the outer loop, producing a single-ring polygon without holes


	function eliminateHoles(data, holeIndices, outerNode, dim) {
		var queue = [];
		var i, len, start, end, list;

		for (i = 0, len = holeIndices.length; i < len; i++) {
			start = holeIndices[i] * dim;
			end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
			list = linkedList(data, start, end, dim, false);
			if (list === list.next) list.steiner = true;
			queue.push(getLeftmost(list));
		}

		queue.sort(compareX); // process holes from left to right

		for (i = 0; i < queue.length; i++) {
			eliminateHole(queue[i], outerNode);
			outerNode = filterPoints(outerNode, outerNode.next);
		}

		return outerNode;
	}

	function compareX(a, b) {
		return a.x - b.x;
	} // find a bridge between vertices that connects hole with an outer ring and and link it


	function eliminateHole(hole, outerNode) {
		outerNode = findHoleBridge(hole, outerNode);

		if (outerNode) {
			var b = splitPolygon(outerNode, hole); // filter collinear points around the cuts

			filterPoints(outerNode, outerNode.next);
			filterPoints(b, b.next);
		}
	} // David Eberly's algorithm for finding a bridge between hole and outer polygon


	function findHoleBridge(hole, outerNode) {
		var p = outerNode;
		var hx = hole.x;
		var hy = hole.y;
		var qx = -Infinity,
				m; // find a segment intersected by a ray from the hole's leftmost point to the left;
		// segment's endpoint with lesser x will be potential connection point

		do {
			if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
				var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);

				if (x <= hx && x > qx) {
					qx = x;

					if (x === hx) {
						if (hy === p.y) return p;
						if (hy === p.next.y) return p.next;
					}

					m = p.x < p.next.x ? p : p.next;
				}
			}

			p = p.next;
		} while (p !== outerNode);

		if (!m) return null;
		if (hx === qx) return m; // hole touches outer segment; pick leftmost endpoint
		// look for points inside the triangle of hole point, segment intersection and endpoint;
		// if there are no points found, we have a valid connection;
		// otherwise choose the point of the minimum angle with the ray as connection point

		var stop = m,
				mx = m.x,
				my = m.y;
		var tanMin = Infinity,
				tan;
		p = m;

		do {
			if (hx >= p.x && p.x >= mx && hx !== p.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
				tan = Math.abs(hy - p.y) / (hx - p.x); // tangential

				if (locallyInside(p, hole) && (tan < tanMin || tan === tanMin && (p.x > m.x || p.x === m.x && sectorContainsSector(m, p)))) {
					m = p;
					tanMin = tan;
				}
			}

			p = p.next;
		} while (p !== stop);

		return m;
	} // whether sector in vertex m contains sector in vertex p in the same coordinates


	function sectorContainsSector(m, p) {
		return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;
	} // interlink polygon nodes in z-order


	function indexCurve(start, minX, minY, invSize) {
		var p = start;

		do {
			if (p.z === null) p.z = zOrder(p.x, p.y, minX, minY, invSize);
			p.prevZ = p.prev;
			p.nextZ = p.next;
			p = p.next;
		} while (p !== start);

		p.prevZ.nextZ = null;
		p.prevZ = null;
		sortLinked(p);
	} // Simon Tatham's linked list merge sort algorithm
	// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html


	function sortLinked(list) {
		var i,
				p,
				q,
				e,
				tail,
				numMerges,
				pSize,
				qSize,
				inSize = 1;

		do {
			p = list;
			list = null;
			tail = null;
			numMerges = 0;

			while (p) {
				numMerges++;
				q = p;
				pSize = 0;

				for (i = 0; i < inSize; i++) {
					pSize++;
					q = q.nextZ;
					if (!q) break;
				}

				qSize = inSize;

				while (pSize > 0 || qSize > 0 && q) {
					if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
						e = p;
						p = p.nextZ;
						pSize--;
					} else {
						e = q;
						q = q.nextZ;
						qSize--;
					}

					if (tail) tail.nextZ = e;else list = e;
					e.prevZ = tail;
					tail = e;
				}

				p = q;
			}

			tail.nextZ = null;
			inSize *= 2;
		} while (numMerges > 1);

		return list;
	} // z-order of a point given coords and inverse of the longer side of data bbox


	function zOrder(x, y, minX, minY, invSize) {
		// coords are transformed into non-negative 15-bit integer range
		x = 32767 * (x - minX) * invSize;
		y = 32767 * (y - minY) * invSize;
		x = (x | x << 8) & 0x00FF00FF;
		x = (x | x << 4) & 0x0F0F0F0F;
		x = (x | x << 2) & 0x33333333;
		x = (x | x << 1) & 0x55555555;
		y = (y | y << 8) & 0x00FF00FF;
		y = (y | y << 4) & 0x0F0F0F0F;
		y = (y | y << 2) & 0x33333333;
		y = (y | y << 1) & 0x55555555;
		return x | y << 1;
	} // find the leftmost node of a polygon ring


	function getLeftmost(start) {
		var p = start,
				leftmost = start;

		do {
			if (p.x < leftmost.x || p.x === leftmost.x && p.y < leftmost.y) leftmost = p;
			p = p.next;
		} while (p !== start);

		return leftmost;
	} // check if a point lies within a convex triangle


	function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
		return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 && (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 && (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
	} // check if a diagonal between two polygon nodes is valid (lies in polygon interior)


	function isValidDiagonal(a, b) {
		return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && ( // dones't intersect other edges
		locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && ( // locally visible
		area(a.prev, a, b.prev) || area(a, b.prev, b)) || // does not create opposite-facing sectors
		equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0); // special zero-length case
	} // signed area of a triangle


	function area(p, q, r) {
		return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
	} // check if two points are equal


	function equals(p1, p2) {
		return p1.x === p2.x && p1.y === p2.y;
	} // check if two segments intersect


	function intersects(p1, q1, p2, q2) {
		var o1 = sign(area(p1, q1, p2));
		var o2 = sign(area(p1, q1, q2));
		var o3 = sign(area(p2, q2, p1));
		var o4 = sign(area(p2, q2, q1));
		if (o1 !== o2 && o3 !== o4) return true; // general case

		if (o1 === 0 && onSegment(p1, p2, q1)) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1

		if (o2 === 0 && onSegment(p1, q2, q1)) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1

		if (o3 === 0 && onSegment(p2, p1, q2)) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2

		if (o4 === 0 && onSegment(p2, q1, q2)) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2

		return false;
	} // for collinear points p, q, r, check if point q lies on segment pr


	function onSegment(p, q, r) {
		return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);
	}

	function sign(num) {
		return num > 0 ? 1 : num < 0 ? -1 : 0;
	} // check if a polygon diagonal intersects any polygon segments


	function intersectsPolygon(a, b) {
		var p = a;

		do {
			if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects(p, p.next, a, b)) return true;
			p = p.next;
		} while (p !== a);

		return false;
	} // check if a polygon diagonal is locally inside the polygon


	function locallyInside(a, b) {
		return area(a.prev, a, a.next) < 0 ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
	} // check if the middle point of a polygon diagonal is inside the polygon


	function middleInside(a, b) {
		var p = a,
				inside = false;
		var px = (a.x + b.x) / 2,
				py = (a.y + b.y) / 2;

		do {
			if (p.y > py !== p.next.y > py && p.next.y !== p.y && px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x) inside = !inside;
			p = p.next;
		} while (p !== a);

		return inside;
	} // link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
	// if one belongs to the outer ring and another to a hole, it merges it into a single ring


	function splitPolygon(a, b) {
		var a2 = new Node(a.i, a.x, a.y),
				b2 = new Node(b.i, b.x, b.y),
				an = a.next,
				bp = b.prev;
		a.next = b;
		b.prev = a;
		a2.next = an;
		an.prev = a2;
		b2.next = a2;
		a2.prev = b2;
		bp.next = b2;
		b2.prev = bp;
		return b2;
	} // create a node and optionally link it with previous one (in a circular doubly linked list)


	function insertNode(i, x, y, last) {
		var p = new Node(i, x, y);

		if (!last) {
			p.prev = p;
			p.next = p;
		} else {
			p.next = last.next;
			p.prev = last;
			last.next.prev = p;
			last.next = p;
		}

		return p;
	}

	function removeNode(p) {
		p.next.prev = p.prev;
		p.prev.next = p.next;
		if (p.prevZ) p.prevZ.nextZ = p.nextZ;
		if (p.nextZ) p.nextZ.prevZ = p.prevZ;
	}

	function Node(i, x, y) {
		// vertex index in coordinates array
		this.i = i; // vertex coordinates

		this.x = x;
		this.y = y; // previous and next vertex nodes in a polygon ring

		this.prev = null;
		this.next = null; // z-order curve value

		this.z = null; // previous and next nodes in z-order

		this.prevZ = null;
		this.nextZ = null; // indicates whether this is a steiner point

		this.steiner = false;
	}

	function signedArea(data, start, end, dim) {
		var sum = 0;

		for (var i = start, j = end - dim; i < end; i += dim) {
			sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
			j = i;
		}

		return sum;
	}

	var ShapeUtils = /*#__PURE__*/function () {
		function ShapeUtils() {}

		// calculate area of the contour polygon
		ShapeUtils.area = function area(contour) {
			var n = contour.length;
			var a = 0.0;

			for (var p = n - 1, q = 0; q < n; p = q++) {
				a += contour[p].x * contour[q].y - contour[q].x * contour[p].y;
			}

			return a * 0.5;
		};

		ShapeUtils.isClockWise = function isClockWise(pts) {
			return ShapeUtils.area(pts) < 0;
		};

		ShapeUtils.triangulateShape = function triangulateShape(contour, holes) {
			var vertices = []; // flat array of vertices like [ x0,y0, x1,y1, x2,y2, ... ]

			var holeIndices = []; // array of hole indices

			var faces = []; // final array of vertex indices like [ [ a,b,d ], [ b,c,d ] ]

			removeDupEndPts(contour);
			addContour(vertices, contour); //

			var holeIndex = contour.length;
			holes.forEach(removeDupEndPts);

			for (var i = 0; i < holes.length; i++) {
				holeIndices.push(holeIndex);
				holeIndex += holes[i].length;
				addContour(vertices, holes[i]);
			} //


			var triangles = Earcut.triangulate(vertices, holeIndices); //

			for (var _i = 0; _i < triangles.length; _i += 3) {
				faces.push(triangles.slice(_i, _i + 3));
			}

			return faces;
		};

		return ShapeUtils;
	}();

	function removeDupEndPts(points) {
		var l = points.length;

		if (l > 2 && points[l - 1].equals(points[0])) {
			points.pop();
		}
	}

	function addContour(vertices, contour) {
		for (var i = 0; i < contour.length; i++) {
			vertices.push(contour[i].x);
			vertices.push(contour[i].y);
		}
	}

	var ExtrudeGeometry = /*#__PURE__*/function (_BufferGeometry) {
		_inheritsLoose(ExtrudeGeometry, _BufferGeometry);

		function ExtrudeGeometry(shapes, options) {
			var _this;

			if (shapes === void 0) {
				shapes = new Shape([new Vector2(0.5, 0.5), new Vector2(-0.5, 0.5), new Vector2(-0.5, -0.5), new Vector2(0.5, -0.5)]);
			}

			if (options === void 0) {
				options = {};
			}

			_this = _BufferGeometry.call(this) || this;
			_this.type = 'ExtrudeGeometry';
			_this.parameters = {
				shapes: shapes,
				options: options
			};
			shapes = Array.isArray(shapes) ? shapes : [shapes];

			var scope = _assertThisInitialized(_this);

			var verticesArray = [];
			var uvArray = [];

			for (var i = 0, l = shapes.length; i < l; i++) {
				var shape = shapes[i];
				addShape(shape);
			} // build geometry


			_this.setAttribute('position', new Float32BufferAttribute(verticesArray, 3));

			_this.setAttribute('uv', new Float32BufferAttribute(uvArray, 2));

			_this.computeVertexNormals(); // functions


			function addShape(shape) {
				var placeholder = []; // options

				var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;
				var steps = options.steps !== undefined ? options.steps : 1;
				var depth = options.depth !== undefined ? options.depth : 1;
				var bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true;
				var bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 0.2;
				var bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 0.1;
				var bevelOffset = options.bevelOffset !== undefined ? options.bevelOffset : 0;
				var bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;
				var extrudePath = options.extrudePath;
				var uvgen = options.UVGenerator !== undefined ? options.UVGenerator : WorldUVGenerator; // deprecated options

				if (options.amount !== undefined) {
					console.warn('THREE.ExtrudeBufferGeometry: amount has been renamed to depth.');
					depth = options.amount;
				} //


				var extrudePts,
						extrudeByPath = false;
				var splineTube, binormal, normal, position2;

				if (extrudePath) {
					extrudePts = extrudePath.getSpacedPoints(steps);
					extrudeByPath = true;
					bevelEnabled = false; // bevels not supported for path extrusion
					// SETUP TNB variables
					// TODO1 - have a .isClosed in spline?

					splineTube = extrudePath.computeFrenetFrames(steps, false); // console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);

					binormal = new Vector3();
					normal = new Vector3();
					position2 = new Vector3();
				} // Safeguards if bevels are not enabled


				if (!bevelEnabled) {
					bevelSegments = 0;
					bevelThickness = 0;
					bevelSize = 0;
					bevelOffset = 0;
				} // Variables initialization


				var shapePoints = shape.extractPoints(curveSegments);
				var vertices = shapePoints.shape;
				var holes = shapePoints.holes;
				var reverse = !ShapeUtils.isClockWise(vertices);

				if (reverse) {
					vertices = vertices.reverse(); // Maybe we should also check if holes are in the opposite direction, just to be safe ...

					for (var h = 0, hl = holes.length; h < hl; h++) {
						var ahole = holes[h];

						if (ShapeUtils.isClockWise(ahole)) {
							holes[h] = ahole.reverse();
						}
					}
				}

				var faces = ShapeUtils.triangulateShape(vertices, holes);
				/* Vertices */

				var contour = vertices; // vertices has all points but contour has only points of circumference

				for (var _h = 0, _hl = holes.length; _h < _hl; _h++) {
					var _ahole = holes[_h];
					vertices = vertices.concat(_ahole);
				}

				function scalePt2(pt, vec, size) {
					if (!vec) console.error('THREE.ExtrudeGeometry: vec does not exist');
					return vec.clone().multiplyScalar(size).add(pt);
				}

				var vlen = vertices.length,
						flen = faces.length; // Find directions for point movement

				function getBevelVec(inPt, inPrev, inNext) {
					// computes for inPt the corresponding point inPt' on a new contour
					//	 shifted by 1 unit (length of normalized vector) to the left
					// if we walk along contour clockwise, this new contour is outside the old one
					//
					// inPt' is the intersection of the two lines parallel to the two
					//	adjacent edges of inPt at a distance of 1 unit on the left side.
					var v_trans_x, v_trans_y, shrink_by; // resulting translation vector for inPt
					// good reading for geometry algorithms (here: line-line intersection)
					// http://geomalgorithms.com/a05-_intersect-1.html

					var v_prev_x = inPt.x - inPrev.x,
							v_prev_y = inPt.y - inPrev.y;
					var v_next_x = inNext.x - inPt.x,
							v_next_y = inNext.y - inPt.y;
					var v_prev_lensq = v_prev_x * v_prev_x + v_prev_y * v_prev_y; // check for collinear edges

					var collinear0 = v_prev_x * v_next_y - v_prev_y * v_next_x;

					if (Math.abs(collinear0) > Number.EPSILON) {
						// not collinear
						// length of vectors for normalizing
						var v_prev_len = Math.sqrt(v_prev_lensq);
						var v_next_len = Math.sqrt(v_next_x * v_next_x + v_next_y * v_next_y); // shift adjacent points by unit vectors to the left

						var ptPrevShift_x = inPrev.x - v_prev_y / v_prev_len;
						var ptPrevShift_y = inPrev.y + v_prev_x / v_prev_len;
						var ptNextShift_x = inNext.x - v_next_y / v_next_len;
						var ptNextShift_y = inNext.y + v_next_x / v_next_len; // scaling factor for v_prev to intersection point

						var sf = ((ptNextShift_x - ptPrevShift_x) * v_next_y - (ptNextShift_y - ptPrevShift_y) * v_next_x) / (v_prev_x * v_next_y - v_prev_y * v_next_x); // vector from inPt to intersection point

						v_trans_x = ptPrevShift_x + v_prev_x * sf - inPt.x;
						v_trans_y = ptPrevShift_y + v_prev_y * sf - inPt.y; // Don't normalize!, otherwise sharp corners become ugly
						//	but prevent crazy spikes

						var v_trans_lensq = v_trans_x * v_trans_x + v_trans_y * v_trans_y;

						if (v_trans_lensq <= 2) {
							return new Vector2(v_trans_x, v_trans_y);
						} else {
							shrink_by = Math.sqrt(v_trans_lensq / 2);
						}
					} else {
						// handle special case of collinear edges
						var direction_eq = false; // assumes: opposite

						if (v_prev_x > Number.EPSILON) {
							if (v_next_x > Number.EPSILON) {
								direction_eq = true;
							}
						} else {
							if (v_prev_x < -Number.EPSILON) {
								if (v_next_x < -Number.EPSILON) {
									direction_eq = true;
								}
							} else {
								if (Math.sign(v_prev_y) === Math.sign(v_next_y)) {
									direction_eq = true;
								}
							}
						}

						if (direction_eq) {
							// console.log("Warning: lines are a straight sequence");
							v_trans_x = -v_prev_y;
							v_trans_y = v_prev_x;
							shrink_by = Math.sqrt(v_prev_lensq);
						} else {
							// console.log("Warning: lines are a straight spike");
							v_trans_x = v_prev_x;
							v_trans_y = v_prev_y;
							shrink_by = Math.sqrt(v_prev_lensq / 2);
						}
					}

					return new Vector2(v_trans_x / shrink_by, v_trans_y / shrink_by);
				}

				var contourMovements = [];

				for (var _i = 0, il = contour.length, j = il - 1, k = _i + 1; _i < il; _i++, j++, k++) {
					if (j === il) j = 0;
					if (k === il) k = 0; //	(j)---(i)---(k)
					// console.log('i,j,k', i, j , k)

					contourMovements[_i] = getBevelVec(contour[_i], contour[j], contour[k]);
				}

				var holesMovements = [];
				var oneHoleMovements,
						verticesMovements = contourMovements.concat();

				for (var _h2 = 0, _hl2 = holes.length; _h2 < _hl2; _h2++) {
					var _ahole2 = holes[_h2];
					oneHoleMovements = [];

					for (var _i2 = 0, _il = _ahole2.length, _j = _il - 1, _k = _i2 + 1; _i2 < _il; _i2++, _j++, _k++) {
						if (_j === _il) _j = 0;
						if (_k === _il) _k = 0; //	(j)---(i)---(k)

						oneHoleMovements[_i2] = getBevelVec(_ahole2[_i2], _ahole2[_j], _ahole2[_k]);
					}

					holesMovements.push(oneHoleMovements);
					verticesMovements = verticesMovements.concat(oneHoleMovements);
				} // Loop bevelSegments, 1 for the front, 1 for the back


				for (var b = 0; b < bevelSegments; b++) {
					//for ( b = bevelSegments; b > 0; b -- ) {
					var t = b / bevelSegments;
					var z = bevelThickness * Math.cos(t * Math.PI / 2);

					var _bs = bevelSize * Math.sin(t * Math.PI / 2) + bevelOffset; // contract shape


					for (var _i3 = 0, _il2 = contour.length; _i3 < _il2; _i3++) {
						var vert = scalePt2(contour[_i3], contourMovements[_i3], _bs);
						v(vert.x, vert.y, -z);
					} // expand holes


					for (var _h3 = 0, _hl3 = holes.length; _h3 < _hl3; _h3++) {
						var _ahole3 = holes[_h3];
						oneHoleMovements = holesMovements[_h3];

						for (var _i4 = 0, _il3 = _ahole3.length; _i4 < _il3; _i4++) {
							var _vert = scalePt2(_ahole3[_i4], oneHoleMovements[_i4], _bs);

							v(_vert.x, _vert.y, -z);
						}
					}
				}

				var bs = bevelSize + bevelOffset; // Back facing vertices

				for (var _i5 = 0; _i5 < vlen; _i5++) {
					var _vert2 = bevelEnabled ? scalePt2(vertices[_i5], verticesMovements[_i5], bs) : vertices[_i5];

					if (!extrudeByPath) {
						v(_vert2.x, _vert2.y, 0);
					} else {
						// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );
						normal.copy(splineTube.normals[0]).multiplyScalar(_vert2.x);
						binormal.copy(splineTube.binormals[0]).multiplyScalar(_vert2.y);
						position2.copy(extrudePts[0]).add(normal).add(binormal);
						v(position2.x, position2.y, position2.z);
					}
				} // Add stepped vertices...
				// Including front facing vertices


				for (var s = 1; s <= steps; s++) {
					for (var _i6 = 0; _i6 < vlen; _i6++) {
						var _vert3 = bevelEnabled ? scalePt2(vertices[_i6], verticesMovements[_i6], bs) : vertices[_i6];

						if (!extrudeByPath) {
							v(_vert3.x, _vert3.y, depth / steps * s);
						} else {
							// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );
							normal.copy(splineTube.normals[s]).multiplyScalar(_vert3.x);
							binormal.copy(splineTube.binormals[s]).multiplyScalar(_vert3.y);
							position2.copy(extrudePts[s]).add(normal).add(binormal);
							v(position2.x, position2.y, position2.z);
						}
					}
				} // Add bevel segments planes
				//for ( b = 1; b <= bevelSegments; b ++ ) {


				for (var _b = bevelSegments - 1; _b >= 0; _b--) {
					var _t = _b / bevelSegments;

					var _z = bevelThickness * Math.cos(_t * Math.PI / 2);

					var _bs2 = bevelSize * Math.sin(_t * Math.PI / 2) + bevelOffset; // contract shape


					for (var _i7 = 0, _il4 = contour.length; _i7 < _il4; _i7++) {
						var _vert4 = scalePt2(contour[_i7], contourMovements[_i7], _bs2);

						v(_vert4.x, _vert4.y, depth + _z);
					} // expand holes


					for (var _h4 = 0, _hl4 = holes.length; _h4 < _hl4; _h4++) {
						var _ahole4 = holes[_h4];
						oneHoleMovements = holesMovements[_h4];

						for (var _i8 = 0, _il5 = _ahole4.length; _i8 < _il5; _i8++) {
							var _vert5 = scalePt2(_ahole4[_i8], oneHoleMovements[_i8], _bs2);

							if (!extrudeByPath) {
								v(_vert5.x, _vert5.y, depth + _z);
							} else {
								v(_vert5.x, _vert5.y + extrudePts[steps - 1].y, extrudePts[steps - 1].x + _z);
							}
						}
					}
				}
				/* Faces */
				// Top and bottom faces


				buildLidFaces(); // Sides faces

				buildSideFaces(); /////	Internal functions

				function buildLidFaces() {
					var start = verticesArray.length / 3;

					if (bevelEnabled) {
						var layer = 0; // steps + 1

						var offset = vlen * layer; // Bottom faces

						for (var _i9 = 0; _i9 < flen; _i9++) {
							var face = faces[_i9];
							f3(face[2] + offset, face[1] + offset, face[0] + offset);
						}

						layer = steps + bevelSegments * 2;
						offset = vlen * layer; // Top faces

						for (var _i10 = 0; _i10 < flen; _i10++) {
							var _face = faces[_i10];
							f3(_face[0] + offset, _face[1] + offset, _face[2] + offset);
						}
					} else {
						// Bottom faces
						for (var _i11 = 0; _i11 < flen; _i11++) {
							var _face2 = faces[_i11];
							f3(_face2[2], _face2[1], _face2[0]);
						} // Top faces


						for (var _i12 = 0; _i12 < flen; _i12++) {
							var _face3 = faces[_i12];
							f3(_face3[0] + vlen * steps, _face3[1] + vlen * steps, _face3[2] + vlen * steps);
						}
					}

					scope.addGroup(start, verticesArray.length / 3 - start, 0);
				} // Create faces for the z-sides of the shape


				function buildSideFaces() {
					var start = verticesArray.length / 3;
					var layeroffset = 0;
					sidewalls(contour, layeroffset);
					layeroffset += contour.length;

					for (var _h5 = 0, _hl5 = holes.length; _h5 < _hl5; _h5++) {
						var _ahole5 = holes[_h5];
						sidewalls(_ahole5, layeroffset); //, true

						layeroffset += _ahole5.length;
					}

					scope.addGroup(start, verticesArray.length / 3 - start, 1);
				}

				function sidewalls(contour, layeroffset) {
					var i = contour.length;

					while (--i >= 0) {
						var _j2 = i;

						var _k2 = i - 1;

						if (_k2 < 0) _k2 = contour.length - 1; //console.log('b', i,j, i-1, k,vertices.length);

						for (var _s = 0, sl = steps + bevelSegments * 2; _s < sl; _s++) {
							var slen1 = vlen * _s;
							var slen2 = vlen * (_s + 1);

							var a = layeroffset + _j2 + slen1,
									_b2 = layeroffset + _k2 + slen1,
									c = layeroffset + _k2 + slen2,
									d = layeroffset + _j2 + slen2;

							f4(a, _b2, c, d);
						}
					}
				}

				function v(x, y, z) {
					placeholder.push(x);
					placeholder.push(y);
					placeholder.push(z);
				}

				function f3(a, b, c) {
					addVertex(a);
					addVertex(b);
					addVertex(c);
					var nextIndex = verticesArray.length / 3;
					var uvs = uvgen.generateTopUV(scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1);
					addUV(uvs[0]);
					addUV(uvs[1]);
					addUV(uvs[2]);
				}

				function f4(a, b, c, d) {
					addVertex(a);
					addVertex(b);
					addVertex(d);
					addVertex(b);
					addVertex(c);
					addVertex(d);
					var nextIndex = verticesArray.length / 3;
					var uvs = uvgen.generateSideWallUV(scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1);
					addUV(uvs[0]);
					addUV(uvs[1]);
					addUV(uvs[3]);
					addUV(uvs[1]);
					addUV(uvs[2]);
					addUV(uvs[3]);
				}

				function addVertex(index) {
					verticesArray.push(placeholder[index * 3 + 0]);
					verticesArray.push(placeholder[index * 3 + 1]);
					verticesArray.push(placeholder[index * 3 + 2]);
				}

				function addUV(vector2) {
					uvArray.push(vector2.x);
					uvArray.push(vector2.y);
				}
			}

			return _this;
		}

		var _proto = ExtrudeGeometry.prototype;

		_proto.toJSON = function toJSON() {
			var data = _BufferGeometry.prototype.toJSON.call(this);

			var shapes = this.parameters.shapes;
			var options = this.parameters.options;
			return _toJSON(shapes, options, data);
		};

		ExtrudeGeometry.fromJSON = function fromJSON(data, shapes) {
			var geometryShapes = [];

			for (var j = 0, jl = data.shapes.length; j < jl; j++) {
				var shape = shapes[data.shapes[j]];
				geometryShapes.push(shape);
			}

			var extrudePath = data.options.extrudePath;

			if (extrudePath !== undefined) {
				data.options.extrudePath = new Curves[extrudePath.type]().fromJSON(extrudePath);
			}

			return new ExtrudeGeometry(geometryShapes, data.options);
		};

		return ExtrudeGeometry;
	}(BufferGeometry);

	var WorldUVGenerator = {
		generateTopUV: function generateTopUV(geometry, vertices, indexA, indexB, indexC) {
			var a_x = vertices[indexA * 3];
			var a_y = vertices[indexA * 3 + 1];
			var b_x = vertices[indexB * 3];
			var b_y = vertices[indexB * 3 + 1];
			var c_x = vertices[indexC * 3];
			var c_y = vertices[indexC * 3 + 1];
			return [new Vector2(a_x, a_y), new Vector2(b_x, b_y), new Vector2(c_x, c_y)];
		},
		generateSideWallUV: function generateSideWallUV(geometry, vertices, indexA, indexB, indexC, indexD) {
			var a_x = vertices[indexA * 3];
			var a_y = vertices[indexA * 3 + 1];
			var a_z = vertices[indexA * 3 + 2];
			var b_x = vertices[indexB * 3];
			var b_y = vertices[indexB * 3 + 1];
			var b_z = vertices[indexB * 3 + 2];
			var c_x = vertices[indexC * 3];
			var c_y = vertices[indexC * 3 + 1];
			var c_z = vertices[indexC * 3 + 2];
			var d_x = vertices[indexD * 3];
			var d_y = vertices[indexD * 3 + 1];
			var d_z = vertices[indexD * 3 + 2];

			if (Math.abs(a_y - b_y) < Math.abs(a_x - b_x)) {
				return [new Vector2(a_x, 1 - a_z), new Vector2(b_x, 1 - b_z), new Vector2(c_x, 1 - c_z), new Vector2(d_x, 1 - d_z)];
			} else {
				return [new Vector2(a_y, 1 - a_z), new Vector2(b_y, 1 - b_z), new Vector2(c_y, 1 - c_z), new Vector2(d_y, 1 - d_z)];
			}
		}
	};

	function _toJSON(shapes, options, data) {
		data.shapes = [];

		if (Array.isArray(shapes)) {
			for (var i = 0, l = shapes.length; i < l; i++) {
				var shape = shapes[i];
				data.shapes.push(shape.uuid);
			}
		} else {
			data.shapes.push(shapes.uuid);
		}

		if (options.extrudePath !== undefined) data.options.extrudePath = options.extrudePath.toJSON();
		return data;
	}

	var IcosahedronGeometry = /*#__PURE__*/function (_PolyhedronGeometry) {
		_inheritsLoose(IcosahedronGeometry, _PolyhedronGeometry);

		function IcosahedronGeometry(radius, detail) {
			var _this;

			if (radius === void 0) {
				radius = 1;
			}

			if (detail === void 0) {
				detail = 0;
			}

			var t = (1 + Math.sqrt(5)) / 2;
			var vertices = [-1, t, 0, 1, t, 0, -1, -t, 0, 1, -t, 0, 0, -1, t, 0, 1, t, 0, -1, -t, 0, 1, -t, t, 0, -1, t, 0, 1, -t, 0, -1, -t, 0, 1];
			var indices = [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1];
			_this = _PolyhedronGeometry.call(this, vertices, indices, radius, detail) || this;
			_this.type = 'IcosahedronGeometry';
			_this.parameters = {
				radius: radius,
				detail: detail
			};
			return _this;
		}

		IcosahedronGeometry.fromJSON = function fromJSON(data) {
			return new IcosahedronGeometry(data.radius, data.detail);
		};

		return IcosahedronGeometry;
	}(PolyhedronGeometry);

	var LatheGeometry = /*#__PURE__*/function (_BufferGeometry) {
		_inheritsLoose(LatheGeometry, _BufferGeometry);

		function LatheGeometry(points, segments, phiStart, phiLength) {
			var _this;

			if (points === void 0) {
				points = [new Vector2(0, 0.5), new Vector2(0.5, 0), new Vector2(0, -0.5)];
			}

			if (segments === void 0) {
				segments = 12;
			}

			if (phiStart === void 0) {
				phiStart = 0;
			}

			if (phiLength === void 0) {
				phiLength = Math.PI * 2;
			}

			_this = _BufferGeometry.call(this) || this;
			_this.type = 'LatheGeometry';
			_this.parameters = {
				points: points,
				segments: segments,
				phiStart: phiStart,
				phiLength: phiLength
			};
			segments = Math.floor(segments); // clamp phiLength so it's in range of [ 0, 2PI ]

			phiLength = clamp(phiLength, 0, Math.PI * 2); // buffers

			var indices = [];
			var vertices = [];
			var uvs = []; // helper variables

			var inverseSegments = 1.0 / segments;
			var vertex = new Vector3();
			var uv = new Vector2(); // generate vertices and uvs

			for (var i = 0; i <= segments; i++) {
				var phi = phiStart + i * inverseSegments * phiLength;
				var sin = Math.sin(phi);
				var cos = Math.cos(phi);

				for (var j = 0; j <= points.length - 1; j++) {
					// vertex
					vertex.x = points[j].x * sin;
					vertex.y = points[j].y;
					vertex.z = points[j].x * cos;
					vertices.push(vertex.x, vertex.y, vertex.z); // uv

					uv.x = i / segments;
					uv.y = j / (points.length - 1);
					uvs.push(uv.x, uv.y);
				}
			} // indices


			for (var _i = 0; _i < segments; _i++) {
				for (var _j = 0; _j < points.length - 1; _j++) {
					var base = _j + _i * points.length;
					var a = base;
					var b = base + points.length;
					var c = base + points.length + 1;
					var d = base + 1; // faces

					indices.push(a, b, d);
					indices.push(b, c, d);
				}
			} // build geometry


			_this.setIndex(indices);

			_this.setAttribute('position', new Float32BufferAttribute(vertices, 3));

			_this.setAttribute('uv', new Float32BufferAttribute(uvs, 2)); // generate normals


			_this.computeVertexNormals(); // if the geometry is closed, we need to average the normals along the seam.
			// because the corresponding vertices are identical (but still have different UVs).


			if (phiLength === Math.PI * 2) {
				var normals = _this.attributes.normal.array;
				var n1 = new Vector3();
				var n2 = new Vector3();
				var n = new Vector3(); // this is the buffer offset for the last line of vertices

				var _base = segments * points.length * 3;

				for (var _i2 = 0, _j2 = 0; _i2 < points.length; _i2++, _j2 += 3) {
					// select the normal of the vertex in the first line
					n1.x = normals[_j2 + 0];
					n1.y = normals[_j2 + 1];
					n1.z = normals[_j2 + 2]; // select the normal of the vertex in the last line

					n2.x = normals[_base + _j2 + 0];
					n2.y = normals[_base + _j2 + 1];
					n2.z = normals[_base + _j2 + 2]; // average normals

					n.addVectors(n1, n2).normalize(); // assign the new values to both normals

					normals[_j2 + 0] = normals[_base + _j2 + 0] = n.x;
					normals[_j2 + 1] = normals[_base + _j2 + 1] = n.y;
					normals[_j2 + 2] = normals[_base + _j2 + 2] = n.z;
				}
			}

			return _this;
		}

		LatheGeometry.fromJSON = function fromJSON(data) {
			return new LatheGeometry(data.points, data.segments, data.phiStart, data.phiLength);
		};

		return LatheGeometry;
	}(BufferGeometry);

	var OctahedronGeometry = /*#__PURE__*/function (_PolyhedronGeometry) {
		_inheritsLoose(OctahedronGeometry, _PolyhedronGeometry);

		function OctahedronGeometry(radius, detail) {
			var _this;

			if (radius === void 0) {
				radius = 1;
			}

			if (detail === void 0) {
				detail = 0;
			}

			var vertices = [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1];
			var indices = [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2];
			_this = _PolyhedronGeometry.call(this, vertices, indices, radius, detail) || this;
			_this.type = 'OctahedronGeometry';
			_this.parameters = {
				radius: radius,
				detail: detail
			};
			return _this;
		}

		OctahedronGeometry.fromJSON = function fromJSON(data) {
			return new OctahedronGeometry(data.radius, data.detail);
		};

		return OctahedronGeometry;
	}(PolyhedronGeometry);

	var RingGeometry = /*#__PURE__*/function (_BufferGeometry) {
		_inheritsLoose(RingGeometry, _BufferGeometry);

		function RingGeometry(innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength) {
			var _this;

			if (innerRadius === void 0) {
				innerRadius = 0.5;
			}

			if (outerRadius === void 0) {
				outerRadius = 1;
			}

			if (thetaSegments === void 0) {
				thetaSegments = 8;
			}

			if (phiSegments === void 0) {
				phiSegments = 1;
			}

			if (thetaStart === void 0) {
				thetaStart = 0;
			}

			if (thetaLength === void 0) {
				thetaLength = Math.PI * 2;
			}

			_this = _BufferGeometry.call(this) || this;
			_this.type = 'RingGeometry';
			_this.parameters = {
				innerRadius: innerRadius,
				outerRadius: outerRadius,
				thetaSegments: thetaSegments,
				phiSegments: phiSegments,
				thetaStart: thetaStart,
				thetaLength: thetaLength
			};
			thetaSegments = Math.max(3, thetaSegments);
			phiSegments = Math.max(1, phiSegments); // buffers

			var indices = [];
			var vertices = [];
			var normals = [];
			var uvs = []; // some helper variables

			var radius = innerRadius;
			var radiusStep = (outerRadius - innerRadius) / phiSegments;
			var vertex = new Vector3();
			var uv = new Vector2(); // generate vertices, normals and uvs

			for (var j = 0; j <= phiSegments; j++) {
				for (var i = 0; i <= thetaSegments; i++) {
					// values are generate from the inside of the ring to the outside
					var segment = thetaStart + i / thetaSegments * thetaLength; // vertex

					vertex.x = radius * Math.cos(segment);
					vertex.y = radius * Math.sin(segment);
					vertices.push(vertex.x, vertex.y, vertex.z); // normal

					normals.push(0, 0, 1); // uv

					uv.x = (vertex.x / outerRadius + 1) / 2;
					uv.y = (vertex.y / outerRadius + 1) / 2;
					uvs.push(uv.x, uv.y);
				} // increase the radius for next row of vertices


				radius += radiusStep;
			} // indices


			for (var _j = 0; _j < phiSegments; _j++) {
				var thetaSegmentLevel = _j * (thetaSegments + 1);

				for (var _i = 0; _i < thetaSegments; _i++) {
					var _segment = _i + thetaSegmentLevel;

					var a = _segment;
					var b = _segment + thetaSegments + 1;
					var c = _segment + thetaSegments + 2;
					var d = _segment + 1; // faces

					indices.push(a, b, d);
					indices.push(b, c, d);
				}
			} // build geometry


			_this.setIndex(indices);

			_this.setAttribute('position', new Float32BufferAttribute(vertices, 3));

			_this.setAttribute('normal', new Float32BufferAttribute(normals, 3));

			_this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));

			return _this;
		}

		RingGeometry.fromJSON = function fromJSON(data) {
			return new RingGeometry(data.innerRadius, data.outerRadius, data.thetaSegments, data.phiSegments, data.thetaStart, data.thetaLength);
		};

		return RingGeometry;
	}(BufferGeometry);

	var ShapeGeometry = /*#__PURE__*/function (_BufferGeometry) {
		_inheritsLoose(ShapeGeometry, _BufferGeometry);

		function ShapeGeometry(shapes, curveSegments) {
			var _this;

			if (shapes === void 0) {
				shapes = new Shape([new Vector2(0, 0.5), new Vector2(-0.5, -0.5), new Vector2(0.5, -0.5)]);
			}

			if (curveSegments === void 0) {
				curveSegments = 12;
			}

			_this = _BufferGeometry.call(this) || this;
			_this.type = 'ShapeGeometry';
			_this.parameters = {
				shapes: shapes,
				curveSegments: curveSegments
			}; // buffers

			var indices = [];
			var vertices = [];
			var normals = [];
			var uvs = []; // helper variables

			var groupStart = 0;
			var groupCount = 0; // allow single and array values for "shapes" parameter

			if (Array.isArray(shapes) === false) {
				addShape(shapes);
			} else {
				for (var i = 0; i < shapes.length; i++) {
					addShape(shapes[i]);

					_this.addGroup(groupStart, groupCount, i); // enables MultiMaterial support


					groupStart += groupCount;
					groupCount = 0;
				}
			} // build geometry


			_this.setIndex(indices);

			_this.setAttribute('position', new Float32BufferAttribute(vertices, 3));

			_this.setAttribute('normal', new Float32BufferAttribute(normals, 3));

			_this.setAttribute('uv', new Float32BufferAttribute(uvs, 2)); // helper functions


			function addShape(shape) {
				var indexOffset = vertices.length / 3;
				var points = shape.extractPoints(curveSegments);
				var shapeVertices = points.shape;
				var shapeHoles = points.holes; // check direction of vertices

				if (ShapeUtils.isClockWise(shapeVertices) === false) {
					shapeVertices = shapeVertices.reverse();
				}

				for (var _i = 0, l = shapeHoles.length; _i < l; _i++) {
					var shapeHole = shapeHoles[_i];

					if (ShapeUtils.isClockWise(shapeHole) === true) {
						shapeHoles[_i] = shapeHole.reverse();
					}
				}

				var faces = ShapeUtils.triangulateShape(shapeVertices, shapeHoles); // join vertices of inner and outer paths to a single array

				for (var _i2 = 0, _l = shapeHoles.length; _i2 < _l; _i2++) {
					var _shapeHole = shapeHoles[_i2];
					shapeVertices = shapeVertices.concat(_shapeHole);
				} // vertices, normals, uvs


				for (var _i3 = 0, _l2 = shapeVertices.length; _i3 < _l2; _i3++) {
					var vertex = shapeVertices[_i3];
					vertices.push(vertex.x, vertex.y, 0);
					normals.push(0, 0, 1);
					uvs.push(vertex.x, vertex.y); // world uvs
				} // incides


				for (var _i4 = 0, _l3 = faces.length; _i4 < _l3; _i4++) {
					var face = faces[_i4];
					var a = face[0] + indexOffset;
					var b = face[1] + indexOffset;
					var c = face[2] + indexOffset;
					indices.push(a, b, c);
					groupCount += 3;
				}
			}

			return _this;
		}

		var _proto = ShapeGeometry.prototype;

		_proto.toJSON = function toJSON() {
			var data = _BufferGeometry.prototype.toJSON.call(this);

			var shapes = this.parameters.shapes;
			return _toJSON$1(shapes, data);
		};

		ShapeGeometry.fromJSON = function fromJSON(data, shapes) {
			var geometryShapes = [];

			for (var j = 0, jl = data.shapes.length; j < jl; j++) {
				var shape = shapes[data.shapes[j]];
				geometryShapes.push(shape);
			}

			return new ShapeGeometry(geometryShapes, data.curveSegments);
		};

		return ShapeGeometry;
	}(BufferGeometry);

	function _toJSON$1(shapes, data) {
		data.shapes = [];

		if (Array.isArray(shapes)) {
			for (var i = 0, l = shapes.length; i < l; i++) {
				var shape = shapes[i];
				data.shapes.push(shape.uuid);
			}
		} else {
			data.shapes.push(shapes.uuid);
		}

		return data;
	}

	var SphereGeometry = /*#__PURE__*/function (_BufferGeometry) {
		_inheritsLoose(SphereGeometry, _BufferGeometry);

		function SphereGeometry(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength) {
			var _this;

			if (radius === void 0) {
				radius = 1;
			}

			if (widthSegments === void 0) {
				widthSegments = 32;
			}

			if (heightSegments === void 0) {
				heightSegments = 16;
			}

			if (phiStart === void 0) {
				phiStart = 0;
			}

			if (phiLength === void 0) {
				phiLength = Math.PI * 2;
			}

			if (thetaStart === void 0) {
				thetaStart = 0;
			}

			if (thetaLength === void 0) {
				thetaLength = Math.PI;
			}

			_this = _BufferGeometry.call(this) || this;
			_this.type = 'SphereGeometry';
			_this.parameters = {
				radius: radius,
				widthSegments: widthSegments,
				heightSegments: heightSegments,
				phiStart: phiStart,
				phiLength: phiLength,
				thetaStart: thetaStart,
				thetaLength: thetaLength
			};
			widthSegments = Math.max(3, Math.floor(widthSegments));
			heightSegments = Math.max(2, Math.floor(heightSegments));
			var thetaEnd = Math.min(thetaStart + thetaLength, Math.PI);
			var index = 0;
			var grid = [];
			var vertex = new Vector3();
			var normal = new Vector3(); // buffers

			var indices = [];
			var vertices = [];
			var normals = [];
			var uvs = []; // generate vertices, normals and uvs

			for (var iy = 0; iy <= heightSegments; iy++) {
				var verticesRow = [];
				var v = iy / heightSegments; // special case for the poles

				var uOffset = 0;

				if (iy == 0 && thetaStart == 0) {
					uOffset = 0.5 / widthSegments;
				} else if (iy == heightSegments && thetaEnd == Math.PI) {
					uOffset = -0.5 / widthSegments;
				}

				for (var ix = 0; ix <= widthSegments; ix++) {
					var u = ix / widthSegments; // vertex

					vertex.x = -radius * Math.cos(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
					vertex.y = radius * Math.cos(thetaStart + v * thetaLength);
					vertex.z = radius * Math.sin(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
					vertices.push(vertex.x, vertex.y, vertex.z); // normal

					normal.copy(vertex).normalize();
					normals.push(normal.x, normal.y, normal.z); // uv

					uvs.push(u + uOffset, 1 - v);
					verticesRow.push(index++);
				}

				grid.push(verticesRow);
			} // indices


			for (var _iy = 0; _iy < heightSegments; _iy++) {
				for (var _ix = 0; _ix < widthSegments; _ix++) {
					var a = grid[_iy][_ix + 1];
					var b = grid[_iy][_ix];
					var c = grid[_iy + 1][_ix];
					var d = grid[_iy + 1][_ix + 1];
					if (_iy !== 0 || thetaStart > 0) indices.push(a, b, d);
					if (_iy !== heightSegments - 1 || thetaEnd < Math.PI) indices.push(b, c, d);
				}
			} // build geometry


			_this.setIndex(indices);

			_this.setAttribute('position', new Float32BufferAttribute(vertices, 3));

			_this.setAttribute('normal', new Float32BufferAttribute(normals, 3));

			_this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));

			return _this;
		}

		SphereGeometry.fromJSON = function fromJSON(data) {
			return new SphereGeometry(data.radius, data.widthSegments, data.heightSegments, data.phiStart, data.phiLength, data.thetaStart, data.thetaLength);
		};

		return SphereGeometry;
	}(BufferGeometry);

	var TetrahedronGeometry = /*#__PURE__*/function (_PolyhedronGeometry) {
		_inheritsLoose(TetrahedronGeometry, _PolyhedronGeometry);

		function TetrahedronGeometry(radius, detail) {
			var _this;

			if (radius === void 0) {
				radius = 1;
			}

			if (detail === void 0) {
				detail = 0;
			}

			var vertices = [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1];
			var indices = [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1];
			_this = _PolyhedronGeometry.call(this, vertices, indices, radius, detail) || this;
			_this.type = 'TetrahedronGeometry';
			_this.parameters = {
				radius: radius,
				detail: detail
			};
			return _this;
		}

		TetrahedronGeometry.fromJSON = function fromJSON(data) {
			return new TetrahedronGeometry(data.radius, data.detail);
		};

		return TetrahedronGeometry;
	}(PolyhedronGeometry);

	var TorusGeometry = /*#__PURE__*/function (_BufferGeometry) {
		_inheritsLoose(TorusGeometry, _BufferGeometry);

		function TorusGeometry(radius, tube, radialSegments, tubularSegments, arc) {
			var _this;

			if (radius === void 0) {
				radius = 1;
			}

			if (tube === void 0) {
				tube = 0.4;
			}

			if (radialSegments === void 0) {
				radialSegments = 8;
			}

			if (tubularSegments === void 0) {
				tubularSegments = 6;
			}

			if (arc === void 0) {
				arc = Math.PI * 2;
			}

			_this = _BufferGeometry.call(this) || this;
			_this.type = 'TorusGeometry';
			_this.parameters = {
				radius: radius,
				tube: tube,
				radialSegments: radialSegments,
				tubularSegments: tubularSegments,
				arc: arc
			};
			radialSegments = Math.floor(radialSegments);
			tubularSegments = Math.floor(tubularSegments); // buffers

			var indices = [];
			var vertices = [];
			var normals = [];
			var uvs = []; // helper variables

			var center = new Vector3();
			var vertex = new Vector3();
			var normal = new Vector3(); // generate vertices, normals and uvs

			for (var j = 0; j <= radialSegments; j++) {
				for (var i = 0; i <= tubularSegments; i++) {
					var u = i / tubularSegments * arc;
					var v = j / radialSegments * Math.PI * 2; // vertex

					vertex.x = (radius + tube * Math.cos(v)) * Math.cos(u);
					vertex.y = (radius + tube * Math.cos(v)) * Math.sin(u);
					vertex.z = tube * Math.sin(v);
					vertices.push(vertex.x, vertex.y, vertex.z); // normal

					center.x = radius * Math.cos(u);
					center.y = radius * Math.sin(u);
					normal.subVectors(vertex, center).normalize();
					normals.push(normal.x, normal.y, normal.z); // uv

					uvs.push(i / tubularSegments);
					uvs.push(j / radialSegments);
				}
			} // generate indices


			for (var _j = 1; _j <= radialSegments; _j++) {
				for (var _i = 1; _i <= tubularSegments; _i++) {
					// indices
					var a = (tubularSegments + 1) * _j + _i - 1;
					var b = (tubularSegments + 1) * (_j - 1) + _i - 1;
					var c = (tubularSegments + 1) * (_j - 1) + _i;
					var d = (tubularSegments + 1) * _j + _i; // faces

					indices.push(a, b, d);
					indices.push(b, c, d);
				}
			} // build geometry


			_this.setIndex(indices);

			_this.setAttribute('position', new Float32BufferAttribute(vertices, 3));

			_this.setAttribute('normal', new Float32BufferAttribute(normals, 3));

			_this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));

			return _this;
		}

		TorusGeometry.fromJSON = function fromJSON(data) {
			return new TorusGeometry(data.radius, data.tube, data.radialSegments, data.tubularSegments, data.arc);
		};

		return TorusGeometry;
	}(BufferGeometry);

	var TorusKnotGeometry = /*#__PURE__*/function (_BufferGeometry) {
		_inheritsLoose(TorusKnotGeometry, _BufferGeometry);

		function TorusKnotGeometry(radius, tube, tubularSegments, radialSegments, p, q) {
			var _this;

			if (radius === void 0) {
				radius = 1;
			}

			if (tube === void 0) {
				tube = 0.4;
			}

			if (tubularSegments === void 0) {
				tubularSegments = 64;
			}

			if (radialSegments === void 0) {
				radialSegments = 8;
			}

			if (p === void 0) {
				p = 2;
			}

			if (q === void 0) {
				q = 3;
			}

			_this = _BufferGeometry.call(this) || this;
			_this.type = 'TorusKnotGeometry';
			_this.parameters = {
				radius: radius,
				tube: tube,
				tubularSegments: tubularSegments,
				radialSegments: radialSegments,
				p: p,
				q: q
			};
			tubularSegments = Math.floor(tubularSegments);
			radialSegments = Math.floor(radialSegments); // buffers

			var indices = [];
			var vertices = [];
			var normals = [];
			var uvs = []; // helper variables

			var vertex = new Vector3();
			var normal = new Vector3();
			var P1 = new Vector3();
			var P2 = new Vector3();
			var B = new Vector3();
			var T = new Vector3();
			var N = new Vector3(); // generate vertices, normals and uvs

			for (var i = 0; i <= tubularSegments; ++i) {
				// the radian "u" is used to calculate the position on the torus curve of the current tubular segement
				var u = i / tubularSegments * p * Math.PI * 2; // now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.
				// these points are used to create a special "coordinate space", which is necessary to calculate the correct vertex positions

				calculatePositionOnCurve(u, p, q, radius, P1);
				calculatePositionOnCurve(u + 0.01, p, q, radius, P2); // calculate orthonormal basis

				T.subVectors(P2, P1);
				N.addVectors(P2, P1);
				B.crossVectors(T, N);
				N.crossVectors(B, T); // normalize B, N. T can be ignored, we don't use it

				B.normalize();
				N.normalize();

				for (var j = 0; j <= radialSegments; ++j) {
					// now calculate the vertices. they are nothing more than an extrusion of the torus curve.
					// because we extrude a shape in the xy-plane, there is no need to calculate a z-value.
					var v = j / radialSegments * Math.PI * 2;
					var cx = -tube * Math.cos(v);
					var cy = tube * Math.sin(v); // now calculate the final vertex position.
					// first we orient the extrusion with our basis vectos, then we add it to the current position on the curve

					vertex.x = P1.x + (cx * N.x + cy * B.x);
					vertex.y = P1.y + (cx * N.y + cy * B.y);
					vertex.z = P1.z + (cx * N.z + cy * B.z);
					vertices.push(vertex.x, vertex.y, vertex.z); // normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)

					normal.subVectors(vertex, P1).normalize();
					normals.push(normal.x, normal.y, normal.z); // uv

					uvs.push(i / tubularSegments);
					uvs.push(j / radialSegments);
				}
			} // generate indices


			for (var _j = 1; _j <= tubularSegments; _j++) {
				for (var _i = 1; _i <= radialSegments; _i++) {
					// indices
					var a = (radialSegments + 1) * (_j - 1) + (_i - 1);
					var b = (radialSegments + 1) * _j + (_i - 1);
					var c = (radialSegments + 1) * _j + _i;
					var d = (radialSegments + 1) * (_j - 1) + _i; // faces

					indices.push(a, b, d);
					indices.push(b, c, d);
				}
			} // build geometry


			_this.setIndex(indices);

			_this.setAttribute('position', new Float32BufferAttribute(vertices, 3));

			_this.setAttribute('normal', new Float32BufferAttribute(normals, 3));

			_this.setAttribute('uv', new Float32BufferAttribute(uvs, 2)); // this function calculates the current position on the torus curve


			function calculatePositionOnCurve(u, p, q, radius, position) {
				var cu = Math.cos(u);
				var su = Math.sin(u);
				var quOverP = q / p * u;
				var cs = Math.cos(quOverP);
				position.x = radius * (2 + cs) * 0.5 * cu;
				position.y = radius * (2 + cs) * su * 0.5;
				position.z = radius * Math.sin(quOverP) * 0.5;
			}

			return _this;
		}

		TorusKnotGeometry.fromJSON = function fromJSON(data) {
			return new TorusKnotGeometry(data.radius, data.tube, data.tubularSegments, data.radialSegments, data.p, data.q);
		};

		return TorusKnotGeometry;
	}(BufferGeometry);

	var TubeGeometry = /*#__PURE__*/function (_BufferGeometry) {
		_inheritsLoose(TubeGeometry, _BufferGeometry);

		function TubeGeometry(path, tubularSegments, radius, radialSegments, closed) {
			var _this;

			if (path === void 0) {
				path = new QuadraticBezierCurve3(new Vector3(-1, -1, 0), new Vector3(-1, 1, 0), new Vector3(1, 1, 0));
			}

			if (tubularSegments === void 0) {
				tubularSegments = 64;
			}

			if (radius === void 0) {
				radius = 1;
			}

			if (radialSegments === void 0) {
				radialSegments = 8;
			}

			if (closed === void 0) {
				closed = false;
			}

			_this = _BufferGeometry.call(this) || this;
			_this.type = 'TubeGeometry';
			_this.parameters = {
				path: path,
				tubularSegments: tubularSegments,
				radius: radius,
				radialSegments: radialSegments,
				closed: closed
			};
			var frames = path.computeFrenetFrames(tubularSegments, closed); // expose internals

			_this.tangents = frames.tangents;
			_this.normals = frames.normals;
			_this.binormals = frames.binormals; // helper variables

			var vertex = new Vector3();
			var normal = new Vector3();
			var uv = new Vector2();
			var P = new Vector3(); // buffer

			var vertices = [];
			var normals = [];
			var uvs = [];
			var indices = []; // create buffer data

			generateBufferData(); // build geometry

			_this.setIndex(indices);

			_this.setAttribute('position', new Float32BufferAttribute(vertices, 3));

			_this.setAttribute('normal', new Float32BufferAttribute(normals, 3));

			_this.setAttribute('uv', new Float32BufferAttribute(uvs, 2)); // functions


			function generateBufferData() {
				for (var i = 0; i < tubularSegments; i++) {
					generateSegment(i);
				} // if the geometry is not closed, generate the last row of vertices and normals
				// at the regular position on the given path
				//
				// if the geometry is closed, duplicate the first row of vertices and normals (uvs will differ)


				generateSegment(closed === false ? tubularSegments : 0); // uvs are generated in a separate function.
				// this makes it easy compute correct values for closed geometries

				generateUVs(); // finally create faces

				generateIndices();
			}

			function generateSegment(i) {
				// we use getPointAt to sample evenly distributed points from the given path
				P = path.getPointAt(i / tubularSegments, P); // retrieve corresponding normal and binormal

				var N = frames.normals[i];
				var B = frames.binormals[i]; // generate normals and vertices for the current segment

				for (var j = 0; j <= radialSegments; j++) {
					var v = j / radialSegments * Math.PI * 2;
					var sin = Math.sin(v);
					var cos = -Math.cos(v); // normal

					normal.x = cos * N.x + sin * B.x;
					normal.y = cos * N.y + sin * B.y;
					normal.z = cos * N.z + sin * B.z;
					normal.normalize();
					normals.push(normal.x, normal.y, normal.z); // vertex

					vertex.x = P.x + radius * normal.x;
					vertex.y = P.y + radius * normal.y;
					vertex.z = P.z + radius * normal.z;
					vertices.push(vertex.x, vertex.y, vertex.z);
				}
			}

			function generateIndices() {
				for (var j = 1; j <= tubularSegments; j++) {
					for (var i = 1; i <= radialSegments; i++) {
						var a = (radialSegments + 1) * (j - 1) + (i - 1);
						var b = (radialSegments + 1) * j + (i - 1);
						var c = (radialSegments + 1) * j + i;
						var d = (radialSegments + 1) * (j - 1) + i; // faces

						indices.push(a, b, d);
						indices.push(b, c, d);
					}
				}
			}

			function generateUVs() {
				for (var i = 0; i <= tubularSegments; i++) {
					for (var j = 0; j <= radialSegments; j++) {
						uv.x = i / tubularSegments;
						uv.y = j / radialSegments;
						uvs.push(uv.x, uv.y);
					}
				}
			}

			return _this;
		}

		var _proto = TubeGeometry.prototype;

		_proto.toJSON = function toJSON() {
			var data = _BufferGeometry.prototype.toJSON.call(this);

			data.path = this.parameters.path.toJSON();
			return data;
		};

		TubeGeometry.fromJSON = function fromJSON(data) {
			// This only works for built-in curves (e.g. CatmullRomCurve3).
			// User defined curves or instances of CurvePath will not be deserialized.
			return new TubeGeometry(new Curves[data.path.type]().fromJSON(data.path), data.tubularSegments, data.radius, data.radialSegments, data.closed);
		};

		return TubeGeometry;
	}(BufferGeometry);

	var WireframeGeometry = /*#__PURE__*/function (_BufferGeometry) {
		_inheritsLoose(WireframeGeometry, _BufferGeometry);

		function WireframeGeometry(geometry) {
			var _this;

			if (geometry === void 0) {
				geometry = null;
			}

			_this = _BufferGeometry.call(this) || this;
			_this.type = 'WireframeGeometry';
			_this.parameters = {
				geometry: geometry
			};

			if (geometry !== null) {
				// buffer
				var vertices = [];
				var edges = new Set(); // helper variables

				var start = new Vector3();
				var end = new Vector3();

				if (geometry.index !== null) {
					// indexed BufferGeometry
					var position = geometry.attributes.position;
					var indices = geometry.index;
					var groups = geometry.groups;

					if (groups.length === 0) {
						groups = [{
							start: 0,
							count: indices.count,
							materialIndex: 0
						}];
					} // create a data structure that contains all eges without duplicates


					for (var o = 0, ol = groups.length; o < ol; ++o) {
						var group = groups[o];
						var groupStart = group.start;
						var groupCount = group.count;

						for (var i = groupStart, l = groupStart + groupCount; i < l; i += 3) {
							for (var j = 0; j < 3; j++) {
								var index1 = indices.getX(i + j);
								var index2 = indices.getX(i + (j + 1) % 3);
								start.fromBufferAttribute(position, index1);
								end.fromBufferAttribute(position, index2);

								if (isUniqueEdge(start, end, edges) === true) {
									vertices.push(start.x, start.y, start.z);
									vertices.push(end.x, end.y, end.z);
								}
							}
						}
					}
				} else {
					// non-indexed BufferGeometry
					var _position = geometry.attributes.position;

					for (var _i = 0, _l = _position.count / 3; _i < _l; _i++) {
						for (var _j = 0; _j < 3; _j++) {
							// three edges per triangle, an edge is represented as (index1, index2)
							// e.g. the first triangle has the following edges: (0,1),(1,2),(2,0)
							var _index = 3 * _i + _j;

							var _index2 = 3 * _i + (_j + 1) % 3;

							start.fromBufferAttribute(_position, _index);
							end.fromBufferAttribute(_position, _index2);

							if (isUniqueEdge(start, end, edges) === true) {
								vertices.push(start.x, start.y, start.z);
								vertices.push(end.x, end.y, end.z);
							}
						}
					}
				} // build geometry


				_this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
			}

			return _this;
		}

		return WireframeGeometry;
	}(BufferGeometry);

	function isUniqueEdge(start, end, edges) {
		var hash1 = start.x + "," + start.y + "," + start.z + "-" + end.x + "," + end.y + "," + end.z;
		var hash2 = end.x + "," + end.y + "," + end.z + "-" + start.x + "," + start.y + "," + start.z; // coincident edge

		if (edges.has(hash1) === true || edges.has(hash2) === true) {
			return false;
		} else {
			edges.add(hash1, hash2);
			return true;
		}
	}

	var Geometries = /*#__PURE__*/Object.freeze({
		__proto__: null,
		BoxGeometry: BoxGeometry,
		BoxBufferGeometry: BoxGeometry,
		CircleGeometry: CircleGeometry,
		CircleBufferGeometry: CircleGeometry,
		ConeGeometry: ConeGeometry,
		ConeBufferGeometry: ConeGeometry,
		CylinderGeometry: CylinderGeometry,
		CylinderBufferGeometry: CylinderGeometry,
		DodecahedronGeometry: DodecahedronGeometry,
		DodecahedronBufferGeometry: DodecahedronGeometry,
		EdgesGeometry: EdgesGeometry,
		ExtrudeGeometry: ExtrudeGeometry,
		ExtrudeBufferGeometry: ExtrudeGeometry,
		IcosahedronGeometry: IcosahedronGeometry,
		IcosahedronBufferGeometry: IcosahedronGeometry,
		LatheGeometry: LatheGeometry,
		LatheBufferGeometry: LatheGeometry,
		OctahedronGeometry: OctahedronGeometry,
		OctahedronBufferGeometry: OctahedronGeometry,
		PlaneGeometry: PlaneGeometry,
		PlaneBufferGeometry: PlaneGeometry,
		PolyhedronGeometry: PolyhedronGeometry,
		PolyhedronBufferGeometry: PolyhedronGeometry,
		RingGeometry: RingGeometry,
		RingBufferGeometry: RingGeometry,
		ShapeGeometry: ShapeGeometry,
		ShapeBufferGeometry: ShapeGeometry,
		SphereGeometry: SphereGeometry,
		SphereBufferGeometry: SphereGeometry,
		TetrahedronGeometry: TetrahedronGeometry,
		TetrahedronBufferGeometry: TetrahedronGeometry,
		TorusGeometry: TorusGeometry,
		TorusBufferGeometry: TorusGeometry,
		TorusKnotGeometry: TorusKnotGeometry,
		TorusKnotBufferGeometry: TorusKnotGeometry,
		TubeGeometry: TubeGeometry,
		TubeBufferGeometry: TubeGeometry,
		WireframeGeometry: WireframeGeometry
	});

	/**
	 * parameters = {
	 *	color: <THREE.Color>
	 * }
	 */

	var ShadowMaterial = /*#__PURE__*/function (_Material) {
		_inheritsLoose(ShadowMaterial, _Material);

		function ShadowMaterial(parameters) {
			var _this;

			_this = _Material.call(this) || this;
			_this.type = 'ShadowMaterial';
			_this.color = new Color(0x000000);
			_this.transparent = true;

			_this.setValues(parameters);

			return _this;
		}

		var _proto = ShadowMaterial.prototype;

		_proto.copy = function copy(source) {
			_Material.prototype.copy.call(this, source);

			this.color.copy(source.color);
			return this;
		};

		return ShadowMaterial;
	}(Material);

	ShadowMaterial.prototype.isShadowMaterial = true;

	/**
	 * parameters = {
	 *	color: <hex>,
	 *	roughness: <float>,
	 *	metalness: <float>,
	 *	opacity: <float>,
	 *
	 *	map: new THREE.Texture( <Image> ),
	 *
	 *	lightMap: new THREE.Texture( <Image> ),
	 *	lightMapIntensity: <float>
	 *
	 *	aoMap: new THREE.Texture( <Image> ),
	 *	aoMapIntensity: <float>
	 *
	 *	emissive: <hex>,
	 *	emissiveIntensity: <float>
	 *	emissiveMap: new THREE.Texture( <Image> ),
	 *
	 *	bumpMap: new THREE.Texture( <Image> ),
	 *	bumpScale: <float>,
	 *
	 *	normalMap: new THREE.Texture( <Image> ),
	 *	normalMapType: THREE.TangentSpaceNormalMap,
	 *	normalScale: <Vector2>,
	 *
	 *	displacementMap: new THREE.Texture( <Image> ),
	 *	displacementScale: <float>,
	 *	displacementBias: <float>,
	 *
	 *	roughnessMap: new THREE.Texture( <Image> ),
	 *
	 *	metalnessMap: new THREE.Texture( <Image> ),
	 *
	 *	alphaMap: new THREE.Texture( <Image> ),
	 *
	 *	envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
	 *	envMapIntensity: <float>
	 *
	 *	refractionRatio: <float>,
	 *
	 *	wireframe: <boolean>,
	 *	wireframeLinewidth: <float>,
	 *
	 *	flatShading: <bool>
	 * }
	 */

	var MeshStandardMaterial = /*#__PURE__*/function (_Material) {
		_inheritsLoose(MeshStandardMaterial, _Material);

		function MeshStandardMaterial(parameters) {
			var _this;

			_this = _Material.call(this) || this;
			_this.defines = {
				'STANDARD': ''
			};
			_this.type = 'MeshStandardMaterial';
			_this.color = new Color(0xffffff); // diffuse

			_this.roughness = 1.0;
			_this.metalness = 0.0;
			_this.map = null;
			_this.lightMap = null;
			_this.lightMapIntensity = 1.0;
			_this.aoMap = null;
			_this.aoMapIntensity = 1.0;
			_this.emissive = new Color(0x000000);
			_this.emissiveIntensity = 1.0;
			_this.emissiveMap = null;
			_this.bumpMap = null;
			_this.bumpScale = 1;
			_this.normalMap = null;
			_this.normalMapType = TangentSpaceNormalMap;
			_this.normalScale = new Vector2(1, 1);
			_this.displacementMap = null;
			_this.displacementScale = 1;
			_this.displacementBias = 0;
			_this.roughnessMap = null;
			_this.metalnessMap = null;
			_this.alphaMap = null;
			_this.envMap = null;
			_this.envMapIntensity = 1.0;
			_this.refractionRatio = 0.98;
			_this.wireframe = false;
			_this.wireframeLinewidth = 1;
			_this.wireframeLinecap = 'round';
			_this.wireframeLinejoin = 'round';
			_this.flatShading = false;

			_this.setValues(parameters);

			return _this;
		}

		var _proto = MeshStandardMaterial.prototype;

		_proto.copy = function copy(source) {
			_Material.prototype.copy.call(this, source);

			this.defines = {
				'STANDARD': ''
			};
			this.color.copy(source.color);
			this.roughness = source.roughness;
			this.metalness = source.metalness;
			this.map = source.map;
			this.lightMap = source.lightMap;
			this.lightMapIntensity = source.lightMapIntensity;
			this.aoMap = source.aoMap;
			this.aoMapIntensity = source.aoMapIntensity;
			this.emissive.copy(source.emissive);
			this.emissiveMap = source.emissiveMap;
			this.emissiveIntensity = source.emissiveIntensity;
			this.bumpMap = source.bumpMap;
			this.bumpScale = source.bumpScale;
			this.normalMap = source.normalMap;
			this.normalMapType = source.normalMapType;
			this.normalScale.copy(source.normalScale);
			this.displacementMap = source.displacementMap;
			this.displacementScale = source.displacementScale;
			this.displacementBias = source.displacementBias;
			this.roughnessMap = source.roughnessMap;
			this.metalnessMap = source.metalnessMap;
			this.alphaMap = source.alphaMap;
			this.envMap = source.envMap;
			this.envMapIntensity = source.envMapIntensity;
			this.refractionRatio = source.refractionRatio;
			this.wireframe = source.wireframe;
			this.wireframeLinewidth = source.wireframeLinewidth;
			this.wireframeLinecap = source.wireframeLinecap;
			this.wireframeLinejoin = source.wireframeLinejoin;
			this.flatShading = source.flatShading;
			return this;
		};

		return MeshStandardMaterial;
	}(Material);

	MeshStandardMaterial.prototype.isMeshStandardMaterial = true;

	/**
	 * parameters = {
	 *	clearcoat: <float>,
	 *	clearcoatMap: new THREE.Texture( <Image> ),
	 *	clearcoatRoughness: <float>,
	 *	clearcoatRoughnessMap: new THREE.Texture( <Image> ),
	 *	clearcoatNormalScale: <Vector2>,
	 *	clearcoatNormalMap: new THREE.Texture( <Image> ),
	 *
	 *	ior: <float>,
	 *	reflectivity: <float>,
	 *
	 *	sheen: <float>,
	 *	sheenTint: <Color>,
	 *	sheenRoughness: <float>,
	 *
	 *	transmission: <float>,
	 *	transmissionMap: new THREE.Texture( <Image> ),
	 *
	 *	thickness: <float>,
	 *	thicknessMap: new THREE.Texture( <Image> ),
	 *	attenuationDistance: <float>,
	 *	attenuationTint: <Color>,
	 *
	 *	specularIntensity: <float>,
	 *	specularIntensityhMap: new THREE.Texture( <Image> ),
	 *	specularTint: <Color>,
	 *	specularTintMap: new THREE.Texture( <Image> )
	 * }
	 */

	var MeshPhysicalMaterial = /*#__PURE__*/function (_MeshStandardMaterial) {
		_inheritsLoose(MeshPhysicalMaterial, _MeshStandardMaterial);

		function MeshPhysicalMaterial(parameters) {
			var _this;

			_this = _MeshStandardMaterial.call(this) || this;
			_this.defines = {
				'STANDARD': '',
				'PHYSICAL': ''
			};
			_this.type = 'MeshPhysicalMaterial';
			_this.clearcoatMap = null;
			_this.clearcoatRoughness = 0.0;
			_this.clearcoatRoughnessMap = null;
			_this.clearcoatNormalScale = new Vector2(1, 1);
			_this.clearcoatNormalMap = null;
			_this.ior = 1.5;
			Object.defineProperty(_assertThisInitialized(_this), 'reflectivity', {
				get: function get() {
					return clamp(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1);
				},
				set: function set(reflectivity) {
					this.ior = (1 + 0.4 * reflectivity) / (1 - 0.4 * reflectivity);
				}
			});
			_this.sheenTint = new Color(0x000000);
			_this.sheenRoughness = 1.0;
			_this.transmissionMap = null;
			_this.thickness = 0.01;
			_this.thicknessMap = null;
			_this.attenuationDistance = 0.0;
			_this.attenuationTint = new Color(1, 1, 1);
			_this.specularIntensity = 1.0;
			_this.specularIntensityMap = null;
			_this.specularTint = new Color(1, 1, 1);
			_this.specularTintMap = null;
			_this._sheen = 0.0;
			_this._clearcoat = 0;
			_this._transmission = 0;

			_this.setValues(parameters);

			return _this;
		}

		var _proto = MeshPhysicalMaterial.prototype;

		_proto.copy = function copy(source) {
			_MeshStandardMaterial.prototype.copy.call(this, source);

			this.defines = {
				'STANDARD': '',
				'PHYSICAL': ''
			};
			this.clearcoat = source.clearcoat;
			this.clearcoatMap = source.clearcoatMap;
			this.clearcoatRoughness = source.clearcoatRoughness;
			this.clearcoatRoughnessMap = source.clearcoatRoughnessMap;
			this.clearcoatNormalMap = source.clearcoatNormalMap;
			this.clearcoatNormalScale.copy(source.clearcoatNormalScale);
			this.ior = source.ior;
			this.sheen = source.sheen;
			this.sheenTint.copy(source.sheenTint);
			this.sheenRoughness = source.sheenRoughness;
			this.transmission = source.transmission;
			this.transmissionMap = source.transmissionMap;
			this.thickness = source.thickness;
			this.thicknessMap = source.thicknessMap;
			this.attenuationDistance = source.attenuationDistance;
			this.attenuationTint.copy(source.attenuationTint);
			this.specularIntensity = source.specularIntensity;
			this.specularIntensityMap = source.specularIntensityMap;
			this.specularTint.copy(source.specularTint);
			this.specularTintMap = source.specularTintMap;
			return this;
		};

		_createClass(MeshPhysicalMaterial, [{
			key: "sheen",
			get: function get() {
				return this._sheen;
			},
			set: function set(value) {
				if (this._sheen > 0 !== value > 0) {
					this.version++;
				}

				this._sheen = value;
			}
		}, {
			key: "clearcoat",
			get: function get() {
				return this._clearcoat;
			},
			set: function set(value) {
				if (this._clearcoat > 0 !== value > 0) {
					this.version++;
				}

				this._clearcoat = value;
			}
		}, {
			key: "transmission",
			get: function get() {
				return this._transmission;
			},
			set: function set(value) {
				if (this._transmission > 0 !== value > 0) {
					this.version++;
				}

				this._transmission = value;
			}
		}]);

		return MeshPhysicalMaterial;
	}(MeshStandardMaterial);

	MeshPhysicalMaterial.prototype.isMeshPhysicalMaterial = true;

	/**
	 * parameters = {
	 *	color: <hex>,
	 *	specular: <hex>,
	 *	shininess: <float>,
	 *	opacity: <float>,
	 *
	 *	map: new THREE.Texture( <Image> ),
	 *
	 *	lightMap: new THREE.Texture( <Image> ),
	 *	lightMapIntensity: <float>
	 *
	 *	aoMap: new THREE.Texture( <Image> ),
	 *	aoMapIntensity: <float>
	 *
	 *	emissive: <hex>,
	 *	emissiveIntensity: <float>
	 *	emissiveMap: new THREE.Texture( <Image> ),
	 *
	 *	bumpMap: new THREE.Texture( <Image> ),
	 *	bumpScale: <float>,
	 *
	 *	normalMap: new THREE.Texture( <Image> ),
	 *	normalMapType: THREE.TangentSpaceNormalMap,
	 *	normalScale: <Vector2>,
	 *
	 *	displacementMap: new THREE.Texture( <Image> ),
	 *	displacementScale: <float>,
	 *	displacementBias: <float>,
	 *
	 *	specularMap: new THREE.Texture( <Image> ),
	 *
	 *	alphaMap: new THREE.Texture( <Image> ),
	 *
	 *	envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
	 *	combine: THREE.MultiplyOperation,
	 *	reflectivity: <float>,
	 *	refractionRatio: <float>,
	 *
	 *	wireframe: <boolean>,
	 *	wireframeLinewidth: <float>,
	 *
	 *	flatShading: <bool>
	 * }
	 */

	var MeshPhongMaterial = /*#__PURE__*/function (_Material) {
		_inheritsLoose(MeshPhongMaterial, _Material);

		function MeshPhongMaterial(parameters) {
			var _this;

			_this = _Material.call(this) || this;
			_this.type = 'MeshPhongMaterial';
			_this.color = new Color(0xffffff); // diffuse

			_this.specular = new Color(0x111111);
			_this.shininess = 30;
			_this.map = null;
			_this.lightMap = null;
			_this.lightMapIntensity = 1.0;
			_this.aoMap = null;
			_this.aoMapIntensity = 1.0;
			_this.emissive = new Color(0x000000);
			_this.emissiveIntensity = 1.0;
			_this.emissiveMap = null;
			_this.bumpMap = null;
			_this.bumpScale = 1;
			_this.normalMap = null;
			_this.normalMapType = TangentSpaceNormalMap;
			_this.normalScale = new Vector2(1, 1);
			_this.displacementMap = null;
			_this.displacementScale = 1;
			_this.displacementBias = 0;
			_this.specularMap = null;
			_this.alphaMap = null;
			_this.envMap = null;
			_this.combine = MultiplyOperation;
			_this.reflectivity = 1;
			_this.refractionRatio = 0.98;
			_this.wireframe = false;
			_this.wireframeLinewidth = 1;
			_this.wireframeLinecap = 'round';
			_this.wireframeLinejoin = 'round';
			_this.flatShading = false;

			_this.setValues(parameters);

			return _this;
		}

		var _proto = MeshPhongMaterial.prototype;

		_proto.copy = function copy(source) {
			_Material.prototype.copy.call(this, source);

			this.color.copy(source.color);
			this.specular.copy(source.specular);
			this.shininess = source.shininess;
			this.map = source.map;
			this.lightMap = source.lightMap;
			this.lightMapIntensity = source.lightMapIntensity;
			this.aoMap = source.aoMap;
			this.aoMapIntensity = source.aoMapIntensity;
			this.emissive.copy(source.emissive);
			this.emissiveMap = source.emissiveMap;
			this.emissiveIntensity = source.emissiveIntensity;
			this.bumpMap = source.bumpMap;
			this.bumpScale = source.bumpScale;
			this.normalMap = source.normalMap;
			this.normalMapType = source.normalMapType;
			this.normalScale.copy(source.normalScale);
			this.displacementMap = source.displacementMap;
			this.displacementScale = source.displacementScale;
			this.displacementBias = source.displacementBias;
			this.specularMap = source.specularMap;
			this.alphaMap = source.alphaMap;
			this.envMap = source.envMap;
			this.combine = source.combine;
			this.reflectivity = source.reflectivity;
			this.refractionRatio = source.refractionRatio;
			this.wireframe = source.wireframe;
			this.wireframeLinewidth = source.wireframeLinewidth;
			this.wireframeLinecap = source.wireframeLinecap;
			this.wireframeLinejoin = source.wireframeLinejoin;
			this.flatShading = source.flatShading;
			return this;
		};

		return MeshPhongMaterial;
	}(Material);

	MeshPhongMaterial.prototype.isMeshPhongMaterial = true;

	/**
	 * parameters = {
	 *	color: <hex>,
	 *
	 *	map: new THREE.Texture( <Image> ),
	 *	gradientMap: new THREE.Texture( <Image> ),
	 *
	 *	lightMap: new THREE.Texture( <Image> ),
	 *	lightMapIntensity: <float>
	 *
	 *	aoMap: new THREE.Texture( <Image> ),
	 *	aoMapIntensity: <float>
	 *
	 *	emissive: <hex>,
	 *	emissiveIntensity: <float>
	 *	emissiveMap: new THREE.Texture( <Image> ),
	 *
	 *	bumpMap: new THREE.Texture( <Image> ),
	 *	bumpScale: <float>,
	 *
	 *	normalMap: new THREE.Texture( <Image> ),
	 *	normalMapType: THREE.TangentSpaceNormalMap,
	 *	normalScale: <Vector2>,
	 *
	 *	displacementMap: new THREE.Texture( <Image> ),
	 *	displacementScale: <float>,
	 *	displacementBias: <float>,
	 *
	 *	alphaMap: new THREE.Texture( <Image> ),
	 *
	 *	wireframe: <boolean>,
	 *	wireframeLinewidth: <float>,
	 *
	 * }
	 */

	var MeshToonMaterial = /*#__PURE__*/function (_Material) {
		_inheritsLoose(MeshToonMaterial, _Material);

		function MeshToonMaterial(parameters) {
			var _this;

			_this = _Material.call(this) || this;
			_this.defines = {
				'TOON': ''
			};
			_this.type = 'MeshToonMaterial';
			_this.color = new Color(0xffffff);
			_this.map = null;
			_this.gradientMap = null;
			_this.lightMap = null;
			_this.lightMapIntensity = 1.0;
			_this.aoMap = null;
			_this.aoMapIntensity = 1.0;
			_this.emissive = new Color(0x000000);
			_this.emissiveIntensity = 1.0;
			_this.emissiveMap = null;
			_this.bumpMap = null;
			_this.bumpScale = 1;
			_this.normalMap = null;
			_this.normalMapType = TangentSpaceNormalMap;
			_this.normalScale = new Vector2(1, 1);
			_this.displacementMap = null;
			_this.displacementScale = 1;
			_this.displacementBias = 0;
			_this.alphaMap = null;
			_this.wireframe = false;
			_this.wireframeLinewidth = 1;
			_this.wireframeLinecap = 'round';
			_this.wireframeLinejoin = 'round';

			_this.setValues(parameters);

			return _this;
		}

		var _proto = MeshToonMaterial.prototype;

		_proto.copy = function copy(source) {
			_Material.prototype.copy.call(this, source);

			this.color.copy(source.color);
			this.map = source.map;
			this.gradientMap = source.gradientMap;
			this.lightMap = source.lightMap;
			this.lightMapIntensity = source.lightMapIntensity;
			this.aoMap = source.aoMap;
			this.aoMapIntensity = source.aoMapIntensity;
			this.emissive.copy(source.emissive);
			this.emissiveMap = source.emissiveMap;
			this.emissiveIntensity = source.emissiveIntensity;
			this.bumpMap = source.bumpMap;
			this.bumpScale = source.bumpScale;
			this.normalMap = source.normalMap;
			this.normalMapType = source.normalMapType;
			this.normalScale.copy(source.normalScale);
			this.displacementMap = source.displacementMap;
			this.displacementScale = source.displacementScale;
			this.displacementBias = source.displacementBias;
			this.alphaMap = source.alphaMap;
			this.wireframe = source.wireframe;
			this.wireframeLinewidth = source.wireframeLinewidth;
			this.wireframeLinecap = source.wireframeLinecap;
			this.wireframeLinejoin = source.wireframeLinejoin;
			return this;
		};

		return MeshToonMaterial;
	}(Material);

	MeshToonMaterial.prototype.isMeshToonMaterial = true;

	/**
	 * parameters = {
	 *	opacity: <float>,
	 *
	 *	bumpMap: new THREE.Texture( <Image> ),
	 *	bumpScale: <float>,
	 *
	 *	normalMap: new THREE.Texture( <Image> ),
	 *	normalMapType: THREE.TangentSpaceNormalMap,
	 *	normalScale: <Vector2>,
	 *
	 *	displacementMap: new THREE.Texture( <Image> ),
	 *	displacementScale: <float>,
	 *	displacementBias: <float>,
	 *
	 *	wireframe: <boolean>,
	 *	wireframeLinewidth: <float>
	 *
	 *	flatShading: <bool>
	 * }
	 */

	var MeshNormalMaterial = /*#__PURE__*/function (_Material) {
		_inheritsLoose(MeshNormalMaterial, _Material);

		function MeshNormalMaterial(parameters) {
			var _this;

			_this = _Material.call(this) || this;
			_this.type = 'MeshNormalMaterial';
			_this.bumpMap = null;
			_this.bumpScale = 1;
			_this.normalMap = null;
			_this.normalMapType = TangentSpaceNormalMap;
			_this.normalScale = new Vector2(1, 1);
			_this.displacementMap = null;
			_this.displacementScale = 1;
			_this.displacementBias = 0;
			_this.wireframe = false;
			_this.wireframeLinewidth = 1;
			_this.fog = false;
			_this.flatShading = false;

			_this.setValues(parameters);

			return _this;
		}

		var _proto = MeshNormalMaterial.prototype;

		_proto.copy = function copy(source) {
			_Material.prototype.copy.call(this, source);

			this.bumpMap = source.bumpMap;
			this.bumpScale = source.bumpScale;
			this.normalMap = source.normalMap;
			this.normalMapType = source.normalMapType;
			this.normalScale.copy(source.normalScale);
			this.displacementMap = source.displacementMap;
			this.displacementScale = source.displacementScale;
			this.displacementBias = source.displacementBias;
			this.wireframe = source.wireframe;
			this.wireframeLinewidth = source.wireframeLinewidth;
			this.flatShading = source.flatShading;
			return this;
		};

		return MeshNormalMaterial;
	}(Material);

	MeshNormalMaterial.prototype.isMeshNormalMaterial = true;

	/**
	 * parameters = {
	 *	color: <hex>,
	 *	opacity: <float>,
	 *
	 *	map: new THREE.Texture( <Image> ),
	 *
	 *	lightMap: new THREE.Texture( <Image> ),
	 *	lightMapIntensity: <float>
	 *
	 *	aoMap: new THREE.Texture( <Image> ),
	 *	aoMapIntensity: <float>
	 *
	 *	emissive: <hex>,
	 *	emissiveIntensity: <float>
	 *	emissiveMap: new THREE.Texture( <Image> ),
	 *
	 *	specularMap: new THREE.Texture( <Image> ),
	 *
	 *	alphaMap: new THREE.Texture( <Image> ),
	 *
	 *	envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
	 *	combine: THREE.Multiply,
	 *	reflectivity: <float>,
	 *	refractionRatio: <float>,
	 *
	 *	wireframe: <boolean>,
	 *	wireframeLinewidth: <float>,
	 *
	 * }
	 */

	var MeshLambertMaterial = /*#__PURE__*/function (_Material) {
		_inheritsLoose(MeshLambertMaterial, _Material);

		function MeshLambertMaterial(parameters) {
			var _this;

			_this = _Material.call(this) || this;
			_this.type = 'MeshLambertMaterial';
			_this.color = new Color(0xffffff); // diffuse

			_this.map = null;
			_this.lightMap = null;
			_this.lightMapIntensity = 1.0;
			_this.aoMap = null;
			_this.aoMapIntensity = 1.0;
			_this.emissive = new Color(0x000000);
			_this.emissiveIntensity = 1.0;
			_this.emissiveMap = null;
			_this.specularMap = null;
			_this.alphaMap = null;
			_this.envMap = null;
			_this.combine = MultiplyOperation;
			_this.reflectivity = 1;
			_this.refractionRatio = 0.98;
			_this.wireframe = false;
			_this.wireframeLinewidth = 1;
			_this.wireframeLinecap = 'round';
			_this.wireframeLinejoin = 'round';

			_this.setValues(parameters);

			return _this;
		}

		var _proto = MeshLambertMaterial.prototype;

		_proto.copy = function copy(source) {
			_Material.prototype.copy.call(this, source);

			this.color.copy(source.color);
			this.map = source.map;
			this.lightMap = source.lightMap;
			this.lightMapIntensity = source.lightMapIntensity;
			this.aoMap = source.aoMap;
			this.aoMapIntensity = source.aoMapIntensity;
			this.emissive.copy(source.emissive);
			this.emissiveMap = source.emissiveMap;
			this.emissiveIntensity = source.emissiveIntensity;
			this.specularMap = source.specularMap;
			this.alphaMap = source.alphaMap;
			this.envMap = source.envMap;
			this.combine = source.combine;
			this.reflectivity = source.reflectivity;
			this.refractionRatio = source.refractionRatio;
			this.wireframe = source.wireframe;
			this.wireframeLinewidth = source.wireframeLinewidth;
			this.wireframeLinecap = source.wireframeLinecap;
			this.wireframeLinejoin = source.wireframeLinejoin;
			return this;
		};

		return MeshLambertMaterial;
	}(Material);

	MeshLambertMaterial.prototype.isMeshLambertMaterial = true;

	/**
	 * parameters = {
	 *	color: <hex>,
	 *	opacity: <float>,
	 *
	 *	matcap: new THREE.Texture( <Image> ),
	 *
	 *	map: new THREE.Texture( <Image> ),
	 *
	 *	bumpMap: new THREE.Texture( <Image> ),
	 *	bumpScale: <float>,
	 *
	 *	normalMap: new THREE.Texture( <Image> ),
	 *	normalMapType: THREE.TangentSpaceNormalMap,
	 *	normalScale: <Vector2>,
	 *
	 *	displacementMap: new THREE.Texture( <Image> ),
	 *	displacementScale: <float>,
	 *	displacementBias: <float>,
	 *
	 *	alphaMap: new THREE.Texture( <Image> ),
	 *
	 *	flatShading: <bool>
	 * }
	 */

	var MeshMatcapMaterial = /*#__PURE__*/function (_Material) {
		_inheritsLoose(MeshMatcapMaterial, _Material);

		function MeshMatcapMaterial(parameters) {
			var _this;

			_this = _Material.call(this) || this;
			_this.defines = {
				'MATCAP': ''
			};
			_this.type = 'MeshMatcapMaterial';
			_this.color = new Color(0xffffff); // diffuse

			_this.matcap = null;
			_this.map = null;
			_this.bumpMap = null;
			_this.bumpScale = 1;
			_this.normalMap = null;
			_this.normalMapType = TangentSpaceNormalMap;
			_this.normalScale = new Vector2(1, 1);
			_this.displacementMap = null;
			_this.displacementScale = 1;
			_this.displacementBias = 0;
			_this.alphaMap = null;
			_this.flatShading = false;

			_this.setValues(parameters);

			return _this;
		}

		var _proto = MeshMatcapMaterial.prototype;

		_proto.copy = function copy(source) {
			_Material.prototype.copy.call(this, source);

			this.defines = {
				'MATCAP': ''
			};
			this.color.copy(source.color);
			this.matcap = source.matcap;
			this.map = source.map;
			this.bumpMap = source.bumpMap;
			this.bumpScale = source.bumpScale;
			this.normalMap = source.normalMap;
			this.normalMapType = source.normalMapType;
			this.normalScale.copy(source.normalScale);
			this.displacementMap = source.displacementMap;
			this.displacementScale = source.displacementScale;
			this.displacementBias = source.displacementBias;
			this.alphaMap = source.alphaMap;
			this.flatShading = source.flatShading;
			return this;
		};

		return MeshMatcapMaterial;
	}(Material);

	MeshMatcapMaterial.prototype.isMeshMatcapMaterial = true;

	/**
	 * parameters = {
	 *	color: <hex>,
	 *	opacity: <float>,
	 *
	 *	linewidth: <float>,
	 *
	 *	scale: <float>,
	 *	dashSize: <float>,
	 *	gapSize: <float>
	 * }
	 */

	var LineDashedMaterial = /*#__PURE__*/function (_LineBasicMaterial) {
		_inheritsLoose(LineDashedMaterial, _LineBasicMaterial);

		function LineDashedMaterial(parameters) {
			var _this;

			_this = _LineBasicMaterial.call(this) || this;
			_this.type = 'LineDashedMaterial';
			_this.scale = 1;
			_this.dashSize = 3;
			_this.gapSize = 1;

			_this.setValues(parameters);

			return _this;
		}

		var _proto = LineDashedMaterial.prototype;

		_proto.copy = function copy(source) {
			_LineBasicMaterial.prototype.copy.call(this, source);

			this.scale = source.scale;
			this.dashSize = source.dashSize;
			this.gapSize = source.gapSize;
			return this;
		};

		return LineDashedMaterial;
	}(LineBasicMaterial);

	LineDashedMaterial.prototype.isLineDashedMaterial = true;

	var Materials = /*#__PURE__*/Object.freeze({
		__proto__: null,
		ShadowMaterial: ShadowMaterial,
		SpriteMaterial: SpriteMaterial,
		RawShaderMaterial: RawShaderMaterial,
		ShaderMaterial: ShaderMaterial,
		PointsMaterial: PointsMaterial,
		MeshPhysicalMaterial: MeshPhysicalMaterial,
		MeshStandardMaterial: MeshStandardMaterial,
		MeshPhongMaterial: MeshPhongMaterial,
		MeshToonMaterial: MeshToonMaterial,
		MeshNormalMaterial: MeshNormalMaterial,
		MeshLambertMaterial: MeshLambertMaterial,
		MeshDepthMaterial: MeshDepthMaterial,
		MeshDistanceMaterial: MeshDistanceMaterial,
		MeshBasicMaterial: MeshBasicMaterial,
		MeshMatcapMaterial: MeshMatcapMaterial,
		LineDashedMaterial: LineDashedMaterial,
		LineBasicMaterial: LineBasicMaterial,
		Material: Material
	});

	var AnimationUtils = {
		// same as Array.prototype.slice, but also works on typed arrays
		arraySlice: function arraySlice(array, from, to) {
			if (AnimationUtils.isTypedArray(array)) {
				// in ios9 array.subarray(from, undefined) will return empty array
				// but array.subarray(from) or array.subarray(from, len) is correct
				return new array.constructor(array.subarray(from, to !== undefined ? to : array.length));
			}

			return array.slice(from, to);
		},
		// converts an array to a specific type
		convertArray: function convertArray(array, type, forceClone) {
			if (!array || // let 'undefined' and 'null' pass
			!forceClone && array.constructor === type) return array;

			if (typeof type.BYTES_PER_ELEMENT === 'number') {
				return new type(array); // create typed array
			}

			return Array.prototype.slice.call(array); // create Array
		},
		isTypedArray: function isTypedArray(object) {
			return ArrayBuffer.isView(object) && !(object instanceof DataView);
		},
		// returns an array by which times and values can be sorted
		getKeyframeOrder: function getKeyframeOrder(times) {
			function compareTime(i, j) {
				return times[i] - times[j];
			}

			var n = times.length;
			var result = new Array(n);

			for (var i = 0; i !== n; ++i) {
				result[i] = i;
			}

			result.sort(compareTime);
			return result;
		},
		// uses the array previously returned by 'getKeyframeOrder' to sort data
		sortedArray: function sortedArray(values, stride, order) {
			var nValues = values.length;
			var result = new values.constructor(nValues);

			for (var i = 0, dstOffset = 0; dstOffset !== nValues; ++i) {
				var srcOffset = order[i] * stride;

				for (var j = 0; j !== stride; ++j) {
					result[dstOffset++] = values[srcOffset + j];
				}
			}

			return result;
		},
		// function for parsing AOS keyframe formats
		flattenJSON: function flattenJSON(jsonKeys, times, values, valuePropertyName) {
			var i = 1,
					key = jsonKeys[0];

			while (key !== undefined && key[valuePropertyName] === undefined) {
				key = jsonKeys[i++];
			}

			if (key === undefined) return; // no data

			var value = key[valuePropertyName];
			if (value === undefined) return; // no data

			if (Array.isArray(value)) {
				do {
					value = key[valuePropertyName];

					if (value !== undefined) {
						times.push(key.time);
						values.push.apply(values, value); // push all elements
					}

					key = jsonKeys[i++];
				} while (key !== undefined);
			} else if (value.toArray !== undefined) {
				// ...assume THREE.Math-ish
				do {
					value = key[valuePropertyName];

					if (value !== undefined) {
						times.push(key.time);
						value.toArray(values, values.length);
					}

					key = jsonKeys[i++];
				} while (key !== undefined);
			} else {
				// otherwise push as-is
				do {
					value = key[valuePropertyName];

					if (value !== undefined) {
						times.push(key.time);
						values.push(value);
					}

					key = jsonKeys[i++];
				} while (key !== undefined);
			}
		},
		subclip: function subclip(sourceClip, name, startFrame, endFrame, fps) {
			if (fps === void 0) {
				fps = 30;
			}

			var clip = sourceClip.clone();
			clip.name = name;
			var tracks = [];

			for (var i = 0; i < clip.tracks.length; ++i) {
				var track = clip.tracks[i];
				var valueSize = track.getValueSize();
				var times = [];
				var values = [];

				for (var j = 0; j < track.times.length; ++j) {
					var frame = track.times[j] * fps;
					if (frame < startFrame || frame >= endFrame) continue;
					times.push(track.times[j]);

					for (var k = 0; k < valueSize; ++k) {
						values.push(track.values[j * valueSize + k]);
					}
				}

				if (times.length === 0) continue;
				track.times = AnimationUtils.convertArray(times, track.times.constructor);
				track.values = AnimationUtils.convertArray(values, track.values.constructor);
				tracks.push(track);
			}

			clip.tracks = tracks; // find minimum .times value across all tracks in the trimmed clip

			var minStartTime = Infinity;

			for (var _i = 0; _i < clip.tracks.length; ++_i) {
				if (minStartTime > clip.tracks[_i].times[0]) {
					minStartTime = clip.tracks[_i].times[0];
				}
			} // shift all tracks such that clip begins at t=0


			for (var _i2 = 0; _i2 < clip.tracks.length; ++_i2) {
				clip.tracks[_i2].shift(-1 * minStartTime);
			}

			clip.resetDuration();
			return clip;
		},
		makeClipAdditive: function makeClipAdditive(targetClip, referenceFrame, referenceClip, fps) {
			if (referenceFrame === void 0) {
				referenceFrame = 0;
			}

			if (referenceClip === void 0) {
				referenceClip = targetClip;
			}

			if (fps === void 0) {
				fps = 30;
			}

			if (fps <= 0) fps = 30;
			var numTracks = referenceClip.tracks.length;
			var referenceTime = referenceFrame / fps; // Make each track's values relative to the values at the reference frame

			var _loop = function _loop(i) {
				var referenceTrack = referenceClip.tracks[i];
				var referenceTrackType = referenceTrack.ValueTypeName; // Skip this track if it's non-numeric

				if (referenceTrackType === 'bool' || referenceTrackType === 'string') return "continue"; // Find the track in the target clip whose name and type matches the reference track

				var targetTrack = targetClip.tracks.find(function (track) {
					return track.name === referenceTrack.name && track.ValueTypeName === referenceTrackType;
				});
				if (targetTrack === undefined) return "continue";
				var referenceOffset = 0;
				var referenceValueSize = referenceTrack.getValueSize();

				if (referenceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {
					referenceOffset = referenceValueSize / 3;
				}

				var targetOffset = 0;
				var targetValueSize = targetTrack.getValueSize();

				if (targetTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {
					targetOffset = targetValueSize / 3;
				}

				var lastIndex = referenceTrack.times.length - 1;
				var referenceValue = void 0; // Find the value to subtract out of the track

				if (referenceTime <= referenceTrack.times[0]) {
					// Reference frame is earlier than the first keyframe, so just use the first keyframe
					var startIndex = referenceOffset;
					var endIndex = referenceValueSize - referenceOffset;
					referenceValue = AnimationUtils.arraySlice(referenceTrack.values, startIndex, endIndex);
				} else if (referenceTime >= referenceTrack.times[lastIndex]) {
					// Reference frame is after the last keyframe, so just use the last keyframe
					var _startIndex = lastIndex * referenceValueSize + referenceOffset;

					var _endIndex = _startIndex + referenceValueSize - referenceOffset;

					referenceValue = AnimationUtils.arraySlice(referenceTrack.values, _startIndex, _endIndex);
				} else {
					// Interpolate to the reference value
					var interpolant = referenceTrack.createInterpolant();
					var _startIndex2 = referenceOffset;

					var _endIndex2 = referenceValueSize - referenceOffset;

					interpolant.evaluate(referenceTime);
					referenceValue = AnimationUtils.arraySlice(interpolant.resultBuffer, _startIndex2, _endIndex2);
				} // Conjugate the quaternion


				if (referenceTrackType === 'quaternion') {
					var referenceQuat = new Quaternion().fromArray(referenceValue).normalize().conjugate();
					referenceQuat.toArray(referenceValue);
				} // Subtract the reference value from all of the track values


				var numTimes = targetTrack.times.length;

				for (var j = 0; j < numTimes; ++j) {
					var valueStart = j * targetValueSize + targetOffset;

					if (referenceTrackType === 'quaternion') {
						// Multiply the conjugate for quaternion track types
						Quaternion.multiplyQuaternionsFlat(targetTrack.values, valueStart, referenceValue, 0, targetTrack.values, valueStart);
					} else {
						var valueEnd = targetValueSize - targetOffset * 2; // Subtract each value for all other numeric track types

						for (var k = 0; k < valueEnd; ++k) {
							targetTrack.values[valueStart + k] -= referenceValue[k];
						}
					}
				}
			};

			for (var i = 0; i < numTracks; ++i) {
				var _ret = _loop(i);

				if (_ret === "continue") continue;
			}

			targetClip.blendMode = AdditiveAnimationBlendMode;
			return targetClip;
		}
	};

	/**
	 * Abstract base class of interpolants over parametric samples.
	 *
	 * The parameter domain is one dimensional, typically the time or a path
	 * along a curve defined by the data.
	 *
	 * The sample values can have any dimensionality and derived classes may
	 * apply special interpretations to the data.
	 *
	 * This class provides the interval seek in a Template Method, deferring
	 * the actual interpolation to derived classes.
	 *
	 * Time complexity is O(1) for linear access crossing at most two points
	 * and O(log N) for random access, where N is the number of positions.
	 *
	 * References:
	 *
	 * 		http://www.oodesign.com/template-method-pattern.html
	 *
	 */
	var Interpolant = /*#__PURE__*/function () {
		function Interpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
			this.parameterPositions = parameterPositions;
			this._cachedIndex = 0;
			this.resultBuffer = resultBuffer !== undefined ? resultBuffer : new sampleValues.constructor(sampleSize);
			this.sampleValues = sampleValues;
			this.valueSize = sampleSize;
			this.settings = null;
			this.DefaultSettings_ = {};
		}

		var _proto = Interpolant.prototype;

		_proto.evaluate = function evaluate(t) {
			var pp = this.parameterPositions;
			var i1 = this._cachedIndex,
					t1 = pp[i1],
					t0 = pp[i1 - 1];

			validate_interval: {
				seek: {
					var right;

					linear_scan: {
						//- See http://jsperf.com/comparison-to-undefined/3
						//- slower code:
						//-
						//- 				if ( t >= t1 || t1 === undefined ) {
						forward_scan: if (!(t < t1)) {
							for (var giveUpAt = i1 + 2;;) {
								if (t1 === undefined) {
									if (t < t0) break forward_scan; // after end

									i1 = pp.length;
									this._cachedIndex = i1;
									return this.afterEnd_(i1 - 1, t, t0);
								}

								if (i1 === giveUpAt) break; // this loop

								t0 = t1;
								t1 = pp[++i1];

								if (t < t1) {
									// we have arrived at the sought interval
									break seek;
								}
							} // prepare binary search on the right side of the index


							right = pp.length;
							break linear_scan;
						} //- slower code:
						//-					if ( t < t0 || t0 === undefined ) {


						if (!(t >= t0)) {
							// looping?
							var t1global = pp[1];

							if (t < t1global) {
								i1 = 2; // + 1, using the scan for the details

								t0 = t1global;
							} // linear reverse scan


							for (var _giveUpAt = i1 - 2;;) {
								if (t0 === undefined) {
									// before start
									this._cachedIndex = 0;
									return this.beforeStart_(0, t, t1);
								}

								if (i1 === _giveUpAt) break; // this loop

								t1 = t0;
								t0 = pp[--i1 - 1];

								if (t >= t0) {
									// we have arrived at the sought interval
									break seek;
								}
							} // prepare binary search on the left side of the index


							right = i1;
							i1 = 0;
							break linear_scan;
						} // the interval is valid


						break validate_interval;
					} // linear scan
					// binary search


					while (i1 < right) {
						var mid = i1 + right >>> 1;

						if (t < pp[mid]) {
							right = mid;
						} else {
							i1 = mid + 1;
						}
					}

					t1 = pp[i1];
					t0 = pp[i1 - 1]; // check boundary cases, again

					if (t0 === undefined) {
						this._cachedIndex = 0;
						return this.beforeStart_(0, t, t1);
					}

					if (t1 === undefined) {
						i1 = pp.length;
						this._cachedIndex = i1;
						return this.afterEnd_(i1 - 1, t0, t);
					}
				} // seek


				this._cachedIndex = i1;
				this.intervalChanged_(i1, t0, t1);
			} // validate_interval


			return this.interpolate_(i1, t0, t, t1);
		};

		_proto.getSettings_ = function getSettings_() {
			return this.settings || this.DefaultSettings_;
		};

		_proto.copySampleValue_ = function copySampleValue_(index) {
			// copies a sample value to the result buffer
			var result = this.resultBuffer,
					values = this.sampleValues,
					stride = this.valueSize,
					offset = index * stride;

			for (var i = 0; i !== stride; ++i) {
				result[i] = values[offset + i];
			}

			return result;
		} // Template methods for derived classes:
		;

		_proto.interpolate_ = function interpolate_()
		/* i1, t0, t, t1 */
		{
			throw new Error('call to abstract method'); // implementations shall return this.resultBuffer
		};

		_proto.intervalChanged_ = function intervalChanged_()
		/* i1, t0, t1 */
		{// empty
		};

		return Interpolant;
	}(); // ALIAS DEFINITIONS


	Interpolant.prototype.beforeStart_ = Interpolant.prototype.copySampleValue_;
	Interpolant.prototype.afterEnd_ = Interpolant.prototype.copySampleValue_;

	/**
	 * Fast and simple cubic spline interpolant.
	 *
	 * It was derived from a Hermitian construction setting the first derivative
	 * at each sample position to the linear slope between neighboring positions
	 * over their parameter interval.
	 */

	var CubicInterpolant = /*#__PURE__*/function (_Interpolant) {
		_inheritsLoose(CubicInterpolant, _Interpolant);

		function CubicInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
			var _this;

			_this = _Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer) || this;
			_this._weightPrev = -0;
			_this._offsetPrev = -0;
			_this._weightNext = -0;
			_this._offsetNext = -0;
			_this.DefaultSettings_ = {
				endingStart: ZeroCurvatureEnding,
				endingEnd: ZeroCurvatureEnding
			};
			return _this;
		}

		var _proto = CubicInterpolant.prototype;

		_proto.intervalChanged_ = function intervalChanged_(i1, t0, t1) {
			var pp = this.parameterPositions;
			var iPrev = i1 - 2,
					iNext = i1 + 1,
					tPrev = pp[iPrev],
					tNext = pp[iNext];

			if (tPrev === undefined) {
				switch (this.getSettings_().endingStart) {
					case ZeroSlopeEnding:
						// f'(t0) = 0
						iPrev = i1;
						tPrev = 2 * t0 - t1;
						break;

					case WrapAroundEnding:
						// use the other end of the curve
						iPrev = pp.length - 2;
						tPrev = t0 + pp[iPrev] - pp[iPrev + 1];
						break;

					default:
						// ZeroCurvatureEnding
						// f''(t0) = 0 a.k.a. Natural Spline
						iPrev = i1;
						tPrev = t1;
				}
			}

			if (tNext === undefined) {
				switch (this.getSettings_().endingEnd) {
					case ZeroSlopeEnding:
						// f'(tN) = 0
						iNext = i1;
						tNext = 2 * t1 - t0;
						break;

					case WrapAroundEnding:
						// use the other end of the curve
						iNext = 1;
						tNext = t1 + pp[1] - pp[0];
						break;

					default:
						// ZeroCurvatureEnding
						// f''(tN) = 0, a.k.a. Natural Spline
						iNext = i1 - 1;
						tNext = t0;
				}
			}

			var halfDt = (t1 - t0) * 0.5,
					stride = this.valueSize;
			this._weightPrev = halfDt / (t0 - tPrev);
			this._weightNext = halfDt / (tNext - t1);
			this._offsetPrev = iPrev * stride;
			this._offsetNext = iNext * stride;
		};

		_proto.interpolate_ = function interpolate_(i1, t0, t, t1) {
			var result = this.resultBuffer,
					values = this.sampleValues,
					stride = this.valueSize,
					o1 = i1 * stride,
					o0 = o1 - stride,
					oP = this._offsetPrev,
					oN = this._offsetNext,
					wP = this._weightPrev,
					wN = this._weightNext,
					p = (t - t0) / (t1 - t0),
					pp = p * p,
					ppp = pp * p; // evaluate polynomials

			var sP = -wP * ppp + 2 * wP * pp - wP * p;
			var s0 = (1 + wP) * ppp + (-1.5 - 2 * wP) * pp + (-0.5 + wP) * p + 1;
			var s1 = (-1 - wN) * ppp + (1.5 + wN) * pp + 0.5 * p;
			var sN = wN * ppp - wN * pp; // combine data linearly

			for (var i = 0; i !== stride; ++i) {
				result[i] = sP * values[oP + i] + s0 * values[o0 + i] + s1 * values[o1 + i] + sN * values[oN + i];
			}

			return result;
		};

		return CubicInterpolant;
	}(Interpolant);

	var LinearInterpolant = /*#__PURE__*/function (_Interpolant) {
		_inheritsLoose(LinearInterpolant, _Interpolant);

		function LinearInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
			return _Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer) || this;
		}

		var _proto = LinearInterpolant.prototype;

		_proto.interpolate_ = function interpolate_(i1, t0, t, t1) {
			var result = this.resultBuffer,
					values = this.sampleValues,
					stride = this.valueSize,
					offset1 = i1 * stride,
					offset0 = offset1 - stride,
					weight1 = (t - t0) / (t1 - t0),
					weight0 = 1 - weight1;

			for (var i = 0; i !== stride; ++i) {
				result[i] = values[offset0 + i] * weight0 + values[offset1 + i] * weight1;
			}

			return result;
		};

		return LinearInterpolant;
	}(Interpolant);

	/**
	 *
	 * Interpolant that evaluates to the sample value at the position preceeding
	 * the parameter.
	 */

	var DiscreteInterpolant = /*#__PURE__*/function (_Interpolant) {
		_inheritsLoose(DiscreteInterpolant, _Interpolant);

		function DiscreteInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
			return _Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer) || this;
		}

		var _proto = DiscreteInterpolant.prototype;

		_proto.interpolate_ = function interpolate_(i1
		/*, t0, t, t1 */
		) {
			return this.copySampleValue_(i1 - 1);
		};

		return DiscreteInterpolant;
	}(Interpolant);

	var KeyframeTrack = /*#__PURE__*/function () {
		function KeyframeTrack(name, times, values, interpolation) {
			if (name === undefined) throw new Error('THREE.KeyframeTrack: track name is undefined');
			if (times === undefined || times.length === 0) throw new Error('THREE.KeyframeTrack: no keyframes in track named ' + name);
			this.name = name;
			this.times = AnimationUtils.convertArray(times, this.TimeBufferType);
			this.values = AnimationUtils.convertArray(values, this.ValueBufferType);
			this.setInterpolation(interpolation || this.DefaultInterpolation);
		} // Serialization (in static context, because of constructor invocation
		// and automatic invocation of .toJSON):


		KeyframeTrack.toJSON = function toJSON(track) {
			var trackType = track.constructor;
			var json; // derived classes can define a static toJSON method

			if (trackType.toJSON !== this.toJSON) {
				json = trackType.toJSON(track);
			} else {
				// by default, we assume the data can be serialized as-is
				json = {
					'name': track.name,
					'times': AnimationUtils.convertArray(track.times, Array),
					'values': AnimationUtils.convertArray(track.values, Array)
				};
				var interpolation = track.getInterpolation();

				if (interpolation !== track.DefaultInterpolation) {
					json.interpolation = interpolation;
				}
			}

			json.type = track.ValueTypeName; // mandatory

			return json;
		};

		var _proto = KeyframeTrack.prototype;

		_proto.InterpolantFactoryMethodDiscrete = function InterpolantFactoryMethodDiscrete(result) {
			return new DiscreteInterpolant(this.times, this.values, this.getValueSize(), result);
		};

		_proto.InterpolantFactoryMethodLinear = function InterpolantFactoryMethodLinear(result) {
			return new LinearInterpolant(this.times, this.values, this.getValueSize(), result);
		};

		_proto.InterpolantFactoryMethodSmooth = function InterpolantFactoryMethodSmooth(result) {
			return new CubicInterpolant(this.times, this.values, this.getValueSize(), result);
		};

		_proto.setInterpolation = function setInterpolation(interpolation) {
			var factoryMethod;

			switch (interpolation) {
				case InterpolateDiscrete:
					factoryMethod = this.InterpolantFactoryMethodDiscrete;
					break;

				case InterpolateLinear:
					factoryMethod = this.InterpolantFactoryMethodLinear;
					break;

				case InterpolateSmooth:
					factoryMethod = this.InterpolantFactoryMethodSmooth;
					break;
			}

			if (factoryMethod === undefined) {
				var message = 'unsupported interpolation for ' + this.ValueTypeName + ' keyframe track named ' + this.name;

				if (this.createInterpolant === undefined) {
					// fall back to default, unless the default itself is messed up
					if (interpolation !== this.DefaultInterpolation) {
						this.setInterpolation(this.DefaultInterpolation);
					} else {
						throw new Error(message); // fatal, in this case
					}
				}

				console.warn('THREE.KeyframeTrack:', message);
				return this;
			}

			this.createInterpolant = factoryMethod;
			return this;
		};

		_proto.getInterpolation = function getInterpolation() {
			switch (this.createInterpolant) {
				case this.InterpolantFactoryMethodDiscrete:
					return InterpolateDiscrete;

				case this.InterpolantFactoryMethodLinear:
					return InterpolateLinear;

				case this.InterpolantFactoryMethodSmooth:
					return InterpolateSmooth;
			}
		};

		_proto.getValueSize = function getValueSize() {
			return this.values.length / this.times.length;
		} // move all keyframes either forwards or backwards in time
		;

		_proto.shift = function shift(timeOffset) {
			if (timeOffset !== 0.0) {
				var times = this.times;

				for (var i = 0, n = times.length; i !== n; ++i) {
					times[i] += timeOffset;
				}
			}

			return this;
		} // scale all keyframe times by a factor (useful for frame <-> seconds conversions)
		;

		_proto.scale = function scale(timeScale) {
			if (timeScale !== 1.0) {
				var times = this.times;

				for (var i = 0, n = times.length; i !== n; ++i) {
					times[i] *= timeScale;
				}
			}

			return this;
		} // removes keyframes before and after animation without changing any values within the range [startTime, endTime].
		// IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
		;

		_proto.trim = function trim(startTime, endTime) {
			var times = this.times,
					nKeys = times.length;
			var from = 0,
					to = nKeys - 1;

			while (from !== nKeys && times[from] < startTime) {
				++from;
			}

			while (to !== -1 && times[to] > endTime) {
				--to;
			}

			++to; // inclusive -> exclusive bound

			if (from !== 0 || to !== nKeys) {
				// empty tracks are forbidden, so keep at least one keyframe
				if (from >= to) {
					to = Math.max(to, 1);
					from = to - 1;
				}

				var stride = this.getValueSize();
				this.times = AnimationUtils.arraySlice(times, from, to);
				this.values = AnimationUtils.arraySlice(this.values, from * stride, to * stride);
			}

			return this;
		} // ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
		;

		_proto.validate = function validate() {
			var valid = true;
			var valueSize = this.getValueSize();

			if (valueSize - Math.floor(valueSize) !== 0) {
				console.error('THREE.KeyframeTrack: Invalid value size in track.', this);
				valid = false;
			}

			var times = this.times,
					values = this.values,
					nKeys = times.length;

			if (nKeys === 0) {
				console.error('THREE.KeyframeTrack: Track is empty.', this);
				valid = false;
			}

			var prevTime = null;

			for (var i = 0; i !== nKeys; i++) {
				var currTime = times[i];

				if (typeof currTime === 'number' && isNaN(currTime)) {
					console.error('THREE.KeyframeTrack: Time is not a valid number.', this, i, currTime);
					valid = false;
					break;
				}

				if (prevTime !== null && prevTime > currTime) {
					console.error('THREE.KeyframeTrack: Out of order keys.', this, i, currTime, prevTime);
					valid = false;
					break;
				}

				prevTime = currTime;
			}

			if (values !== undefined) {
				if (AnimationUtils.isTypedArray(values)) {
					for (var _i = 0, n = values.length; _i !== n; ++_i) {
						var value = values[_i];

						if (isNaN(value)) {
							console.error('THREE.KeyframeTrack: Value is not a valid number.', this, _i, value);
							valid = false;
							break;
						}
					}
				}
			}

			return valid;
		} // removes equivalent sequential keys as common in morph target sequences
		// (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)
		;

		_proto.optimize = function optimize() {
			// times or values may be shared with other tracks, so overwriting is unsafe
			var times = AnimationUtils.arraySlice(this.times),
					values = AnimationUtils.arraySlice(this.values),
					stride = this.getValueSize(),
					smoothInterpolation = this.getInterpolation() === InterpolateSmooth,
					lastIndex = times.length - 1;
			var writeIndex = 1;

			for (var i = 1; i < lastIndex; ++i) {
				var keep = false;
				var time = times[i];
				var timeNext = times[i + 1]; // remove adjacent keyframes scheduled at the same time

				if (time !== timeNext && (i !== 1 || time !== times[0])) {
					if (!smoothInterpolation) {
						// remove unnecessary keyframes same as their neighbors
						var offset = i * stride,
								offsetP = offset - stride,
								offsetN = offset + stride;

						for (var j = 0; j !== stride; ++j) {
							var value = values[offset + j];

							if (value !== values[offsetP + j] || value !== values[offsetN + j]) {
								keep = true;
								break;
							}
						}
					} else {
						keep = true;
					}
				} // in-place compaction


				if (keep) {
					if (i !== writeIndex) {
						times[writeIndex] = times[i];
						var readOffset = i * stride,
								writeOffset = writeIndex * stride;

						for (var _j = 0; _j !== stride; ++_j) {
							values[writeOffset + _j] = values[readOffset + _j];
						}
					}

					++writeIndex;
				}
			} // flush last keyframe (compaction looks ahead)


			if (lastIndex > 0) {
				times[writeIndex] = times[lastIndex];

				for (var _readOffset = lastIndex * stride, _writeOffset = writeIndex * stride, _j2 = 0; _j2 !== stride; ++_j2) {
					values[_writeOffset + _j2] = values[_readOffset + _j2];
				}

				++writeIndex;
			}

			if (writeIndex !== times.length) {
				this.times = AnimationUtils.arraySlice(times, 0, writeIndex);
				this.values = AnimationUtils.arraySlice(values, 0, writeIndex * stride);
			} else {
				this.times = times;
				this.values = values;
			}

			return this;
		};

		_proto.clone = function clone() {
			var times = AnimationUtils.arraySlice(this.times, 0);
			var values = AnimationUtils.arraySlice(this.values, 0);
			var TypedKeyframeTrack = this.constructor;
			var track = new TypedKeyframeTrack(this.name, times, values); // Interpolant argument to constructor is not saved, so copy the factory method directly.

			track.createInterpolant = this.createInterpolant;
			return track;
		};

		return KeyframeTrack;
	}();

	KeyframeTrack.prototype.TimeBufferType = Float32Array;
	KeyframeTrack.prototype.ValueBufferType = Float32Array;
	KeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;

	/**
	 * A Track of Boolean keyframe values.
	 */

	var BooleanKeyframeTrack = /*#__PURE__*/function (_KeyframeTrack) {
		_inheritsLoose(BooleanKeyframeTrack, _KeyframeTrack);

		function BooleanKeyframeTrack() {
			return _KeyframeTrack.apply(this, arguments) || this;
		}

		return BooleanKeyframeTrack;
	}(KeyframeTrack);

	BooleanKeyframeTrack.prototype.ValueTypeName = 'bool';
	BooleanKeyframeTrack.prototype.ValueBufferType = Array;
	BooleanKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
	BooleanKeyframeTrack.prototype.InterpolantFactoryMethodLinear = undefined;
	BooleanKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined; // Note: Actually this track could have a optimized / compressed

	/**
	 * A Track of keyframe values that represent color.
	 */

	var ColorKeyframeTrack = /*#__PURE__*/function (_KeyframeTrack) {
		_inheritsLoose(ColorKeyframeTrack, _KeyframeTrack);

		function ColorKeyframeTrack() {
			return _KeyframeTrack.apply(this, arguments) || this;
		}

		return ColorKeyframeTrack;
	}(KeyframeTrack);

	ColorKeyframeTrack.prototype.ValueTypeName = 'color'; // ValueBufferType is inherited

	/**
	 * A Track of numeric keyframe values.
	 */

	var NumberKeyframeTrack = /*#__PURE__*/function (_KeyframeTrack) {
		_inheritsLoose(NumberKeyframeTrack, _KeyframeTrack);

		function NumberKeyframeTrack() {
			return _KeyframeTrack.apply(this, arguments) || this;
		}

		return NumberKeyframeTrack;
	}(KeyframeTrack);

	NumberKeyframeTrack.prototype.ValueTypeName = 'number'; // ValueBufferType is inherited

	/**
	 * Spherical linear unit quaternion interpolant.
	 */

	var QuaternionLinearInterpolant = /*#__PURE__*/function (_Interpolant) {
		_inheritsLoose(QuaternionLinearInterpolant, _Interpolant);

		function QuaternionLinearInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
			return _Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer) || this;
		}

		var _proto = QuaternionLinearInterpolant.prototype;

		_proto.interpolate_ = function interpolate_(i1, t0, t, t1) {
			var result = this.resultBuffer,
					values = this.sampleValues,
					stride = this.valueSize,
					alpha = (t - t0) / (t1 - t0);
			var offset = i1 * stride;

			for (var end = offset + stride; offset !== end; offset += 4) {
				Quaternion.slerpFlat(result, 0, values, offset - stride, values, offset, alpha);
			}

			return result;
		};

		return QuaternionLinearInterpolant;
	}(Interpolant);

	/**
	 * A Track of quaternion keyframe values.
	 */

	var QuaternionKeyframeTrack = /*#__PURE__*/function (_KeyframeTrack) {
		_inheritsLoose(QuaternionKeyframeTrack, _KeyframeTrack);

		function QuaternionKeyframeTrack() {
			return _KeyframeTrack.apply(this, arguments) || this;
		}

		var _proto = QuaternionKeyframeTrack.prototype;

		_proto.InterpolantFactoryMethodLinear = function InterpolantFactoryMethodLinear(result) {
			return new QuaternionLinearInterpolant(this.times, this.values, this.getValueSize(), result);
		};

		return QuaternionKeyframeTrack;
	}(KeyframeTrack);

	QuaternionKeyframeTrack.prototype.ValueTypeName = 'quaternion'; // ValueBufferType is inherited

	QuaternionKeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;
	QuaternionKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;

	/**
	 * A Track that interpolates Strings
	 */

	var StringKeyframeTrack = /*#__PURE__*/function (_KeyframeTrack) {
		_inheritsLoose(StringKeyframeTrack, _KeyframeTrack);

		function StringKeyframeTrack() {
			return _KeyframeTrack.apply(this, arguments) || this;
		}

		return StringKeyframeTrack;
	}(KeyframeTrack);

	StringKeyframeTrack.prototype.ValueTypeName = 'string';
	StringKeyframeTrack.prototype.ValueBufferType = Array;
	StringKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
	StringKeyframeTrack.prototype.InterpolantFactoryMethodLinear = undefined;
	StringKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;

	/**
	 * A Track of vectored keyframe values.
	 */

	var VectorKeyframeTrack = /*#__PURE__*/function (_KeyframeTrack) {
		_inheritsLoose(VectorKeyframeTrack, _KeyframeTrack);

		function VectorKeyframeTrack() {
			return _KeyframeTrack.apply(this, arguments) || this;
		}

		return VectorKeyframeTrack;
	}(KeyframeTrack);

	VectorKeyframeTrack.prototype.ValueTypeName = 'vector'; // ValueBufferType is inherited

	var AnimationClip = /*#__PURE__*/function () {
		function AnimationClip(name, duration, tracks, blendMode) {
			if (duration === void 0) {
				duration = -1;
			}

			if (blendMode === void 0) {
				blendMode = NormalAnimationBlendMode;
			}

			this.name = name;
			this.tracks = tracks;
			this.duration = duration;
			this.blendMode = blendMode;
			this.uuid = generateUUID(); // this means it should figure out its duration by scanning the tracks

			if (this.duration < 0) {
				this.resetDuration();
			}
		}

		AnimationClip.parse = function parse(json) {
			var tracks = [],
					jsonTracks = json.tracks,
					frameTime = 1.0 / (json.fps || 1.0);

			for (var i = 0, n = jsonTracks.length; i !== n; ++i) {
				tracks.push(parseKeyframeTrack(jsonTracks[i]).scale(frameTime));
			}

			var clip = new this(json.name, json.duration, tracks, json.blendMode);
			clip.uuid = json.uuid;
			return clip;
		};

		AnimationClip.toJSON = function toJSON(clip) {
			var tracks = [],
					clipTracks = clip.tracks;
			var json = {
				'name': clip.name,
				'duration': clip.duration,
				'tracks': tracks,
				'uuid': clip.uuid,
				'blendMode': clip.blendMode
			};

			for (var i = 0, n = clipTracks.length; i !== n; ++i) {
				tracks.push(KeyframeTrack.toJSON(clipTracks[i]));
			}

			return json;
		};

		AnimationClip.CreateFromMorphTargetSequence = function CreateFromMorphTargetSequence(name, morphTargetSequence, fps, noLoop) {
			var numMorphTargets = morphTargetSequence.length;
			var tracks = [];

			for (var i = 0; i < numMorphTargets; i++) {
				var times = [];
				var values = [];
				times.push((i + numMorphTargets - 1) % numMorphTargets, i, (i + 1) % numMorphTargets);
				values.push(0, 1, 0);
				var order = AnimationUtils.getKeyframeOrder(times);
				times = AnimationUtils.sortedArray(times, 1, order);
				values = AnimationUtils.sortedArray(values, 1, order); // if there is a key at the first frame, duplicate it as the
				// last frame as well for perfect loop.

				if (!noLoop && times[0] === 0) {
					times.push(numMorphTargets);
					values.push(values[0]);
				}

				tracks.push(new NumberKeyframeTrack('.morphTargetInfluences[' + morphTargetSequence[i].name + ']', times, values).scale(1.0 / fps));
			}

			return new this(name, -1, tracks);
		};

		AnimationClip.findByName = function findByName(objectOrClipArray, name) {
			var clipArray = objectOrClipArray;

			if (!Array.isArray(objectOrClipArray)) {
				var o = objectOrClipArray;
				clipArray = o.geometry && o.geometry.animations || o.animations;
			}

			for (var i = 0; i < clipArray.length; i++) {
				if (clipArray[i].name === name) {
					return clipArray[i];
				}
			}

			return null;
		};

		AnimationClip.CreateClipsFromMorphTargetSequences = function CreateClipsFromMorphTargetSequences(morphTargets, fps, noLoop) {
			var animationToMorphTargets = {}; // tested with https://regex101.com/ on trick sequences
			// such flamingo_flyA_003, flamingo_run1_003, crdeath0059

			var pattern = /^([\w-]*?)([\d]+)$/; // sort morph target names into animation groups based
			// patterns like Walk_001, Walk_002, Run_001, Run_002

			for (var i = 0, il = morphTargets.length; i < il; i++) {
				var morphTarget = morphTargets[i];
				var parts = morphTarget.name.match(pattern);

				if (parts && parts.length > 1) {
					var name = parts[1];
					var animationMorphTargets = animationToMorphTargets[name];

					if (!animationMorphTargets) {
						animationToMorphTargets[name] = animationMorphTargets = [];
					}

					animationMorphTargets.push(morphTarget);
				}
			}

			var clips = [];

			for (var _name in animationToMorphTargets) {
				clips.push(this.CreateFromMorphTargetSequence(_name, animationToMorphTargets[_name], fps, noLoop));
			}

			return clips;
		} // parse the animation.hierarchy format
		;

		AnimationClip.parseAnimation = function parseAnimation(animation, bones) {
			if (!animation) {
				console.error('THREE.AnimationClip: No animation in JSONLoader data.');
				return null;
			}

			var addNonemptyTrack = function addNonemptyTrack(trackType, trackName, animationKeys, propertyName, destTracks) {
				// only return track if there are actually keys.
				if (animationKeys.length !== 0) {
					var times = [];
					var values = [];
					AnimationUtils.flattenJSON(animationKeys, times, values, propertyName); // empty keys are filtered out, so check again

					if (times.length !== 0) {
						destTracks.push(new trackType(trackName, times, values));
					}
				}
			};

			var tracks = [];
			var clipName = animation.name || 'default';
			var fps = animation.fps || 30;
			var blendMode = animation.blendMode; // automatic length determination in AnimationClip.

			var duration = animation.length || -1;
			var hierarchyTracks = animation.hierarchy || [];

			for (var h = 0; h < hierarchyTracks.length; h++) {
				var animationKeys = hierarchyTracks[h].keys; // skip empty tracks

				if (!animationKeys || animationKeys.length === 0) continue; // process morph targets

				if (animationKeys[0].morphTargets) {
					// figure out all morph targets used in this track
					var morphTargetNames = {};
					var k = void 0;

					for (k = 0; k < animationKeys.length; k++) {
						if (animationKeys[k].morphTargets) {
							for (var m = 0; m < animationKeys[k].morphTargets.length; m++) {
								morphTargetNames[animationKeys[k].morphTargets[m]] = -1;
							}
						}
					} // create a track for each morph target with all zero
					// morphTargetInfluences except for the keys in which
					// the morphTarget is named.


					for (var morphTargetName in morphTargetNames) {
						var times = [];
						var values = [];

						for (var _m = 0; _m !== animationKeys[k].morphTargets.length; ++_m) {
							var animationKey = animationKeys[k];
							times.push(animationKey.time);
							values.push(animationKey.morphTarget === morphTargetName ? 1 : 0);
						}

						tracks.push(new NumberKeyframeTrack('.morphTargetInfluence[' + morphTargetName + ']', times, values));
					}

					duration = morphTargetNames.length * (fps || 1.0);
				} else {
					// ...assume skeletal animation
					var boneName = '.bones[' + bones[h].name + ']';
					addNonemptyTrack(VectorKeyframeTrack, boneName + '.position', animationKeys, 'pos', tracks);
					addNonemptyTrack(QuaternionKeyframeTrack, boneName + '.quaternion', animationKeys, 'rot', tracks);
					addNonemptyTrack(VectorKeyframeTrack, boneName + '.scale', animationKeys, 'scl', tracks);
				}
			}

			if (tracks.length === 0) {
				return null;
			}

			var clip = new this(clipName, duration, tracks, blendMode);
			return clip;
		};

		var _proto = AnimationClip.prototype;

		_proto.resetDuration = function resetDuration() {
			var tracks = this.tracks;
			var duration = 0;

			for (var i = 0, n = tracks.length; i !== n; ++i) {
				var track = this.tracks[i];
				duration = Math.max(duration, track.times[track.times.length - 1]);
			}

			this.duration = duration;
			return this;
		};

		_proto.trim = function trim() {
			for (var i = 0; i < this.tracks.length; i++) {
				this.tracks[i].trim(0, this.duration);
			}

			return this;
		};

		_proto.validate = function validate() {
			var valid = true;

			for (var i = 0; i < this.tracks.length; i++) {
				valid = valid && this.tracks[i].validate();
			}

			return valid;
		};

		_proto.optimize = function optimize() {
			for (var i = 0; i < this.tracks.length; i++) {
				this.tracks[i].optimize();
			}

			return this;
		};

		_proto.clone = function clone() {
			var tracks = [];

			for (var i = 0; i < this.tracks.length; i++) {
				tracks.push(this.tracks[i].clone());
			}

			return new this.constructor(this.name, this.duration, tracks, this.blendMode);
		};

		_proto.toJSON = function toJSON() {
			return this.constructor.toJSON(this);
		};

		return AnimationClip;
	}();

	function getTrackTypeForValueTypeName(typeName) {
		switch (typeName.toLowerCase()) {
			case 'scalar':
			case 'double':
			case 'float':
			case 'number':
			case 'integer':
				return NumberKeyframeTrack;

			case 'vector':
			case 'vector2':
			case 'vector3':
			case 'vector4':
				return VectorKeyframeTrack;

			case 'color':
				return ColorKeyframeTrack;

			case 'quaternion':
				return QuaternionKeyframeTrack;

			case 'bool':
			case 'boolean':
				return BooleanKeyframeTrack;

			case 'string':
				return StringKeyframeTrack;
		}

		throw new Error('THREE.KeyframeTrack: Unsupported typeName: ' + typeName);
	}

	function parseKeyframeTrack(json) {
		if (json.type === undefined) {
			throw new Error('THREE.KeyframeTrack: track type undefined, can not parse');
		}

		var trackType = getTrackTypeForValueTypeName(json.type);

		if (json.times === undefined) {
			var times = [],
					values = [];
			AnimationUtils.flattenJSON(json.keys, times, values, 'value');
			json.times = times;
			json.values = values;
		} // derived classes can define a static parse method


		if (trackType.parse !== undefined) {
			return trackType.parse(json);
		} else {
			// by default, we assume a constructor compatible with the base
			return new trackType(json.name, json.times, json.values, json.interpolation);
		}
	}

	var Cache = {
		enabled: false,
		files: {},
		add: function add(key, file) {
			if (this.enabled === false) return; // console.log( 'THREE.Cache', 'Adding key:', key );

			this.files[key] = file;
		},
		get: function get(key) {
			if (this.enabled === false) return; // console.log( 'THREE.Cache', 'Checking key:', key );

			return this.files[key];
		},
		remove: function remove(key) {
			delete this.files[key];
		},
		clear: function clear() {
			this.files = {};
		}
	};

	var LoadingManager = function LoadingManager(onLoad, onProgress, onError) {
		var scope = this;
		var isLoading = false;
		var itemsLoaded = 0;
		var itemsTotal = 0;
		var urlModifier = undefined;
		var handlers = []; // Refer to #5689 for the reason why we don't set .onStart
		// in the constructor

		this.onStart = undefined;
		this.onLoad = onLoad;
		this.onProgress = onProgress;
		this.onError = onError;

		this.itemStart = function (url) {
			itemsTotal++;

			if (isLoading === false) {
				if (scope.onStart !== undefined) {
					scope.onStart(url, itemsLoaded, itemsTotal);
				}
			}

			isLoading = true;
		};

		this.itemEnd = function (url) {
			itemsLoaded++;

			if (scope.onProgress !== undefined) {
				scope.onProgress(url, itemsLoaded, itemsTotal);
			}

			if (itemsLoaded === itemsTotal) {
				isLoading = false;

				if (scope.onLoad !== undefined) {
					scope.onLoad();
				}
			}
		};

		this.itemError = function (url) {
			if (scope.onError !== undefined) {
				scope.onError(url);
			}
		};

		this.resolveURL = function (url) {
			if (urlModifier) {
				return urlModifier(url);
			}

			return url;
		};

		this.setURLModifier = function (transform) {
			urlModifier = transform;
			return this;
		};

		this.addHandler = function (regex, loader) {
			handlers.push(regex, loader);
			return this;
		};

		this.removeHandler = function (regex) {
			var index = handlers.indexOf(regex);

			if (index !== -1) {
				handlers.splice(index, 2);
			}

			return this;
		};

		this.getHandler = function (file) {
			for (var i = 0, l = handlers.length; i < l; i += 2) {
				var regex = handlers[i];
				var loader = handlers[i + 1];
				if (regex.global) regex.lastIndex = 0; // see #17920

				if (regex.test(file)) {
					return loader;
				}
			}

			return null;
		};
	};

	var DefaultLoadingManager = new LoadingManager();

	var Loader = /*#__PURE__*/function () {
		function Loader(manager) {
			this.manager = manager !== undefined ? manager : DefaultLoadingManager;
			this.crossOrigin = 'anonymous';
			this.withCredentials = false;
			this.path = '';
			this.resourcePath = '';
			this.requestHeader = {};
		}

		var _proto = Loader.prototype;

		_proto.load = function load()
		/* url, onLoad, onProgress, onError */
		{};

		_proto.loadAsync = function loadAsync(url, onProgress) {
			var scope = this;
			return new Promise(function (resolve, reject) {
				scope.load(url, resolve, onProgress, reject);
			});
		};

		_proto.parse = function parse()
		/* data */
		{};

		_proto.setCrossOrigin = function setCrossOrigin(crossOrigin) {
			this.crossOrigin = crossOrigin;
			return this;
		};

		_proto.setWithCredentials = function setWithCredentials(value) {
			this.withCredentials = value;
			return this;
		};

		_proto.setPath = function setPath(path) {
			this.path = path;
			return this;
		};

		_proto.setResourcePath = function setResourcePath(resourcePath) {
			this.resourcePath = resourcePath;
			return this;
		};

		_proto.setRequestHeader = function setRequestHeader(requestHeader) {
			this.requestHeader = requestHeader;
			return this;
		};

		return Loader;
	}();

	var loading = {};

	var FileLoader = /*#__PURE__*/function (_Loader) {
		_inheritsLoose(FileLoader, _Loader);

		function FileLoader(manager) {
			return _Loader.call(this, manager) || this;
		}

		var _proto = FileLoader.prototype;

		_proto.load = function load(url, onLoad, onProgress, onError) {
			if (url === undefined) url = '';
			if (this.path !== undefined) url = this.path + url;
			url = this.manager.resolveURL(url);
			var scope = this;
			var cached = Cache.get(url);

			if (cached !== undefined) {
				scope.manager.itemStart(url);
				setTimeout(function () {
					if (onLoad) onLoad(cached);
					scope.manager.itemEnd(url);
				}, 0);
				return cached;
			} // Check if request is duplicate


			if (loading[url] !== undefined) {
				loading[url].push({
					onLoad: onLoad,
					onProgress: onProgress,
					onError: onError
				});
				return;
			} // Check for data: URI


			var dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/;
			var dataUriRegexResult = url.match(dataUriRegex);
			var request; // Safari can not handle Data URIs through XMLHttpRequest so process manually

			if (dataUriRegexResult) {
				var mimeType = dataUriRegexResult[1];
				var isBase64 = !!dataUriRegexResult[2];
				var data = dataUriRegexResult[3];
				data = decodeURIComponent(data);
				if (isBase64) data = atob(data);

				try {
					var response;
					var responseType = (this.responseType || '').toLowerCase();

					switch (responseType) {
						case 'arraybuffer':
						case 'blob':
							var view = new Uint8Array(data.length);

							for (var i = 0; i < data.length; i++) {
								view[i] = data.charCodeAt(i);
							}

							if (responseType === 'blob') {
								response = new Blob([view.buffer], {
									type: mimeType
								});
							} else {
								response = view.buffer;
							}

							break;

						case 'document':
							var parser = new DOMParser();
							response = parser.parseFromString(data, mimeType);
							break;

						case 'json':
							response = JSON.parse(data);
							break;

						default:
							// 'text' or other
							response = data;
							break;
					} // Wait for next browser tick like standard XMLHttpRequest event dispatching does


					setTimeout(function () {
						if (onLoad) onLoad(response);
						scope.manager.itemEnd(url);
					}, 0);
				} catch (error) {
					// Wait for next browser tick like standard XMLHttpRequest event dispatching does
					setTimeout(function () {
						if (onError) onError(error);
						scope.manager.itemError(url);
						scope.manager.itemEnd(url);
					}, 0);
				}
			} else {
				// Initialise array for duplicate requests
				loading[url] = [];
				loading[url].push({
					onLoad: onLoad,
					onProgress: onProgress,
					onError: onError
				});
				request = new XMLHttpRequest();
				request.open('GET', url, true);
				request.addEventListener('load', function (event) {
					var response = this.response;
					var callbacks = loading[url];
					delete loading[url];

					if (this.status === 200 || this.status === 0) {
						// Some browsers return HTTP Status 0 when using non-http protocol
						// e.g. 'file://' or 'data://'. Handle as success.
						if (this.status === 0) console.warn('THREE.FileLoader: HTTP Status 0 received.'); // Add to cache only on HTTP success, so that we do not cache
						// error response bodies as proper responses to requests.

						Cache.add(url, response);

						for (var _i = 0, il = callbacks.length; _i < il; _i++) {
							var callback = callbacks[_i];
							if (callback.onLoad) callback.onLoad(response);
						}

						scope.manager.itemEnd(url);
					} else {
						for (var _i2 = 0, _il = callbacks.length; _i2 < _il; _i2++) {
							var _callback = callbacks[_i2];
							if (_callback.onError) _callback.onError(event);
						}

						scope.manager.itemError(url);
						scope.manager.itemEnd(url);
					}
				}, false);
				request.addEventListener('progress', function (event) {
					var callbacks = loading[url];

					for (var _i3 = 0, il = callbacks.length; _i3 < il; _i3++) {
						var callback = callbacks[_i3];
						if (callback.onProgress) callback.onProgress(event);
					}
				}, false);
				request.addEventListener('error', function (event) {
					var callbacks = loading[url];
					delete loading[url];

					for (var _i4 = 0, il = callbacks.length; _i4 < il; _i4++) {
						var callback = callbacks[_i4];
						if (callback.onError) callback.onError(event);
					}

					scope.manager.itemError(url);
					scope.manager.itemEnd(url);
				}, false);
				request.addEventListener('abort', function (event) {
					var callbacks = loading[url];
					delete loading[url];

					for (var _i5 = 0, il = callbacks.length; _i5 < il; _i5++) {
						var callback = callbacks[_i5];
						if (callback.onError) callback.onError(event);
					}

					scope.manager.itemError(url);
					scope.manager.itemEnd(url);
				}, false);
				if (this.responseType !== undefined) request.responseType = this.responseType;
				if (this.withCredentials !== undefined) request.withCredentials = this.withCredentials;
				if (request.overrideMimeType) request.overrideMimeType(this.mimeType !== undefined ? this.mimeType : 'text/plain');

				for (var header in this.requestHeader) {
					request.setRequestHeader(header, this.requestHeader[header]);
				}

				request.send(null);
			}

			scope.manager.itemStart(url);
			return request;
		};

		_proto.setResponseType = function setResponseType(value) {
			this.responseType = value;
			return this;
		};

		_proto.setMimeType = function setMimeType(value) {
			this.mimeType = value;
			return this;
		};

		return FileLoader;
	}(Loader);

	var AnimationLoader = /*#__PURE__*/function (_Loader) {
		_inheritsLoose(AnimationLoader, _Loader);

		function AnimationLoader(manager) {
			return _Loader.call(this, manager) || this;
		}

		var _proto = AnimationLoader.prototype;

		_proto.load = function load(url, onLoad, onProgress, onError) {
			var scope = this;
			var loader = new FileLoader(this.manager);
			loader.setPath(this.path);
			loader.setRequestHeader(this.requestHeader);
			loader.setWithCredentials(this.withCredentials);
			loader.load(url, function (text) {
				try {
					onLoad(scope.parse(JSON.parse(text)));
				} catch (e) {
					if (onError) {
						onError(e);
					} else {
						console.error(e);
					}

					scope.manager.itemError(url);
				}
			}, onProgress, onError);
		};

		_proto.parse = function parse(json) {
			var animations = [];

			for (var i = 0; i < json.length; i++) {
				var clip = AnimationClip.parse(json[i]);
				animations.push(clip);
			}

			return animations;
		};

		return AnimationLoader;
	}(Loader);

	/**
	 * Abstract Base class to block based textures loader (dds, pvr, ...)
	 *
	 * Sub classes have to implement the parse() method which will be used in load().
	 */

	var CompressedTextureLoader = /*#__PURE__*/function (_Loader) {
		_inheritsLoose(CompressedTextureLoader, _Loader);

		function CompressedTextureLoader(manager) {
			return _Loader.call(this, manager) || this;
		}

		var _proto = CompressedTextureLoader.prototype;

		_proto.load = function load(url, onLoad, onProgress, onError) {
			var scope = this;
			var images = [];
			var texture = new CompressedTexture();
			var loader = new FileLoader(this.manager);
			loader.setPath(this.path);
			loader.setResponseType('arraybuffer');
			loader.setRequestHeader(this.requestHeader);
			loader.setWithCredentials(scope.withCredentials);
			var loaded = 0;

			function loadTexture(i) {
				loader.load(url[i], function (buffer) {
					var texDatas = scope.parse(buffer, true);
					images[i] = {
						width: texDatas.width,
						height: texDatas.height,
						format: texDatas.format,
						mipmaps: texDatas.mipmaps
					};
					loaded += 1;

					if (loaded === 6) {
						if (texDatas.mipmapCount === 1) texture.minFilter = LinearFilter;
						texture.image = images;
						texture.format = texDatas.format;
						texture.needsUpdate = true;
						if (onLoad) onLoad(texture);
					}
				}, onProgress, onError);
			}

			if (Array.isArray(url)) {
				for (var i = 0, il = url.length; i < il; ++i) {
					loadTexture(i);
				}
			} else {
				// compressed cubemap texture stored in a single DDS file
				loader.load(url, function (buffer) {
					var texDatas = scope.parse(buffer, true);

					if (texDatas.isCubemap) {
						var faces = texDatas.mipmaps.length / texDatas.mipmapCount;

						for (var f = 0; f < faces; f++) {
							images[f] = {
								mipmaps: []
							};

							for (var _i = 0; _i < texDatas.mipmapCount; _i++) {
								images[f].mipmaps.push(texDatas.mipmaps[f * texDatas.mipmapCount + _i]);
								images[f].format = texDatas.format;
								images[f].width = texDatas.width;
								images[f].height = texDatas.height;
							}
						}

						texture.image = images;
					} else {
						texture.image.width = texDatas.width;
						texture.image.height = texDatas.height;
						texture.mipmaps = texDatas.mipmaps;
					}

					if (texDatas.mipmapCount === 1) {
						texture.minFilter = LinearFilter;
					}

					texture.format = texDatas.format;
					texture.needsUpdate = true;
					if (onLoad) onLoad(texture);
				}, onProgress, onError);
			}

			return texture;
		};

		return CompressedTextureLoader;
	}(Loader);

	var ImageLoader = /*#__PURE__*/function (_Loader) {
		_inheritsLoose(ImageLoader, _Loader);

		function ImageLoader(manager) {
			return _Loader.call(this, manager) || this;
		}

		var _proto = ImageLoader.prototype;

		_proto.load = function load(url, onLoad, onProgress, onError) {
			if (this.path !== undefined) url = this.path + url;
			url = this.manager.resolveURL(url);
			var scope = this;
			var cached = Cache.get(url);

			if (cached !== undefined) {
				scope.manager.itemStart(url);
				setTimeout(function () {
					if (onLoad) onLoad(cached);
					scope.manager.itemEnd(url);
				}, 0);
				return cached;
			}

			var image = createElementNS('img');

			function onImageLoad() {
				image.removeEventListener('load', onImageLoad, false);
				image.removeEventListener('error', onImageError, false);
				Cache.add(url, this);
				if (onLoad) onLoad(this);
				scope.manager.itemEnd(url);
			}

			function onImageError(event) {
				image.removeEventListener('load', onImageLoad, false);
				image.removeEventListener('error', onImageError, false);
				if (onError) onError(event);
				scope.manager.itemError(url);
				scope.manager.itemEnd(url);
			}

			image.addEventListener('load', onImageLoad, false);
			image.addEventListener('error', onImageError, false);

			if (url.substr(0, 5) !== 'data:') {
				if (this.crossOrigin !== undefined) image.crossOrigin = this.crossOrigin;
			}

			scope.manager.itemStart(url);
			image.src = url;
			return image;
		};

		return ImageLoader;
	}(Loader);

	var CubeTextureLoader = /*#__PURE__*/function (_Loader) {
		_inheritsLoose(CubeTextureLoader, _Loader);

		function CubeTextureLoader(manager) {
			return _Loader.call(this, manager) || this;
		}

		var _proto = CubeTextureLoader.prototype;

		_proto.load = function load(urls, onLoad, onProgress, onError) {
			var texture = new CubeTexture();
			var loader = new ImageLoader(this.manager);
			loader.setCrossOrigin(this.crossOrigin);
			loader.setPath(this.path);
			var loaded = 0;

			function loadTexture(i) {
				loader.load(urls[i], function (image) {
					texture.images[i] = image;
					loaded++;

					if (loaded === 6) {
						texture.needsUpdate = true;
						if (onLoad) onLoad(texture);
					}
				}, undefined, onError);
			}

			for (var i = 0; i < urls.length; ++i) {
				loadTexture(i);
			}

			return texture;
		};

		return CubeTextureLoader;
	}(Loader);

	/**
	 * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)
	 *
	 * Sub classes have to implement the parse() method which will be used in load().
	 */

	var DataTextureLoader = /*#__PURE__*/function (_Loader) {
		_inheritsLoose(DataTextureLoader, _Loader);

		function DataTextureLoader(manager) {
			return _Loader.call(this, manager) || this;
		}

		var _proto = DataTextureLoader.prototype;

		_proto.load = function load(url, onLoad, onProgress, onError) {
			var scope = this;
			var texture = new DataTexture();
			var loader = new FileLoader(this.manager);
			loader.setResponseType('arraybuffer');
			loader.setRequestHeader(this.requestHeader);
			loader.setPath(this.path);
			loader.setWithCredentials(scope.withCredentials);
			loader.load(url, function (buffer) {
				var texData = scope.parse(buffer);
				if (!texData) return;

				if (texData.image !== undefined) {
					texture.image = texData.image;
				} else if (texData.data !== undefined) {
					texture.image.width = texData.width;
					texture.image.height = texData.height;
					texture.image.data = texData.data;
				}

				texture.wrapS = texData.wrapS !== undefined ? texData.wrapS : ClampToEdgeWrapping;
				texture.wrapT = texData.wrapT !== undefined ? texData.wrapT : ClampToEdgeWrapping;
				texture.magFilter = texData.magFilter !== undefined ? texData.magFilter : LinearFilter;
				texture.minFilter = texData.minFilter !== undefined ? texData.minFilter : LinearFilter;
				texture.anisotropy = texData.anisotropy !== undefined ? texData.anisotropy : 1;

				if (texData.encoding !== undefined) {
					texture.encoding = texData.encoding;
				}

				if (texData.flipY !== undefined) {
					texture.flipY = texData.flipY;
				}

				if (texData.format !== undefined) {
					texture.format = texData.format;
				}

				if (texData.type !== undefined) {
					texture.type = texData.type;
				}

				if (texData.mipmaps !== undefined) {
					texture.mipmaps = texData.mipmaps;
					texture.minFilter = LinearMipmapLinearFilter; // presumably...
				}

				if (texData.mipmapCount === 1) {
					texture.minFilter = LinearFilter;
				}

				if (texData.generateMipmaps !== undefined) {
					texture.generateMipmaps = texData.generateMipmaps;
				}

				texture.needsUpdate = true;
				if (onLoad) onLoad(texture, texData);
			}, onProgress, onError);
			return texture;
		};

		return DataTextureLoader;
	}(Loader);

	var TextureLoader = /*#__PURE__*/function (_Loader) {
		_inheritsLoose(TextureLoader, _Loader);

		function TextureLoader(manager) {
			return _Loader.call(this, manager) || this;
		}

		var _proto = TextureLoader.prototype;

		_proto.load = function load(url, onLoad, onProgress, onError) {
			var texture = new Texture();
			var loader = new ImageLoader(this.manager);
			loader.setCrossOrigin(this.crossOrigin);
			loader.setPath(this.path);
			loader.load(url, function (image) {
				texture.image = image;
				texture.needsUpdate = true;

				if (onLoad !== undefined) {
					onLoad(texture);
				}
			}, onProgress, onError);
			return texture;
		};

		return TextureLoader;
	}(Loader);

	var Light = /*#__PURE__*/function (_Object3D) {
		_inheritsLoose(Light, _Object3D);

		function Light(color, intensity) {
			var _this;

			if (intensity === void 0) {
				intensity = 1;
			}

			_this = _Object3D.call(this) || this;
			_this.type = 'Light';
			_this.color = new Color(color);
			_this.intensity = intensity;
			return _this;
		}

		var _proto = Light.prototype;

		_proto.dispose = function dispose() {// Empty here in base class; some subclasses override.
		};

		_proto.copy = function copy(source) {
			_Object3D.prototype.copy.call(this, source);

			this.color.copy(source.color);
			this.intensity = source.intensity;
			return this;
		};

		_proto.toJSON = function toJSON(meta) {
			var data = _Object3D.prototype.toJSON.call(this, meta);

			data.object.color = this.color.getHex();
			data.object.intensity = this.intensity;
			if (this.groundColor !== undefined) data.object.groundColor = this.groundColor.getHex();
			if (this.distance !== undefined) data.object.distance = this.distance;
			if (this.angle !== undefined) data.object.angle = this.angle;
			if (this.decay !== undefined) data.object.decay = this.decay;
			if (this.penumbra !== undefined) data.object.penumbra = this.penumbra;
			if (this.shadow !== undefined) data.object.shadow = this.shadow.toJSON();
			return data;
		};

		return Light;
	}(Object3D);

	Light.prototype.isLight = true;

	var HemisphereLight = /*#__PURE__*/function (_Light) {
		_inheritsLoose(HemisphereLight, _Light);

		function HemisphereLight(skyColor, groundColor, intensity) {
			var _this;

			_this = _Light.call(this, skyColor, intensity) || this;
			_this.type = 'HemisphereLight';

			_this.position.copy(Object3D.DefaultUp);

			_this.updateMatrix();

			_this.groundColor = new Color(groundColor);
			return _this;
		}

		var _proto = HemisphereLight.prototype;

		_proto.copy = function copy(source) {
			Light.prototype.copy.call(this, source);
			this.groundColor.copy(source.groundColor);
			return this;
		};

		return HemisphereLight;
	}(Light);

	HemisphereLight.prototype.isHemisphereLight = true;

	var _projScreenMatrix = /*@__PURE__*/new Matrix4();

	var _lightPositionWorld = /*@__PURE__*/new Vector3();

	var _lookTarget = /*@__PURE__*/new Vector3();

	var LightShadow = /*#__PURE__*/function () {
		function LightShadow(camera) {
			this.camera = camera;
			this.bias = 0;
			this.normalBias = 0;
			this.radius = 1;
			this.blurSamples = 8;
			this.mapSize = new Vector2(512, 512);
			this.map = null;
			this.mapPass = null;
			this.matrix = new Matrix4();
			this.autoUpdate = true;
			this.needsUpdate = false;
			this._frustum = new Frustum();
			this._frameExtents = new Vector2(1, 1);
			this._viewportCount = 1;
			this._viewports = [new Vector4(0, 0, 1, 1)];
		}

		var _proto = LightShadow.prototype;

		_proto.getViewportCount = function getViewportCount() {
			return this._viewportCount;
		};

		_proto.getFrustum = function getFrustum() {
			return this._frustum;
		};

		_proto.updateMatrices = function updateMatrices(light) {
			var shadowCamera = this.camera;
			var shadowMatrix = this.matrix;

			_lightPositionWorld.setFromMatrixPosition(light.matrixWorld);

			shadowCamera.position.copy(_lightPositionWorld);

			_lookTarget.setFromMatrixPosition(light.target.matrixWorld);

			shadowCamera.lookAt(_lookTarget);
			shadowCamera.updateMatrixWorld();

			_projScreenMatrix.multiplyMatrices(shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse);

			this._frustum.setFromProjectionMatrix(_projScreenMatrix);

			shadowMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);
			shadowMatrix.multiply(shadowCamera.projectionMatrix);
			shadowMatrix.multiply(shadowCamera.matrixWorldInverse);
		};

		_proto.getViewport = function getViewport(viewportIndex) {
			return this._viewports[viewportIndex];
		};

		_proto.getFrameExtents = function getFrameExtents() {
			return this._frameExtents;
		};

		_proto.dispose = function dispose() {
			if (this.map) {
				this.map.dispose();
			}

			if (this.mapPass) {
				this.mapPass.dispose();
			}
		};

		_proto.copy = function copy(source) {
			this.camera = source.camera.clone();
			this.bias = source.bias;
			this.radius = source.radius;
			this.mapSize.copy(source.mapSize);
			return this;
		};

		_proto.clone = function clone() {
			return new this.constructor().copy(this);
		};

		_proto.toJSON = function toJSON() {
			var object = {};
			if (this.bias !== 0) object.bias = this.bias;
			if (this.normalBias !== 0) object.normalBias = this.normalBias;
			if (this.radius !== 1) object.radius = this.radius;
			if (this.mapSize.x !== 512 || this.mapSize.y !== 512) object.mapSize = this.mapSize.toArray();
			object.camera = this.camera.toJSON(false).object;
			delete object.camera.matrix;
			return object;
		};

		return LightShadow;
	}();

	var SpotLightShadow = /*#__PURE__*/function (_LightShadow) {
		_inheritsLoose(SpotLightShadow, _LightShadow);

		function SpotLightShadow() {
			var _this;

			_this = _LightShadow.call(this, new PerspectiveCamera(50, 1, 0.5, 500)) || this;
			_this.focus = 1;
			return _this;
		}

		var _proto = SpotLightShadow.prototype;

		_proto.updateMatrices = function updateMatrices(light) {
			var camera = this.camera;
			var fov = RAD2DEG * 2 * light.angle * this.focus;
			var aspect = this.mapSize.width / this.mapSize.height;
			var far = light.distance || camera.far;

			if (fov !== camera.fov || aspect !== camera.aspect || far !== camera.far) {
				camera.fov = fov;
				camera.aspect = aspect;
				camera.far = far;
				camera.updateProjectionMatrix();
			}

			_LightShadow.prototype.updateMatrices.call(this, light);
		};

		_proto.copy = function copy(source) {
			_LightShadow.prototype.copy.call(this, source);

			this.focus = source.focus;
			return this;
		};

		return SpotLightShadow;
	}(LightShadow);

	SpotLightShadow.prototype.isSpotLightShadow = true;

	var SpotLight = /*#__PURE__*/function (_Light) {
		_inheritsLoose(SpotLight, _Light);

		function SpotLight(color, intensity, distance, angle, penumbra, decay) {
			var _this;

			if (distance === void 0) {
				distance = 0;
			}

			if (angle === void 0) {
				angle = Math.PI / 3;
			}

			if (penumbra === void 0) {
				penumbra = 0;
			}

			if (decay === void 0) {
				decay = 1;
			}

			_this = _Light.call(this, color, intensity) || this;
			_this.type = 'SpotLight';

			_this.position.copy(Object3D.DefaultUp);

			_this.updateMatrix();

			_this.target = new Object3D();
			_this.distance = distance;
			_this.angle = angle;
			_this.penumbra = penumbra;
			_this.decay = decay; // for physically correct lights, should be 2.

			_this.shadow = new SpotLightShadow();
			return _this;
		}

		var _proto = SpotLight.prototype;

		_proto.dispose = function dispose() {
			this.shadow.dispose();
		};

		_proto.copy = function copy(source) {
			_Light.prototype.copy.call(this, source);

			this.distance = source.distance;
			this.angle = source.angle;
			this.penumbra = source.penumbra;
			this.decay = source.decay;
			this.target = source.target.clone();
			this.shadow = source.shadow.clone();
			return this;
		};

		_createClass(SpotLight, [{
			key: "power",
			get: function get() {
				// compute the light's luminous power (in lumens) from its intensity (in candela)
				// by convention for a spotlight, luminous power (lm) = π * luminous intensity (cd)
				return this.intensity * Math.PI;
			},
			set: function set(power) {
				// set the light's intensity (in candela) from the desired luminous power (in lumens)
				this.intensity = power / Math.PI;
			}
		}]);

		return SpotLight;
	}(Light);

	SpotLight.prototype.isSpotLight = true;

	var _projScreenMatrix$1 = /*@__PURE__*/new Matrix4();

	var _lightPositionWorld$1 = /*@__PURE__*/new Vector3();

	var _lookTarget$1 = /*@__PURE__*/new Vector3();

	var PointLightShadow = /*#__PURE__*/function (_LightShadow) {
		_inheritsLoose(PointLightShadow, _LightShadow);

		function PointLightShadow() {
			var _this;

			_this = _LightShadow.call(this, new PerspectiveCamera(90, 1, 0.5, 500)) || this;
			_this._frameExtents = new Vector2(4, 2);
			_this._viewportCount = 6;
			_this._viewports = [// These viewports map a cube-map onto a 2D texture with the
			// following orientation:
			//
			//	xzXZ
			//	 y Y
			//
			// X - Positive x direction
			// x - Negative x direction
			// Y - Positive y direction
			// y - Negative y direction
			// Z - Positive z direction
			// z - Negative z direction
			// positive X
			new Vector4(2, 1, 1, 1), // negative X
			new Vector4(0, 1, 1, 1), // positive Z
			new Vector4(3, 1, 1, 1), // negative Z
			new Vector4(1, 1, 1, 1), // positive Y
			new Vector4(3, 0, 1, 1), // negative Y
			new Vector4(1, 0, 1, 1)];
			_this._cubeDirections = [new Vector3(1, 0, 0), new Vector3(-1, 0, 0), new Vector3(0, 0, 1), new Vector3(0, 0, -1), new Vector3(0, 1, 0), new Vector3(0, -1, 0)];
			_this._cubeUps = [new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 0, 1), new Vector3(0, 0, -1)];
			return _this;
		}

		var _proto = PointLightShadow.prototype;

		_proto.updateMatrices = function updateMatrices(light, viewportIndex) {
			if (viewportIndex === void 0) {
				viewportIndex = 0;
			}

			var camera = this.camera;
			var shadowMatrix = this.matrix;
			var far = light.distance || camera.far;

			if (far !== camera.far) {
				camera.far = far;
				camera.updateProjectionMatrix();
			}

			_lightPositionWorld$1.setFromMatrixPosition(light.matrixWorld);

			camera.position.copy(_lightPositionWorld$1);

			_lookTarget$1.copy(camera.position);

			_lookTarget$1.add(this._cubeDirections[viewportIndex]);

			camera.up.copy(this._cubeUps[viewportIndex]);
			camera.lookAt(_lookTarget$1);
			camera.updateMatrixWorld();
			shadowMatrix.makeTranslation(-_lightPositionWorld$1.x, -_lightPositionWorld$1.y, -_lightPositionWorld$1.z);

			_projScreenMatrix$1.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);

			this._frustum.setFromProjectionMatrix(_projScreenMatrix$1);
		};

		return PointLightShadow;
	}(LightShadow);

	PointLightShadow.prototype.isPointLightShadow = true;

	var PointLight = /*#__PURE__*/function (_Light) {
		_inheritsLoose(PointLight, _Light);

		function PointLight(color, intensity, distance, decay) {
			var _this;

			if (distance === void 0) {
				distance = 0;
			}

			if (decay === void 0) {
				decay = 1;
			}

			_this = _Light.call(this, color, intensity) || this;
			_this.type = 'PointLight';
			_this.distance = distance;
			_this.decay = decay; // for physically correct lights, should be 2.

			_this.shadow = new PointLightShadow();
			return _this;
		}

		var _proto = PointLight.prototype;

		_proto.dispose = function dispose() {
			this.shadow.dispose();
		};

		_proto.copy = function copy(source) {
			_Light.prototype.copy.call(this, source);

			this.distance = source.distance;
			this.decay = source.decay;
			this.shadow = source.shadow.clone();
			return this;
		};

		_createClass(PointLight, [{
			key: "power",
			get: function get() {
				// compute the light's luminous power (in lumens) from its intensity (in candela)
				// for an isotropic light source, luminous power (lm) = 4 π luminous intensity (cd)
				return this.intensity * 4 * Math.PI;
			},
			set: function set(power) {
				// set the light's intensity (in candela) from the desired luminous power (in lumens)
				this.intensity = power / (4 * Math.PI);
			}
		}]);

		return PointLight;
	}(Light);

	PointLight.prototype.isPointLight = true;

	var DirectionalLightShadow = /*#__PURE__*/function (_LightShadow) {
		_inheritsLoose(DirectionalLightShadow, _LightShadow);

		function DirectionalLightShadow() {
			return _LightShadow.call(this, new OrthographicCamera(-5, 5, 5, -5, 0.5, 500)) || this;
		}

		return DirectionalLightShadow;
	}(LightShadow);

	DirectionalLightShadow.prototype.isDirectionalLightShadow = true;

	var DirectionalLight = /*#__PURE__*/function (_Light) {
		_inheritsLoose(DirectionalLight, _Light);

		function DirectionalLight(color, intensity) {
			var _this;

			_this = _Light.call(this, color, intensity) || this;
			_this.type = 'DirectionalLight';

			_this.position.copy(Object3D.DefaultUp);

			_this.updateMatrix();

			_this.target = new Object3D();
			_this.shadow = new DirectionalLightShadow();
			return _this;
		}

		var _proto = DirectionalLight.prototype;

		_proto.dispose = function dispose() {
			this.shadow.dispose();
		};

		_proto.copy = function copy(source) {
			_Light.prototype.copy.call(this, source);

			this.target = source.target.clone();
			this.shadow = source.shadow.clone();
			return this;
		};

		return DirectionalLight;
	}(Light);

	DirectionalLight.prototype.isDirectionalLight = true;

	var AmbientLight = /*#__PURE__*/function (_Light) {
		_inheritsLoose(AmbientLight, _Light);

		function AmbientLight(color, intensity) {
			var _this;

			_this = _Light.call(this, color, intensity) || this;
			_this.type = 'AmbientLight';
			return _this;
		}

		return AmbientLight;
	}(Light);

	AmbientLight.prototype.isAmbientLight = true;

	var RectAreaLight = /*#__PURE__*/function (_Light) {
		_inheritsLoose(RectAreaLight, _Light);

		function RectAreaLight(color, intensity, width, height) {
			var _this;

			if (width === void 0) {
				width = 10;
			}

			if (height === void 0) {
				height = 10;
			}

			_this = _Light.call(this, color, intensity) || this;
			_this.type = 'RectAreaLight';
			_this.width = width;
			_this.height = height;
			return _this;
		}

		var _proto = RectAreaLight.prototype;

		_proto.copy = function copy(source) {
			_Light.prototype.copy.call(this, source);

			this.width = source.width;
			this.height = source.height;
			return this;
		};

		_proto.toJSON = function toJSON(meta) {
			var data = _Light.prototype.toJSON.call(this, meta);

			data.object.width = this.width;
			data.object.height = this.height;
			return data;
		};

		_createClass(RectAreaLight, [{
			key: "power",
			get: function get() {
				// compute the light's luminous power (in lumens) from its intensity (in nits)
				return this.intensity * this.width * this.height * Math.PI;
			},
			set: function set(power) {
				// set the light's intensity (in nits) from the desired luminous power (in lumens)
				this.intensity = power / (this.width * this.height * Math.PI);
			}
		}]);

		return RectAreaLight;
	}(Light);

	RectAreaLight.prototype.isRectAreaLight = true;

	/**
	 * Primary reference:
	 *	 https://graphics.stanford.edu/papers/envmap/envmap.pdf
	 *
	 * Secondary reference:
	 *	 https://www.ppsloan.org/publications/StupidSH36.pdf
	 */
	// 3-band SH defined by 9 coefficients

	var SphericalHarmonics3 = /*#__PURE__*/function () {
		function SphericalHarmonics3() {
			this.coefficients = [];

			for (var i = 0; i < 9; i++) {
				this.coefficients.push(new Vector3());
			}
		}

		var _proto = SphericalHarmonics3.prototype;

		_proto.set = function set(coefficients) {
			for (var i = 0; i < 9; i++) {
				this.coefficients[i].copy(coefficients[i]);
			}

			return this;
		};

		_proto.zero = function zero() {
			for (var i = 0; i < 9; i++) {
				this.coefficients[i].set(0, 0, 0);
			}

			return this;
		} // get the radiance in the direction of the normal
		// target is a Vector3
		;

		_proto.getAt = function getAt(normal, target) {
			// normal is assumed to be unit length
			var x = normal.x,
					y = normal.y,
					z = normal.z;
			var coeff = this.coefficients; // band 0

			target.copy(coeff[0]).multiplyScalar(0.282095); // band 1

			target.addScaledVector(coeff[1], 0.488603 * y);
			target.addScaledVector(coeff[2], 0.488603 * z);
			target.addScaledVector(coeff[3], 0.488603 * x); // band 2

			target.addScaledVector(coeff[4], 1.092548 * (x * y));
			target.addScaledVector(coeff[5], 1.092548 * (y * z));
			target.addScaledVector(coeff[6], 0.315392 * (3.0 * z * z - 1.0));
			target.addScaledVector(coeff[7], 1.092548 * (x * z));
			target.addScaledVector(coeff[8], 0.546274 * (x * x - y * y));
			return target;
		} // get the irradiance (radiance convolved with cosine lobe) in the direction of the normal
		// target is a Vector3
		// https://graphics.stanford.edu/papers/envmap/envmap.pdf
		;

		_proto.getIrradianceAt = function getIrradianceAt(normal, target) {
			// normal is assumed to be unit length
			var x = normal.x,
					y = normal.y,
					z = normal.z;
			var coeff = this.coefficients; // band 0

			target.copy(coeff[0]).multiplyScalar(0.886227); // π * 0.282095
			// band 1

			target.addScaledVector(coeff[1], 2.0 * 0.511664 * y); // ( 2 * π / 3 ) * 0.488603

			target.addScaledVector(coeff[2], 2.0 * 0.511664 * z);
			target.addScaledVector(coeff[3], 2.0 * 0.511664 * x); // band 2

			target.addScaledVector(coeff[4], 2.0 * 0.429043 * x * y); // ( π / 4 ) * 1.092548

			target.addScaledVector(coeff[5], 2.0 * 0.429043 * y * z);
			target.addScaledVector(coeff[6], 0.743125 * z * z - 0.247708); // ( π / 4 ) * 0.315392 * 3

			target.addScaledVector(coeff[7], 2.0 * 0.429043 * x * z);
			target.addScaledVector(coeff[8], 0.429043 * (x * x - y * y)); // ( π / 4 ) * 0.546274

			return target;
		};

		_proto.add = function add(sh) {
			for (var i = 0; i < 9; i++) {
				this.coefficients[i].add(sh.coefficients[i]);
			}

			return this;
		};

		_proto.addScaledSH = function addScaledSH(sh, s) {
			for (var i = 0; i < 9; i++) {
				this.coefficients[i].addScaledVector(sh.coefficients[i], s);
			}

			return this;
		};

		_proto.scale = function scale(s) {
			for (var i = 0; i < 9; i++) {
				this.coefficients[i].multiplyScalar(s);
			}

			return this;
		};

		_proto.lerp = function lerp(sh, alpha) {
			for (var i = 0; i < 9; i++) {
				this.coefficients[i].lerp(sh.coefficients[i], alpha);
			}

			return this;
		};

		_proto.equals = function equals(sh) {
			for (var i = 0; i < 9; i++) {
				if (!this.coefficients[i].equals(sh.coefficients[i])) {
					return false;
				}
			}

			return true;
		};

		_proto.copy = function copy(sh) {
			return this.set(sh.coefficients);
		};

		_proto.clone = function clone() {
			return new this.constructor().copy(this);
		};

		_proto.fromArray = function fromArray(array, offset) {
			if (offset === void 0) {
				offset = 0;
			}

			var coefficients = this.coefficients;

			for (var i = 0; i < 9; i++) {
				coefficients[i].fromArray(array, offset + i * 3);
			}

			return this;
		};

		_proto.toArray = function toArray(array, offset) {
			if (array === void 0) {
				array = [];
			}

			if (offset === void 0) {
				offset = 0;
			}

			var coefficients = this.coefficients;

			for (var i = 0; i < 9; i++) {
				coefficients[i].toArray(array, offset + i * 3);
			}

			return array;
		} // evaluate the basis functions
		// shBasis is an Array[ 9 ]
		;

		SphericalHarmonics3.getBasisAt = function getBasisAt(normal, shBasis) {
			// normal is assumed to be unit length
			var x = normal.x,
					y = normal.y,
					z = normal.z; // band 0

			shBasis[0] = 0.282095; // band 1

			shBasis[1] = 0.488603 * y;
			shBasis[2] = 0.488603 * z;
			shBasis[3] = 0.488603 * x; // band 2

			shBasis[4] = 1.092548 * x * y;
			shBasis[5] = 1.092548 * y * z;
			shBasis[6] = 0.315392 * (3 * z * z - 1);
			shBasis[7] = 1.092548 * x * z;
			shBasis[8] = 0.546274 * (x * x - y * y);
		};

		return SphericalHarmonics3;
	}();

	SphericalHarmonics3.prototype.isSphericalHarmonics3 = true;

	var LightProbe = /*#__PURE__*/function (_Light) {
		_inheritsLoose(LightProbe, _Light);

		function LightProbe(sh, intensity) {
			var _this;

			if (sh === void 0) {
				sh = new SphericalHarmonics3();
			}

			if (intensity === void 0) {
				intensity = 1;
			}

			_this = _Light.call(this, undefined, intensity) || this;
			_this.sh = sh;
			return _this;
		}

		var _proto = LightProbe.prototype;

		_proto.copy = function copy(source) {
			_Light.prototype.copy.call(this, source);

			this.sh.copy(source.sh);
			return this;
		};

		_proto.fromJSON = function fromJSON(json) {
			this.intensity = json.intensity; // TODO: Move this bit to Light.fromJSON();

			this.sh.fromArray(json.sh);
			return this;
		};

		_proto.toJSON = function toJSON(meta) {
			var data = _Light.prototype.toJSON.call(this, meta);

			data.object.sh = this.sh.toArray();
			return data;
		};

		return LightProbe;
	}(Light);

	LightProbe.prototype.isLightProbe = true;

	var MaterialLoader = /*#__PURE__*/function (_Loader) {
		_inheritsLoose(MaterialLoader, _Loader);

		function MaterialLoader(manager) {
			var _this;

			_this = _Loader.call(this, manager) || this;
			_this.textures = {};
			return _this;
		}

		var _proto = MaterialLoader.prototype;

		_proto.load = function load(url, onLoad, onProgress, onError) {
			var scope = this;
			var loader = new FileLoader(scope.manager);
			loader.setPath(scope.path);
			loader.setRequestHeader(scope.requestHeader);
			loader.setWithCredentials(scope.withCredentials);
			loader.load(url, function (text) {
				try {
					onLoad(scope.parse(JSON.parse(text)));
				} catch (e) {
					if (onError) {
						onError(e);
					} else {
						console.error(e);
					}

					scope.manager.itemError(url);
				}
			}, onProgress, onError);
		};

		_proto.parse = function parse(json) {
			var textures = this.textures;

			function getTexture(name) {
				if (textures[name] === undefined) {
					console.warn('THREE.MaterialLoader: Undefined texture', name);
				}

				return textures[name];
			}

			var material = new Materials[json.type]();
			if (json.uuid !== undefined) material.uuid = json.uuid;
			if (json.name !== undefined) material.name = json.name;
			if (json.color !== undefined && material.color !== undefined) material.color.setHex(json.color);
			if (json.roughness !== undefined) material.roughness = json.roughness;
			if (json.metalness !== undefined) material.metalness = json.metalness;
			if (json.sheen !== undefined) material.sheen = json.sheen;
			if (json.sheenTint !== undefined) material.sheenTint = new Color().setHex(json.sheenTint);
			if (json.sheenRoughness !== undefined) material.sheenRoughness = json.sheenRoughness;
			if (json.emissive !== undefined && material.emissive !== undefined) material.emissive.setHex(json.emissive);
			if (json.specular !== undefined && material.specular !== undefined) material.specular.setHex(json.specular);
			if (json.specularIntensity !== undefined) material.specularIntensity = json.specularIntensity;
			if (json.specularTint !== undefined && material.specularTint !== undefined) material.specularTint.setHex(json.specularTint);
			if (json.shininess !== undefined) material.shininess = json.shininess;
			if (json.clearcoat !== undefined) material.clearcoat = json.clearcoat;
			if (json.clearcoatRoughness !== undefined) material.clearcoatRoughness = json.clearcoatRoughness;
			if (json.transmission !== undefined) material.transmission = json.transmission;
			if (json.thickness !== undefined) material.thickness = json.thickness;
			if (json.attenuationDistance !== undefined) material.attenuationDistance = json.attenuationDistance;
			if (json.attenuationTint !== undefined && material.attenuationTint !== undefined) material.attenuationTint.setHex(json.attenuationTint);
			if (json.fog !== undefined) material.fog = json.fog;
			if (json.flatShading !== undefined) material.flatShading = json.flatShading;
			if (json.blending !== undefined) material.blending = json.blending;
			if (json.combine !== undefined) material.combine = json.combine;
			if (json.side !== undefined) material.side = json.side;
			if (json.shadowSide !== undefined) material.shadowSide = json.shadowSide;
			if (json.opacity !== undefined) material.opacity = json.opacity;
			if (json.format !== undefined) material.format = json.format;
			if (json.transparent !== undefined) material.transparent = json.transparent;
			if (json.alphaTest !== undefined) material.alphaTest = json.alphaTest;
			if (json.depthTest !== undefined) material.depthTest = json.depthTest;
			if (json.depthWrite !== undefined) material.depthWrite = json.depthWrite;
			if (json.colorWrite !== undefined) material.colorWrite = json.colorWrite;
			if (json.stencilWrite !== undefined) material.stencilWrite = json.stencilWrite;
			if (json.stencilWriteMask !== undefined) material.stencilWriteMask = json.stencilWriteMask;
			if (json.stencilFunc !== undefined) material.stencilFunc = json.stencilFunc;
			if (json.stencilRef !== undefined) material.stencilRef = json.stencilRef;
			if (json.stencilFuncMask !== undefined) material.stencilFuncMask = json.stencilFuncMask;
			if (json.stencilFail !== undefined) material.stencilFail = json.stencilFail;
			if (json.stencilZFail !== undefined) material.stencilZFail = json.stencilZFail;
			if (json.stencilZPass !== undefined) material.stencilZPass = json.stencilZPass;
			if (json.wireframe !== undefined) material.wireframe = json.wireframe;
			if (json.wireframeLinewidth !== undefined) material.wireframeLinewidth = json.wireframeLinewidth;
			if (json.wireframeLinecap !== undefined) material.wireframeLinecap = json.wireframeLinecap;
			if (json.wireframeLinejoin !== undefined) material.wireframeLinejoin = json.wireframeLinejoin;
			if (json.rotation !== undefined) material.rotation = json.rotation;
			if (json.linewidth !== 1) material.linewidth = json.linewidth;
			if (json.dashSize !== undefined) material.dashSize = json.dashSize;
			if (json.gapSize !== undefined) material.gapSize = json.gapSize;
			if (json.scale !== undefined) material.scale = json.scale;
			if (json.polygonOffset !== undefined) material.polygonOffset = json.polygonOffset;
			if (json.polygonOffsetFactor !== undefined) material.polygonOffsetFactor = json.polygonOffsetFactor;
			if (json.polygonOffsetUnits !== undefined) material.polygonOffsetUnits = json.polygonOffsetUnits;
			if (json.dithering !== undefined) material.dithering = json.dithering;
			if (json.alphaToCoverage !== undefined) material.alphaToCoverage = json.alphaToCoverage;
			if (json.premultipliedAlpha !== undefined) material.premultipliedAlpha = json.premultipliedAlpha;
			if (json.visible !== undefined) material.visible = json.visible;
			if (json.toneMapped !== undefined) material.toneMapped = json.toneMapped;
			if (json.userData !== undefined) material.userData = json.userData;

			if (json.vertexColors !== undefined) {
				if (typeof json.vertexColors === 'number') {
					material.vertexColors = json.vertexColors > 0 ? true : false;
				} else {
					material.vertexColors = json.vertexColors;
				}
			} // Shader Material


			if (json.uniforms !== undefined) {
				for (var name in json.uniforms) {
					var uniform = json.uniforms[name];
					material.uniforms[name] = {};

					switch (uniform.type) {
						case 't':
							material.uniforms[name].value = getTexture(uniform.value);
							break;

						case 'c':
							material.uniforms[name].value = new Color().setHex(uniform.value);
							break;

						case 'v2':
							material.uniforms[name].value = new Vector2().fromArray(uniform.value);
							break;

						case 'v3':
							material.uniforms[name].value = new Vector3().fromArray(uniform.value);
							break;

						case 'v4':
							material.uniforms[name].value = new Vector4().fromArray(uniform.value);
							break;

						case 'm3':
							material.uniforms[name].value = new Matrix3().fromArray(uniform.value);
							break;

						case 'm4':
							material.uniforms[name].value = new Matrix4().fromArray(uniform.value);
							break;

						default:
							material.uniforms[name].value = uniform.value;
					}
				}
			}

			if (json.defines !== undefined) material.defines = json.defines;
			if (json.vertexShader !== undefined) material.vertexShader = json.vertexShader;
			if (json.fragmentShader !== undefined) material.fragmentShader = json.fragmentShader;

			if (json.extensions !== undefined) {
				for (var key in json.extensions) {
					material.extensions[key] = json.extensions[key];
				}
			} // Deprecated


			if (json.shading !== undefined) material.flatShading = json.shading === 1; // THREE.FlatShading
			// for PointsMaterial

			if (json.size !== undefined) material.size = json.size;
			if (json.sizeAttenuation !== undefined) material.sizeAttenuation = json.sizeAttenuation; // maps

			if (json.map !== undefined) material.map = getTexture(json.map);
			if (json.matcap !== undefined) material.matcap = getTexture(json.matcap);
			if (json.alphaMap !== undefined) material.alphaMap = getTexture(json.alphaMap);
			if (json.bumpMap !== undefined) material.bumpMap = getTexture(json.bumpMap);
			if (json.bumpScale !== undefined) material.bumpScale = json.bumpScale;
			if (json.normalMap !== undefined) material.normalMap = getTexture(json.normalMap);
			if (json.normalMapType !== undefined) material.normalMapType = json.normalMapType;

			if (json.normalScale !== undefined) {
				var normalScale = json.normalScale;

				if (Array.isArray(normalScale) === false) {
					// Blender exporter used to export a scalar. See #7459
					normalScale = [normalScale, normalScale];
				}

				material.normalScale = new Vector2().fromArray(normalScale);
			}

			if (json.displacementMap !== undefined) material.displacementMap = getTexture(json.displacementMap);
			if (json.displacementScale !== undefined) material.displacementScale = json.displacementScale;
			if (json.displacementBias !== undefined) material.displacementBias = json.displacementBias;
			if (json.roughnessMap !== undefined) material.roughnessMap = getTexture(json.roughnessMap);
			if (json.metalnessMap !== undefined) material.metalnessMap = getTexture(json.metalnessMap);
			if (json.emissiveMap !== undefined) material.emissiveMap = getTexture(json.emissiveMap);
			if (json.emissiveIntensity !== undefined) material.emissiveIntensity = json.emissiveIntensity;
			if (json.specularMap !== undefined) material.specularMap = getTexture(json.specularMap);
			if (json.specularIntensityMap !== undefined) material.specularIntensityMap = getTexture(json.specularIntensityMap);
			if (json.specularTintMap !== undefined) material.specularTintMap = getTexture(json.specularTintMap);
			if (json.envMap !== undefined) material.envMap = getTexture(json.envMap);
			if (json.envMapIntensity !== undefined) material.envMapIntensity = json.envMapIntensity;
			if (json.reflectivity !== undefined) material.reflectivity = json.reflectivity;
			if (json.refractionRatio !== undefined) material.refractionRatio = json.refractionRatio;
			if (json.lightMap !== undefined) material.lightMap = getTexture(json.lightMap);
			if (json.lightMapIntensity !== undefined) material.lightMapIntensity = json.lightMapIntensity;
			if (json.aoMap !== undefined) material.aoMap = getTexture(json.aoMap);
			if (json.aoMapIntensity !== undefined) material.aoMapIntensity = json.aoMapIntensity;
			if (json.gradientMap !== undefined) material.gradientMap = getTexture(json.gradientMap);
			if (json.clearcoatMap !== undefined) material.clearcoatMap = getTexture(json.clearcoatMap);
			if (json.clearcoatRoughnessMap !== undefined) material.clearcoatRoughnessMap = getTexture(json.clearcoatRoughnessMap);
			if (json.clearcoatNormalMap !== undefined) material.clearcoatNormalMap = getTexture(json.clearcoatNormalMap);
			if (json.clearcoatNormalScale !== undefined) material.clearcoatNormalScale = new Vector2().fromArray(json.clearcoatNormalScale);
			if (json.transmissionMap !== undefined) material.transmissionMap = getTexture(json.transmissionMap);
			if (json.thicknessMap !== undefined) material.thicknessMap = getTexture(json.thicknessMap);
			return material;
		};

		_proto.setTextures = function setTextures(value) {
			this.textures = value;
			return this;
		};

		return MaterialLoader;
	}(Loader);

	var LoaderUtils = /*#__PURE__*/function () {
		function LoaderUtils() {}

		LoaderUtils.decodeText = function decodeText(array) {
			if (typeof TextDecoder !== 'undefined') {
				return new TextDecoder().decode(array);
			} // Avoid the String.fromCharCode.apply(null, array) shortcut, which
			// throws a "maximum call stack size exceeded" error for large arrays.


			var s = '';

			for (var i = 0, il = array.length; i < il; i++) {
				// Implicitly assumes little-endian.
				s += String.fromCharCode(array[i]);
			}

			try {
				// merges multi-byte utf-8 characters.
				return decodeURIComponent(escape(s));
			} catch (e) {
				// see #16358
				return s;
			}
		};

		LoaderUtils.extractUrlBase = function extractUrlBase(url) {
			var index = url.lastIndexOf('/');
			if (index === -1) return './';
			return url.substr(0, index + 1);
		};

		return LoaderUtils;
	}();

	var InstancedBufferGeometry = /*#__PURE__*/function (_BufferGeometry) {
		_inheritsLoose(InstancedBufferGeometry, _BufferGeometry);

		function InstancedBufferGeometry() {
			var _this;

			_this = _BufferGeometry.call(this) || this;
			_this.type = 'InstancedBufferGeometry';
			_this.instanceCount = Infinity;
			return _this;
		}

		var _proto = InstancedBufferGeometry.prototype;

		_proto.copy = function copy(source) {
			_BufferGeometry.prototype.copy.call(this, source);

			this.instanceCount = source.instanceCount;
			return this;
		};

		_proto.clone = function clone() {
			return new this.constructor().copy(this);
		};

		_proto.toJSON = function toJSON() {
			var data = _BufferGeometry.prototype.toJSON.call(this, this);

			data.instanceCount = this.instanceCount;
			data.isInstancedBufferGeometry = true;
			return data;
		};

		return InstancedBufferGeometry;
	}(BufferGeometry);

	InstancedBufferGeometry.prototype.isInstancedBufferGeometry = true;

	var BufferGeometryLoader = /*#__PURE__*/function (_Loader) {
		_inheritsLoose(BufferGeometryLoader, _Loader);

		function BufferGeometryLoader(manager) {
			return _Loader.call(this, manager) || this;
		}

		var _proto = BufferGeometryLoader.prototype;

		_proto.load = function load(url, onLoad, onProgress, onError) {
			var scope = this;
			var loader = new FileLoader(scope.manager);
			loader.setPath(scope.path);
			loader.setRequestHeader(scope.requestHeader);
			loader.setWithCredentials(scope.withCredentials);
			loader.load(url, function (text) {
				try {
					onLoad(scope.parse(JSON.parse(text)));
				} catch (e) {
					if (onError) {
						onError(e);
					} else {
						console.error(e);
					}

					scope.manager.itemError(url);
				}
			}, onProgress, onError);
		};

		_proto.parse = function parse(json) {
			var interleavedBufferMap = {};
			var arrayBufferMap = {};

			function getInterleavedBuffer(json, uuid) {
				if (interleavedBufferMap[uuid] !== undefined) return interleavedBufferMap[uuid];
				var interleavedBuffers = json.interleavedBuffers;
				var interleavedBuffer = interleavedBuffers[uuid];
				var buffer = getArrayBuffer(json, interleavedBuffer.buffer);
				var array = getTypedArray(interleavedBuffer.type, buffer);
				var ib = new InterleavedBuffer(array, interleavedBuffer.stride);
				ib.uuid = interleavedBuffer.uuid;
				interleavedBufferMap[uuid] = ib;
				return ib;
			}

			function getArrayBuffer(json, uuid) {
				if (arrayBufferMap[uuid] !== undefined) return arrayBufferMap[uuid];
				var arrayBuffers = json.arrayBuffers;
				var arrayBuffer = arrayBuffers[uuid];
				var ab = new Uint32Array(arrayBuffer).buffer;
				arrayBufferMap[uuid] = ab;
				return ab;
			}

			var geometry = json.isInstancedBufferGeometry ? new InstancedBufferGeometry() : new BufferGeometry();
			var index = json.data.index;

			if (index !== undefined) {
				var typedArray = getTypedArray(index.type, index.array);
				geometry.setIndex(new BufferAttribute(typedArray, 1));
			}

			var attributes = json.data.attributes;

			for (var key in attributes) {
				var attribute = attributes[key];
				var bufferAttribute = void 0;

				if (attribute.isInterleavedBufferAttribute) {
					var interleavedBuffer = getInterleavedBuffer(json.data, attribute.data);
					bufferAttribute = new InterleavedBufferAttribute(interleavedBuffer, attribute.itemSize, attribute.offset, attribute.normalized);
				} else {
					var _typedArray = getTypedArray(attribute.type, attribute.array);

					var bufferAttributeConstr = attribute.isInstancedBufferAttribute ? InstancedBufferAttribute : BufferAttribute;
					bufferAttribute = new bufferAttributeConstr(_typedArray, attribute.itemSize, attribute.normalized);
				}

				if (attribute.name !== undefined) bufferAttribute.name = attribute.name;
				if (attribute.usage !== undefined) bufferAttribute.setUsage(attribute.usage);

				if (attribute.updateRange !== undefined) {
					bufferAttribute.updateRange.offset = attribute.updateRange.offset;
					bufferAttribute.updateRange.count = attribute.updateRange.count;
				}

				geometry.setAttribute(key, bufferAttribute);
			}

			var morphAttributes = json.data.morphAttributes;

			if (morphAttributes) {
				for (var _key in morphAttributes) {
					var attributeArray = morphAttributes[_key];
					var array = [];

					for (var i = 0, il = attributeArray.length; i < il; i++) {
						var _attribute = attributeArray[i];

						var _bufferAttribute = void 0;

						if (_attribute.isInterleavedBufferAttribute) {
							var _interleavedBuffer = getInterleavedBuffer(json.data, _attribute.data);

							_bufferAttribute = new InterleavedBufferAttribute(_interleavedBuffer, _attribute.itemSize, _attribute.offset, _attribute.normalized);
						} else {
							var _typedArray2 = getTypedArray(_attribute.type, _attribute.array);

							_bufferAttribute = new BufferAttribute(_typedArray2, _attribute.itemSize, _attribute.normalized);
						}

						if (_attribute.name !== undefined) _bufferAttribute.name = _attribute.name;
						array.push(_bufferAttribute);
					}

					geometry.morphAttributes[_key] = array;
				}
			}

			var morphTargetsRelative = json.data.morphTargetsRelative;

			if (morphTargetsRelative) {
				geometry.morphTargetsRelative = true;
			}

			var groups = json.data.groups || json.data.drawcalls || json.data.offsets;

			if (groups !== undefined) {
				for (var _i = 0, n = groups.length; _i !== n; ++_i) {
					var group = groups[_i];
					geometry.addGroup(group.start, group.count, group.materialIndex);
				}
			}

			var boundingSphere = json.data.boundingSphere;

			if (boundingSphere !== undefined) {
				var center = new Vector3();

				if (boundingSphere.center !== undefined) {
					center.fromArray(boundingSphere.center);
				}

				geometry.boundingSphere = new Sphere(center, boundingSphere.radius);
			}

			if (json.name) geometry.name = json.name;
			if (json.userData) geometry.userData = json.userData;
			return geometry;
		};

		return BufferGeometryLoader;
	}(Loader);

	var ObjectLoader = /*#__PURE__*/function (_Loader) {
		_inheritsLoose(ObjectLoader, _Loader);

		function ObjectLoader(manager) {
			return _Loader.call(this, manager) || this;
		}

		var _proto = ObjectLoader.prototype;

		_proto.load = function load(url, onLoad, onProgress, onError) {
			var scope = this;
			var path = this.path === '' ? LoaderUtils.extractUrlBase(url) : this.path;
			this.resourcePath = this.resourcePath || path;
			var loader = new FileLoader(this.manager);
			loader.setPath(this.path);
			loader.setRequestHeader(this.requestHeader);
			loader.setWithCredentials(this.withCredentials);
			loader.load(url, function (text) {
				var json = null;

				try {
					json = JSON.parse(text);
				} catch (error) {
					if (onError !== undefined) onError(error);
					console.error('THREE:ObjectLoader: Can\'t parse ' + url + '.', error.message);
					return;
				}

				var metadata = json.metadata;

				if (metadata === undefined || metadata.type === undefined || metadata.type.toLowerCase() === 'geometry') {
					console.error('THREE.ObjectLoader: Can\'t load ' + url);
					return;
				}

				scope.parse(json, onLoad);
			}, onProgress, onError);
		};

		_proto.loadAsync = /*#__PURE__*/function () {
			var _loadAsync = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(url, onProgress) {
				var scope, path, loader, text, json, metadata;
				return regeneratorRuntime.wrap(function _callee$(_context) {
					while (1) {
						switch (_context.prev = _context.next) {
							case 0:
								scope = this;
								path = this.path === '' ? LoaderUtils.extractUrlBase(url) : this.path;
								this.resourcePath = this.resourcePath || path;
								loader = new FileLoader(this.manager);
								loader.setPath(this.path);
								loader.setRequestHeader(this.requestHeader);
								loader.setWithCredentials(this.withCredentials);
								_context.next = 9;
								return loader.loadAsync(url, onProgress);

							case 9:
								text = _context.sent;
								json = JSON.parse(text);
								metadata = json.metadata;

								if (!(metadata === undefined || metadata.type === undefined || metadata.type.toLowerCase() === 'geometry')) {
									_context.next = 14;
									break;
								}

								throw new Error('THREE.ObjectLoader: Can\'t load ' + url);

							case 14:
								_context.next = 16;
								return scope.parseAsync(json);

							case 16:
								return _context.abrupt("return", _context.sent);

							case 17:
							case "end":
								return _context.stop();
						}
					}
				}, _callee, this);
			}));

			function loadAsync(_x, _x2) {
				return _loadAsync.apply(this, arguments);
			}

			return loadAsync;
		}();

		_proto.parse = function parse(json, onLoad) {
			var animations = this.parseAnimations(json.animations);
			var shapes = this.parseShapes(json.shapes);
			var geometries = this.parseGeometries(json.geometries, shapes);
			var images = this.parseImages(json.images, function () {
				if (onLoad !== undefined) onLoad(object);
			});
			var textures = this.parseTextures(json.textures, images);
			var materials = this.parseMaterials(json.materials, textures);
			var object = this.parseObject(json.object, geometries, materials, textures, animations);
			var skeletons = this.parseSkeletons(json.skeletons, object);
			this.bindSkeletons(object, skeletons); //

			if (onLoad !== undefined) {
				var hasImages = false;

				for (var uuid in images) {
					if (images[uuid] instanceof HTMLImageElement) {
						hasImages = true;
						break;
					}
				}

				if (hasImages === false) onLoad(object);
			}

			return object;
		};

		_proto.parseAsync = /*#__PURE__*/function () {
			var _parseAsync = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(json) {
				var animations, shapes, geometries, images, textures, materials, object, skeletons;
				return regeneratorRuntime.wrap(function _callee2$(_context2) {
					while (1) {
						switch (_context2.prev = _context2.next) {
							case 0:
								animations = this.parseAnimations(json.animations);
								shapes = this.parseShapes(json.shapes);
								geometries = this.parseGeometries(json.geometries, shapes);
								_context2.next = 5;
								return this.parseImagesAsync(json.images);

							case 5:
								images = _context2.sent;
								textures = this.parseTextures(json.textures, images);
								materials = this.parseMaterials(json.materials, textures);
								object = this.parseObject(json.object, geometries, materials, textures, animations);
								skeletons = this.parseSkeletons(json.skeletons, object);
								this.bindSkeletons(object, skeletons);
								return _context2.abrupt("return", object);

							case 12:
							case "end":
								return _context2.stop();
						}
					}
				}, _callee2, this);
			}));

			function parseAsync(_x3) {
				return _parseAsync.apply(this, arguments);
			}

			return parseAsync;
		}();

		_proto.parseShapes = function parseShapes(json) {
			var shapes = {};

			if (json !== undefined) {
				for (var i = 0, l = json.length; i < l; i++) {
					var shape = new Shape().fromJSON(json[i]);
					shapes[shape.uuid] = shape;
				}
			}

			return shapes;
		};

		_proto.parseSkeletons = function parseSkeletons(json, object) {
			var skeletons = {};
			var bones = {}; // generate bone lookup table

			object.traverse(function (child) {
				if (child.isBone) bones[child.uuid] = child;
			}); // create skeletons

			if (json !== undefined) {
				for (var i = 0, l = json.length; i < l; i++) {
					var skeleton = new Skeleton().fromJSON(json[i], bones);
					skeletons[skeleton.uuid] = skeleton;
				}
			}

			return skeletons;
		};

		_proto.parseGeometries = function parseGeometries(json, shapes) {
			var geometries = {};

			if (json !== undefined) {
				var bufferGeometryLoader = new BufferGeometryLoader();

				for (var i = 0, l = json.length; i < l; i++) {
					var geometry = void 0;
					var data = json[i];

					switch (data.type) {
						case 'BufferGeometry':
						case 'InstancedBufferGeometry':
							geometry = bufferGeometryLoader.parse(data);
							break;

						case 'Geometry':
							console.error('THREE.ObjectLoader: The legacy Geometry type is no longer supported.');
							break;

						default:
							if (data.type in Geometries) {
								geometry = Geometries[data.type].fromJSON(data, shapes);
							} else {
								console.warn("THREE.ObjectLoader: Unsupported geometry type \"" + data.type + "\"");
							}

					}

					geometry.uuid = data.uuid;
					if (data.name !== undefined) geometry.name = data.name;
					if (geometry.isBufferGeometry === true && data.userData !== undefined) geometry.userData = data.userData;
					geometries[data.uuid] = geometry;
				}
			}

			return geometries;
		};

		_proto.parseMaterials = function parseMaterials(json, textures) {
			var cache = {}; // MultiMaterial

			var materials = {};

			if (json !== undefined) {
				var loader = new MaterialLoader();
				loader.setTextures(textures);

				for (var i = 0, l = json.length; i < l; i++) {
					var data = json[i];

					if (data.type === 'MultiMaterial') {
						// Deprecated
						var array = [];

						for (var j = 0; j < data.materials.length; j++) {
							var material = data.materials[j];

							if (cache[material.uuid] === undefined) {
								cache[material.uuid] = loader.parse(material);
							}

							array.push(cache[material.uuid]);
						}

						materials[data.uuid] = array;
					} else {
						if (cache[data.uuid] === undefined) {
							cache[data.uuid] = loader.parse(data);
						}

						materials[data.uuid] = cache[data.uuid];
					}
				}
			}

			return materials;
		};

		_proto.parseAnimations = function parseAnimations(json) {
			var animations = {};

			if (json !== undefined) {
				for (var i = 0; i < json.length; i++) {
					var data = json[i];
					var clip = AnimationClip.parse(data);
					animations[clip.uuid] = clip;
				}
			}

			return animations;
		};

		_proto.parseImages = function parseImages(json, onLoad) {
			var scope = this;
			var images = {};
			var loader;

			function loadImage(url) {
				scope.manager.itemStart(url);
				return loader.load(url, function () {
					scope.manager.itemEnd(url);
				}, undefined, function () {
					scope.manager.itemError(url);
					scope.manager.itemEnd(url);
				});
			}

			function deserializeImage(image) {
				if (typeof image === 'string') {
					var url = image;
					var path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(url) ? url : scope.resourcePath + url;
					return loadImage(path);
				} else {
					if (image.data) {
						return {
							data: getTypedArray(image.type, image.data),
							width: image.width,
							height: image.height
						};
					} else {
						return null;
					}
				}
			}

			if (json !== undefined && json.length > 0) {
				var manager = new LoadingManager(onLoad);
				loader = new ImageLoader(manager);
				loader.setCrossOrigin(this.crossOrigin);

				for (var i = 0, il = json.length; i < il; i++) {
					var image = json[i];
					var url = image.url;

					if (Array.isArray(url)) {
						// load array of images e.g CubeTexture
						images[image.uuid] = [];

						for (var j = 0, jl = url.length; j < jl; j++) {
							var currentUrl = url[j];
							var deserializedImage = deserializeImage(currentUrl);

							if (deserializedImage !== null) {
								if (deserializedImage instanceof HTMLImageElement) {
									images[image.uuid].push(deserializedImage);
								} else {
									// special case: handle array of data textures for cube textures
									images[image.uuid].push(new DataTexture(deserializedImage.data, deserializedImage.width, deserializedImage.height));
								}
							}
						}
					} else {
						// load single image
						var _deserializedImage = deserializeImage(image.url);

						if (_deserializedImage !== null) {
							images[image.uuid] = _deserializedImage;
						}
					}
				}
			}

			return images;
		};

		_proto.parseImagesAsync = /*#__PURE__*/function () {
			var _parseImagesAsync = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(json) {
				var scope, images, loader, deserializeImage, _deserializeImage, i, il, image, url, j, jl, currentUrl, deserializedImage, _deserializedImage2;

				return regeneratorRuntime.wrap(function _callee4$(_context4) {
					while (1) {
						switch (_context4.prev = _context4.next) {
							case 0:
								_deserializeImage = function _deserializeImage3() {
									_deserializeImage = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(image) {
										var _url, path;

										return regeneratorRuntime.wrap(function _callee3$(_context3) {
											while (1) {
												switch (_context3.prev = _context3.next) {
													case 0:
														if (!(typeof image === 'string')) {
															_context3.next = 8;
															break;
														}

														_url = image;
														path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(_url) ? _url : scope.resourcePath + _url;
														_context3.next = 5;
														return loader.loadAsync(path);

													case 5:
														return _context3.abrupt("return", _context3.sent);

													case 8:
														if (!image.data) {
															_context3.next = 12;
															break;
														}

														return _context3.abrupt("return", {
															data: getTypedArray(image.type, image.data),
															width: image.width,
															height: image.height
														});

													case 12:
														return _context3.abrupt("return", null);

													case 13:
													case "end":
														return _context3.stop();
												}
											}
										}, _callee3);
									}));
									return _deserializeImage.apply(this, arguments);
								};

								deserializeImage = function _deserializeImage2(_x5) {
									return _deserializeImage.apply(this, arguments);
								};

								scope = this;
								images = {};

								if (!(json !== undefined && json.length > 0)) {
									_context4.next = 32;
									break;
								}

								loader = new ImageLoader(this.manager);
								loader.setCrossOrigin(this.crossOrigin);
								i = 0, il = json.length;

							case 8:
								if (!(i < il)) {
									_context4.next = 32;
									break;
								}

								image = json[i];
								url = image.url;

								if (!Array.isArray(url)) {
									_context4.next = 25;
									break;
								}

								// load array of images e.g CubeTexture
								images[image.uuid] = [];
								j = 0, jl = url.length;

							case 14:
								if (!(j < jl)) {
									_context4.next = 23;
									break;
								}

								currentUrl = url[j];
								_context4.next = 18;
								return deserializeImage(currentUrl);

							case 18:
								deserializedImage = _context4.sent;

								if (deserializedImage !== null) {
									if (deserializedImage instanceof HTMLImageElement) {
										images[image.uuid].push(deserializedImage);
									} else {
										// special case: handle array of data textures for cube textures
										images[image.uuid].push(new DataTexture(deserializedImage.data, deserializedImage.width, deserializedImage.height));
									}
								}

							case 20:
								j++;
								_context4.next = 14;
								break;

							case 23:
								_context4.next = 29;
								break;

							case 25:
								_context4.next = 27;
								return deserializeImage(image.url);

							case 27:
								_deserializedImage2 = _context4.sent;

								if (_deserializedImage2 !== null) {
									images[image.uuid] = _deserializedImage2;
								}

							case 29:
								i++;
								_context4.next = 8;
								break;

							case 32:
								return _context4.abrupt("return", images);

							case 33:
							case "end":
								return _context4.stop();
						}
					}
				}, _callee4, this);
			}));

			function parseImagesAsync(_x4) {
				return _parseImagesAsync.apply(this, arguments);
			}

			return parseImagesAsync;
		}();

		_proto.parseTextures = function parseTextures(json, images) {
			function parseConstant(value, type) {
				if (typeof value === 'number') return value;
				console.warn('THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value);
				return type[value];
			}

			var textures = {};

			if (json !== undefined) {
				for (var i = 0, l = json.length; i < l; i++) {
					var data = json[i];

					if (data.image === undefined) {
						console.warn('THREE.ObjectLoader: No "image" specified for', data.uuid);
					}

					if (images[data.image] === undefined) {
						console.warn('THREE.ObjectLoader: Undefined image', data.image);
					}

					var texture = void 0;
					var image = images[data.image];

					if (Array.isArray(image)) {
						texture = new CubeTexture(image);
						if (image.length === 6) texture.needsUpdate = true;
					} else {
						if (image && image.data) {
							texture = new DataTexture(image.data, image.width, image.height);
						} else {
							texture = new Texture(image);
						}

						if (image) texture.needsUpdate = true; // textures can have undefined image data
					}

					texture.uuid = data.uuid;
					if (data.name !== undefined) texture.name = data.name;
					if (data.mapping !== undefined) texture.mapping = parseConstant(data.mapping, TEXTURE_MAPPING);
					if (data.offset !== undefined) texture.offset.fromArray(data.offset);
					if (data.repeat !== undefined) texture.repeat.fromArray(data.repeat);
					if (data.center !== undefined) texture.center.fromArray(data.center);
					if (data.rotation !== undefined) texture.rotation = data.rotation;

					if (data.wrap !== undefined) {
						texture.wrapS = parseConstant(data.wrap[0], TEXTURE_WRAPPING);
						texture.wrapT = parseConstant(data.wrap[1], TEXTURE_WRAPPING);
					}

					if (data.format !== undefined) texture.format = data.format;
					if (data.type !== undefined) texture.type = data.type;
					if (data.encoding !== undefined) texture.encoding = data.encoding;
					if (data.minFilter !== undefined) texture.minFilter = parseConstant(data.minFilter, TEXTURE_FILTER);
					if (data.magFilter !== undefined) texture.magFilter = parseConstant(data.magFilter, TEXTURE_FILTER);
					if (data.anisotropy !== undefined) texture.anisotropy = data.anisotropy;
					if (data.flipY !== undefined) texture.flipY = data.flipY;
					if (data.premultiplyAlpha !== undefined) texture.premultiplyAlpha = data.premultiplyAlpha;
					if (data.unpackAlignment !== undefined) texture.unpackAlignment = data.unpackAlignment;
					textures[data.uuid] = texture;
				}
			}

			return textures;
		};

		_proto.parseObject = function parseObject(data, geometries, materials, textures, animations) {
			var object;

			function getGeometry(name) {
				if (geometries[name] === undefined) {
					console.warn('THREE.ObjectLoader: Undefined geometry', name);
				}

				return geometries[name];
			}

			function getMaterial(name) {
				if (name === undefined) return undefined;

				if (Array.isArray(name)) {
					var array = [];

					for (var i = 0, l = name.length; i < l; i++) {
						var uuid = name[i];

						if (materials[uuid] === undefined) {
							console.warn('THREE.ObjectLoader: Undefined material', uuid);
						}

						array.push(materials[uuid]);
					}

					return array;
				}

				if (materials[name] === undefined) {
					console.warn('THREE.ObjectLoader: Undefined material', name);
				}

				return materials[name];
			}

			function getTexture(uuid) {
				if (textures[uuid] === undefined) {
					console.warn('THREE.ObjectLoader: Undefined texture', uuid);
				}

				return textures[uuid];
			}

			var geometry, material;

			switch (data.type) {
				case 'Scene':
					object = new Scene();

					if (data.background !== undefined) {
						if (Number.isInteger(data.background)) {
							object.background = new Color(data.background);
						} else {
							object.background = getTexture(data.background);
						}
					}

					if (data.environment !== undefined) {
						object.environment = getTexture(data.environment);
					}

					if (data.fog !== undefined) {
						if (data.fog.type === 'Fog') {
							object.fog = new Fog(data.fog.color, data.fog.near, data.fog.far);
						} else if (data.fog.type === 'FogExp2') {
							object.fog = new FogExp2(data.fog.color, data.fog.density);
						}
					}

					break;

				case 'PerspectiveCamera':
					object = new PerspectiveCamera(data.fov, data.aspect, data.near, data.far);
					if (data.focus !== undefined) object.focus = data.focus;
					if (data.zoom !== undefined) object.zoom = data.zoom;
					if (data.filmGauge !== undefined) object.filmGauge = data.filmGauge;
					if (data.filmOffset !== undefined) object.filmOffset = data.filmOffset;
					if (data.view !== undefined) object.view = Object.assign({}, data.view);
					break;

				case 'OrthographicCamera':
					object = new OrthographicCamera(data.left, data.right, data.top, data.bottom, data.near, data.far);
					if (data.zoom !== undefined) object.zoom = data.zoom;
					if (data.view !== undefined) object.view = Object.assign({}, data.view);
					break;

				case 'AmbientLight':
					object = new AmbientLight(data.color, data.intensity);
					break;

				case 'DirectionalLight':
					object = new DirectionalLight(data.color, data.intensity);
					break;

				case 'PointLight':
					object = new PointLight(data.color, data.intensity, data.distance, data.decay);
					break;

				case 'RectAreaLight':
					object = new RectAreaLight(data.color, data.intensity, data.width, data.height);
					break;

				case 'SpotLight':
					object = new SpotLight(data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay);
					break;

				case 'HemisphereLight':
					object = new HemisphereLight(data.color, data.groundColor, data.intensity);
					break;

				case 'LightProbe':
					object = new LightProbe().fromJSON(data);
					break;

				case 'SkinnedMesh':
					geometry = getGeometry(data.geometry);
					material = getMaterial(data.material);
					object = new SkinnedMesh(geometry, material);
					if (data.bindMode !== undefined) object.bindMode = data.bindMode;
					if (data.bindMatrix !== undefined) object.bindMatrix.fromArray(data.bindMatrix);
					if (data.skeleton !== undefined) object.skeleton = data.skeleton;
					break;

				case 'Mesh':
					geometry = getGeometry(data.geometry);
					material = getMaterial(data.material);
					object = new Mesh(geometry, material);
					break;

				case 'InstancedMesh':
					geometry = getGeometry(data.geometry);
					material = getMaterial(data.material);
					var count = data.count;
					var instanceMatrix = data.instanceMatrix;
					var instanceColor = data.instanceColor;
					object = new InstancedMesh(geometry, material, count);
					object.instanceMatrix = new InstancedBufferAttribute(new Float32Array(instanceMatrix.array), 16);
					if (instanceColor !== undefined) object.instanceColor = new InstancedBufferAttribute(new Float32Array(instanceColor.array), instanceColor.itemSize);
					break;

				case 'LOD':
					object = new LOD();
					break;

				case 'Line':
					object = new Line(getGeometry(data.geometry), getMaterial(data.material));
					break;

				case 'LineLoop':
					object = new LineLoop(getGeometry(data.geometry), getMaterial(data.material));
					break;

				case 'LineSegments':
					object = new LineSegments(getGeometry(data.geometry), getMaterial(data.material));
					break;

				case 'PointCloud':
				case 'Points':
					object = new Points(getGeometry(data.geometry), getMaterial(data.material));
					break;

				case 'Sprite':
					object = new Sprite(getMaterial(data.material));
					break;

				case 'Group':
					object = new Group();
					break;

				case 'Bone':
					object = new Bone();
					break;

				default:
					object = new Object3D();
			}

			object.uuid = data.uuid;
			if (data.name !== undefined) object.name = data.name;

			if (data.matrix !== undefined) {
				object.matrix.fromArray(data.matrix);
				if (data.matrixAutoUpdate !== undefined) object.matrixAutoUpdate = data.matrixAutoUpdate;
				if (object.matrixAutoUpdate) object.matrix.decompose(object.position, object.quaternion, object.scale);
			} else {
				if (data.position !== undefined) object.position.fromArray(data.position);
				if (data.rotation !== undefined) object.rotation.fromArray(data.rotation);
				if (data.quaternion !== undefined) object.quaternion.fromArray(data.quaternion);
				if (data.scale !== undefined) object.scale.fromArray(data.scale);
			}

			if (data.castShadow !== undefined) object.castShadow = data.castShadow;
			if (data.receiveShadow !== undefined) object.receiveShadow = data.receiveShadow;

			if (data.shadow) {
				if (data.shadow.bias !== undefined) object.shadow.bias = data.shadow.bias;
				if (data.shadow.normalBias !== undefined) object.shadow.normalBias = data.shadow.normalBias;
				if (data.shadow.radius !== undefined) object.shadow.radius = data.shadow.radius;
				if (data.shadow.mapSize !== undefined) object.shadow.mapSize.fromArray(data.shadow.mapSize);
				if (data.shadow.camera !== undefined) object.shadow.camera = this.parseObject(data.shadow.camera);
			}

			if (data.visible !== undefined) object.visible = data.visible;
			if (data.frustumCulled !== undefined) object.frustumCulled = data.frustumCulled;
			if (data.renderOrder !== undefined) object.renderOrder = data.renderOrder;
			if (data.userData !== undefined) object.userData = data.userData;
			if (data.layers !== undefined) object.layers.mask = data.layers;

			if (data.children !== undefined) {
				var children = data.children;

				for (var i = 0; i < children.length; i++) {
					object.add(this.parseObject(children[i], geometries, materials, textures, animations));
				}
			}

			if (data.animations !== undefined) {
				var objectAnimations = data.animations;

				for (var _i = 0; _i < objectAnimations.length; _i++) {
					var uuid = objectAnimations[_i];
					object.animations.push(animations[uuid]);
				}
			}

			if (data.type === 'LOD') {
				if (data.autoUpdate !== undefined) object.autoUpdate = data.autoUpdate;
				var levels = data.levels;

				for (var l = 0; l < levels.length; l++) {
					var level = levels[l];
					var child = object.getObjectByProperty('uuid', level.object);

					if (child !== undefined) {
						object.addLevel(child, level.distance);
					}
				}
			}

			return object;
		};

		_proto.bindSkeletons = function bindSkeletons(object, skeletons) {
			if (Object.keys(skeletons).length === 0) return;
			object.traverse(function (child) {
				if (child.isSkinnedMesh === true && child.skeleton !== undefined) {
					var skeleton = skeletons[child.skeleton];

					if (skeleton === undefined) {
						console.warn('THREE.ObjectLoader: No skeleton found with UUID:', child.skeleton);
					} else {
						child.bind(skeleton, child.bindMatrix);
					}
				}
			});
		}
		/* DEPRECATED */
		;

		_proto.setTexturePath = function setTexturePath(value) {
			console.warn('THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath().');
			return this.setResourcePath(value);
		};

		return ObjectLoader;
	}(Loader);

	var TEXTURE_MAPPING = {
		UVMapping: UVMapping,
		CubeReflectionMapping: CubeReflectionMapping,
		CubeRefractionMapping: CubeRefractionMapping,
		EquirectangularReflectionMapping: EquirectangularReflectionMapping,
		EquirectangularRefractionMapping: EquirectangularRefractionMapping,
		CubeUVReflectionMapping: CubeUVReflectionMapping,
		CubeUVRefractionMapping: CubeUVRefractionMapping
	};
	var TEXTURE_WRAPPING = {
		RepeatWrapping: RepeatWrapping,
		ClampToEdgeWrapping: ClampToEdgeWrapping,
		MirroredRepeatWrapping: MirroredRepeatWrapping
	};
	var TEXTURE_FILTER = {
		NearestFilter: NearestFilter,
		NearestMipmapNearestFilter: NearestMipmapNearestFilter,
		NearestMipmapLinearFilter: NearestMipmapLinearFilter,
		LinearFilter: LinearFilter,
		LinearMipmapNearestFilter: LinearMipmapNearestFilter,
		LinearMipmapLinearFilter: LinearMipmapLinearFilter
	};

	var ImageBitmapLoader = /*#__PURE__*/function (_Loader) {
		_inheritsLoose(ImageBitmapLoader, _Loader);

		function ImageBitmapLoader(manager) {
			var _this;

			_this = _Loader.call(this, manager) || this;

			if (typeof createImageBitmap === 'undefined') {
				console.warn('THREE.ImageBitmapLoader: createImageBitmap() not supported.');
			}

			if (typeof fetch === 'undefined') {
				console.warn('THREE.ImageBitmapLoader: fetch() not supported.');
			}

			_this.options = {
				premultiplyAlpha: 'none'
			};
			return _this;
		}

		var _proto = ImageBitmapLoader.prototype;

		_proto.setOptions = function setOptions(options) {
			this.options = options;
			return this;
		};

		_proto.load = function load(url, onLoad, onProgress, onError) {
			if (url === undefined) url = '';
			if (this.path !== undefined) url = this.path + url;
			url = this.manager.resolveURL(url);
			var scope = this;
			var cached = Cache.get(url);

			if (cached !== undefined) {
				scope.manager.itemStart(url);
				setTimeout(function () {
					if (onLoad) onLoad(cached);
					scope.manager.itemEnd(url);
				}, 0);
				return cached;
			}

			var fetchOptions = {};
			fetchOptions.credentials = this.crossOrigin === 'anonymous' ? 'same-origin' : 'include';
			fetchOptions.headers = this.requestHeader;
			fetch(url, fetchOptions).then(function (res) {
				return res.blob();
			}).then(function (blob) {
				return createImageBitmap(blob, Object.assign(scope.options, {
					colorSpaceConversion: 'none'
				}));
			}).then(function (imageBitmap) {
				Cache.add(url, imageBitmap);
				if (onLoad) onLoad(imageBitmap);
				scope.manager.itemEnd(url);
			}).catch(function (e) {
				if (onError) onError(e);
				scope.manager.itemError(url);
				scope.manager.itemEnd(url);
			});
			scope.manager.itemStart(url);
		};

		return ImageBitmapLoader;
	}(Loader);

	ImageBitmapLoader.prototype.isImageBitmapLoader = true;

	var _context;

	var AudioContext = {
		getContext: function getContext() {
			if (_context === undefined) {
				_context = new (window.AudioContext || window.webkitAudioContext)();
			}

			return _context;
		},
		setContext: function setContext(value) {
			_context = value;
		}
	};

	var AudioLoader = /*#__PURE__*/function (_Loader) {
		_inheritsLoose(AudioLoader, _Loader);

		function AudioLoader(manager) {
			return _Loader.call(this, manager) || this;
		}

		var _proto = AudioLoader.prototype;

		_proto.load = function load(url, onLoad, onProgress, onError) {
			var scope = this;
			var loader = new FileLoader(this.manager);
			loader.setResponseType('arraybuffer');
			loader.setPath(this.path);
			loader.setRequestHeader(this.requestHeader);
			loader.setWithCredentials(this.withCredentials);
			loader.load(url, function (buffer) {
				try {
					// Create a copy of the buffer. The `decodeAudioData` method
					// detaches the buffer when complete, preventing reuse.
					var bufferCopy = buffer.slice(0);
					var context = AudioContext.getContext();
					context.decodeAudioData(bufferCopy, function (audioBuffer) {
						onLoad(audioBuffer);
					});
				} catch (e) {
					if (onError) {
						onError(e);
					} else {
						console.error(e);
					}

					scope.manager.itemError(url);
				}
			}, onProgress, onError);
		};

		return AudioLoader;
	}(Loader);

	var HemisphereLightProbe = /*#__PURE__*/function (_LightProbe) {
		_inheritsLoose(HemisphereLightProbe, _LightProbe);

		function HemisphereLightProbe(skyColor, groundColor, intensity) {
			var _this;

			if (intensity === void 0) {
				intensity = 1;
			}

			_this = _LightProbe.call(this, undefined, intensity) || this;
			var color1 = new Color().set(skyColor);
			var color2 = new Color().set(groundColor);
			var sky = new Vector3(color1.r, color1.g, color1.b);
			var ground = new Vector3(color2.r, color2.g, color2.b); // without extra factor of PI in the shader, should = 1 / Math.sqrt( Math.PI );

			var c0 = Math.sqrt(Math.PI);
			var c1 = c0 * Math.sqrt(0.75);

			_this.sh.coefficients[0].copy(sky).add(ground).multiplyScalar(c0);

			_this.sh.coefficients[1].copy(sky).sub(ground).multiplyScalar(c1);

			return _this;
		}

		return HemisphereLightProbe;
	}(LightProbe);

	HemisphereLightProbe.prototype.isHemisphereLightProbe = true;

	var AmbientLightProbe = /*#__PURE__*/function (_LightProbe) {
		_inheritsLoose(AmbientLightProbe, _LightProbe);

		function AmbientLightProbe(color, intensity) {
			var _this;

			if (intensity === void 0) {
				intensity = 1;
			}

			_this = _LightProbe.call(this, undefined, intensity) || this;
			var color1 = new Color().set(color); // without extra factor of PI in the shader, would be 2 / Math.sqrt( Math.PI );

			_this.sh.coefficients[0].set(color1.r, color1.g, color1.b).multiplyScalar(2 * Math.sqrt(Math.PI));

			return _this;
		}

		return AmbientLightProbe;
	}(LightProbe);

	AmbientLightProbe.prototype.isAmbientLightProbe = true;

	var _eyeRight = /*@__PURE__*/new Matrix4();

	var _eyeLeft = /*@__PURE__*/new Matrix4();

	var StereoCamera = /*#__PURE__*/function () {
		function StereoCamera() {
			this.type = 'StereoCamera';
			this.aspect = 1;
			this.eyeSep = 0.064;
			this.cameraL = new PerspectiveCamera();
			this.cameraL.layers.enable(1);
			this.cameraL.matrixAutoUpdate = false;
			this.cameraR = new PerspectiveCamera();
			this.cameraR.layers.enable(2);
			this.cameraR.matrixAutoUpdate = false;
			this._cache = {
				focus: null,
				fov: null,
				aspect: null,
				near: null,
				far: null,
				zoom: null,
				eyeSep: null
			};
		}

		var _proto = StereoCamera.prototype;

		_proto.update = function update(camera) {
			var cache = this._cache;
			var needsUpdate = cache.focus !== camera.focus || cache.fov !== camera.fov || cache.aspect !== camera.aspect * this.aspect || cache.near !== camera.near || cache.far !== camera.far || cache.zoom !== camera.zoom || cache.eyeSep !== this.eyeSep;

			if (needsUpdate) {
				cache.focus = camera.focus;
				cache.fov = camera.fov;
				cache.aspect = camera.aspect * this.aspect;
				cache.near = camera.near;
				cache.far = camera.far;
				cache.zoom = camera.zoom;
				cache.eyeSep = this.eyeSep; // Off-axis stereoscopic effect based on
				// http://paulbourke.net/stereographics/stereorender/

				var projectionMatrix = camera.projectionMatrix.clone();
				var eyeSepHalf = cache.eyeSep / 2;
				var eyeSepOnProjection = eyeSepHalf * cache.near / cache.focus;
				var ymax = cache.near * Math.tan(DEG2RAD * cache.fov * 0.5) / cache.zoom;
				var xmin, xmax; // translate xOffset

				_eyeLeft.elements[12] = -eyeSepHalf;
				_eyeRight.elements[12] = eyeSepHalf; // for left eye

				xmin = -ymax * cache.aspect + eyeSepOnProjection;
				xmax = ymax * cache.aspect + eyeSepOnProjection;
				projectionMatrix.elements[0] = 2 * cache.near / (xmax - xmin);
				projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);
				this.cameraL.projectionMatrix.copy(projectionMatrix); // for right eye

				xmin = -ymax * cache.aspect - eyeSepOnProjection;
				xmax = ymax * cache.aspect - eyeSepOnProjection;
				projectionMatrix.elements[0] = 2 * cache.near / (xmax - xmin);
				projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);
				this.cameraR.projectionMatrix.copy(projectionMatrix);
			}

			this.cameraL.matrixWorld.copy(camera.matrixWorld).multiply(_eyeLeft);
			this.cameraR.matrixWorld.copy(camera.matrixWorld).multiply(_eyeRight);
		};

		return StereoCamera;
	}();

	var Clock = /*#__PURE__*/function () {
		function Clock(autoStart) {
			if (autoStart === void 0) {
				autoStart = true;
			}

			this.autoStart = autoStart;
			this.startTime = 0;
			this.oldTime = 0;
			this.elapsedTime = 0;
			this.running = false;
		}

		var _proto = Clock.prototype;

		_proto.start = function start() {
			this.startTime = now();
			this.oldTime = this.startTime;
			this.elapsedTime = 0;
			this.running = true;
		};

		_proto.stop = function stop() {
			this.getElapsedTime();
			this.running = false;
			this.autoStart = false;
		};

		_proto.getElapsedTime = function getElapsedTime() {
			this.getDelta();
			return this.elapsedTime;
		};

		_proto.getDelta = function getDelta() {
			var diff = 0;

			if (this.autoStart && !this.running) {
				this.start();
				return 0;
			}

			if (this.running) {
				var newTime = now();
				diff = (newTime - this.oldTime) / 1000;
				this.oldTime = newTime;
				this.elapsedTime += diff;
			}

			return diff;
		};

		return Clock;
	}();

	function now() {
		return (typeof performance === 'undefined' ? Date : performance).now(); // see #10732
	}

	var _position$2 = /*@__PURE__*/new Vector3();

	var _quaternion$3 = /*@__PURE__*/new Quaternion();

	var _scale$1 = /*@__PURE__*/new Vector3();

	var _orientation = /*@__PURE__*/new Vector3();

	var AudioListener = /*#__PURE__*/function (_Object3D) {
		_inheritsLoose(AudioListener, _Object3D);

		function AudioListener() {
			var _this;

			_this = _Object3D.call(this) || this;
			_this.type = 'AudioListener';
			_this.context = AudioContext.getContext();
			_this.gain = _this.context.createGain();

			_this.gain.connect(_this.context.destination);

			_this.filter = null;
			_this.timeDelta = 0; // private

			_this._clock = new Clock();
			return _this;
		}

		var _proto = AudioListener.prototype;

		_proto.getInput = function getInput() {
			return this.gain;
		};

		_proto.removeFilter = function removeFilter() {
			if (this.filter !== null) {
				this.gain.disconnect(this.filter);
				this.filter.disconnect(this.context.destination);
				this.gain.connect(this.context.destination);
				this.filter = null;
			}

			return this;
		};

		_proto.getFilter = function getFilter() {
			return this.filter;
		};

		_proto.setFilter = function setFilter(value) {
			if (this.filter !== null) {
				this.gain.disconnect(this.filter);
				this.filter.disconnect(this.context.destination);
			} else {
				this.gain.disconnect(this.context.destination);
			}

			this.filter = value;
			this.gain.connect(this.filter);
			this.filter.connect(this.context.destination);
			return this;
		};

		_proto.getMasterVolume = function getMasterVolume() {
			return this.gain.gain.value;
		};

		_proto.setMasterVolume = function setMasterVolume(value) {
			this.gain.gain.setTargetAtTime(value, this.context.currentTime, 0.01);
			return this;
		};

		_proto.updateMatrixWorld = function updateMatrixWorld(force) {
			_Object3D.prototype.updateMatrixWorld.call(this, force);

			var listener = this.context.listener;
			var up = this.up;
			this.timeDelta = this._clock.getDelta();
			this.matrixWorld.decompose(_position$2, _quaternion$3, _scale$1);

			_orientation.set(0, 0, -1).applyQuaternion(_quaternion$3);

			if (listener.positionX) {
				// code path for Chrome (see #14393)
				var endTime = this.context.currentTime + this.timeDelta;
				listener.positionX.linearRampToValueAtTime(_position$2.x, endTime);
				listener.positionY.linearRampToValueAtTime(_position$2.y, endTime);
				listener.positionZ.linearRampToValueAtTime(_position$2.z, endTime);
				listener.forwardX.linearRampToValueAtTime(_orientation.x, endTime);
				listener.forwardY.linearRampToValueAtTime(_orientation.y, endTime);
				listener.forwardZ.linearRampToValueAtTime(_orientation.z, endTime);
				listener.upX.linearRampToValueAtTime(up.x, endTime);
				listener.upY.linearRampToValueAtTime(up.y, endTime);
				listener.upZ.linearRampToValueAtTime(up.z, endTime);
			} else {
				listener.setPosition(_position$2.x, _position$2.y, _position$2.z);
				listener.setOrientation(_orientation.x, _orientation.y, _orientation.z, up.x, up.y, up.z);
			}
		};

		return AudioListener;
	}(Object3D);

	var Audio = /*#__PURE__*/function (_Object3D) {
		_inheritsLoose(Audio, _Object3D);

		function Audio(listener) {
			var _this;

			_this = _Object3D.call(this) || this;
			_this.type = 'Audio';
			_this.listener = listener;
			_this.context = listener.context;
			_this.gain = _this.context.createGain();

			_this.gain.connect(listener.getInput());

			_this.autoplay = false;
			_this.buffer = null;
			_this.detune = 0;
			_this.loop = false;
			_this.loopStart = 0;
			_this.loopEnd = 0;
			_this.offset = 0;
			_this.duration = undefined;
			_this.playbackRate = 1;
			_this.isPlaying = false;
			_this.hasPlaybackControl = true;
			_this.source = null;
			_this.sourceType = 'empty';
			_this._startedAt = 0;
			_this._progress = 0;
			_this._connected = false;
			_this.filters = [];
			return _this;
		}

		var _proto = Audio.prototype;

		_proto.getOutput = function getOutput() {
			return this.gain;
		};

		_proto.setNodeSource = function setNodeSource(audioNode) {
			this.hasPlaybackControl = false;
			this.sourceType = 'audioNode';
			this.source = audioNode;
			this.connect();
			return this;
		};

		_proto.setMediaElementSource = function setMediaElementSource(mediaElement) {
			this.hasPlaybackControl = false;
			this.sourceType = 'mediaNode';
			this.source = this.context.createMediaElementSource(mediaElement);
			this.connect();
			return this;
		};

		_proto.setMediaStreamSource = function setMediaStreamSource(mediaStream) {
			this.hasPlaybackControl = false;
			this.sourceType = 'mediaStreamNode';
			this.source = this.context.createMediaStreamSource(mediaStream);
			this.connect();
			return this;
		};

		_proto.setBuffer = function setBuffer(audioBuffer) {
			this.buffer = audioBuffer;
			this.sourceType = 'buffer';
			if (this.autoplay) this.play();
			return this;
		};

		_proto.play = function play(delay) {
			if (delay === void 0) {
				delay = 0;
			}

			if (this.isPlaying === true) {
				console.warn('THREE.Audio: Audio is already playing.');
				return;
			}

			if (this.hasPlaybackControl === false) {
				console.warn('THREE.Audio: this Audio has no playback control.');
				return;
			}

			this._startedAt = this.context.currentTime + delay;
			var source = this.context.createBufferSource();
			source.buffer = this.buffer;
			source.loop = this.loop;
			source.loopStart = this.loopStart;
			source.loopEnd = this.loopEnd;
			source.onended = this.onEnded.bind(this);
			source.start(this._startedAt, this._progress + this.offset, this.duration);
			this.isPlaying = true;
			this.source = source;
			this.setDetune(this.detune);
			this.setPlaybackRate(this.playbackRate);
			return this.connect();
		};

		_proto.pause = function pause() {
			if (this.hasPlaybackControl === false) {
				console.warn('THREE.Audio: this Audio has no playback control.');
				return;
			}

			if (this.isPlaying === true) {
				// update current progress
				this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate;

				if (this.loop === true) {
					// ensure _progress does not exceed duration with looped audios
					this._progress = this._progress % (this.duration || this.buffer.duration);
				}

				this.source.stop();
				this.source.onended = null;
				this.isPlaying = false;
			}

			return this;
		};

		_proto.stop = function stop() {
			if (this.hasPlaybackControl === false) {
				console.warn('THREE.Audio: this Audio has no playback control.');
				return;
			}

			this._progress = 0;
			this.source.stop();
			this.source.onended = null;
			this.isPlaying = false;
			return this;
		};

		_proto.connect = function connect() {
			if (this.filters.length > 0) {
				this.source.connect(this.filters[0]);

				for (var i = 1, l = this.filters.length; i < l; i++) {
					this.filters[i - 1].connect(this.filters[i]);
				}

				this.filters[this.filters.length - 1].connect(this.getOutput());
			} else {
				this.source.connect(this.getOutput());
			}

			this._connected = true;
			return this;
		};

		_proto.disconnect = function disconnect() {
			if (this.filters.length > 0) {
				this.source.disconnect(this.filters[0]);

				for (var i = 1, l = this.filters.length; i < l; i++) {
					this.filters[i - 1].disconnect(this.filters[i]);
				}

				this.filters[this.filters.length - 1].disconnect(this.getOutput());
			} else {
				this.source.disconnect(this.getOutput());
			}

			this._connected = false;
			return this;
		};

		_proto.getFilters = function getFilters() {
			return this.filters;
		};

		_proto.setFilters = function setFilters(value) {
			if (!value) value = [];

			if (this._connected === true) {
				this.disconnect();
				this.filters = value.slice();
				this.connect();
			} else {
				this.filters = value.slice();
			}

			return this;
		};

		_proto.setDetune = function setDetune(value) {
			this.detune = value;
			if (this.source.detune === undefined) return; // only set detune when available

			if (this.isPlaying === true) {
				this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, 0.01);
			}

			return this;
		};

		_proto.getDetune = function getDetune() {
			return this.detune;
		};

		_proto.getFilter = function getFilter() {
			return this.getFilters()[0];
		};

		_proto.setFilter = function setFilter(filter) {
			return this.setFilters(filter ? [filter] : []);
		};

		_proto.setPlaybackRate = function setPlaybackRate(value) {
			if (this.hasPlaybackControl === false) {
				console.warn('THREE.Audio: this Audio has no playback control.');
				return;
			}

			this.playbackRate = value;

			if (this.isPlaying === true) {
				this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, 0.01);
			}

			return this;
		};

		_proto.getPlaybackRate = function getPlaybackRate() {
			return this.playbackRate;
		};

		_proto.onEnded = function onEnded() {
			this.isPlaying = false;
		};

		_proto.getLoop = function getLoop() {
			if (this.hasPlaybackControl === false) {
				console.warn('THREE.Audio: this Audio has no playback control.');
				return false;
			}

			return this.loop;
		};

		_proto.setLoop = function setLoop(value) {
			if (this.hasPlaybackControl === false) {
				console.warn('THREE.Audio: this Audio has no playback control.');
				return;
			}

			this.loop = value;

			if (this.isPlaying === true) {
				this.source.loop = this.loop;
			}

			return this;
		};

		_proto.setLoopStart = function setLoopStart(value) {
			this.loopStart = value;
			return this;
		};

		_proto.setLoopEnd = function setLoopEnd(value) {
			this.loopEnd = value;
			return this;
		};

		_proto.getVolume = function getVolume() {
			return this.gain.gain.value;
		};

		_proto.setVolume = function setVolume(value) {
			this.gain.gain.setTargetAtTime(value, this.context.currentTime, 0.01);
			return this;
		};

		return Audio;
	}(Object3D);

	var _position$3 = /*@__PURE__*/new Vector3();

	var _quaternion$4 = /*@__PURE__*/new Quaternion();

	var _scale$2 = /*@__PURE__*/new Vector3();

	var _orientation$1 = /*@__PURE__*/new Vector3();

	var PositionalAudio = /*#__PURE__*/function (_Audio) {
		_inheritsLoose(PositionalAudio, _Audio);

		function PositionalAudio(listener) {
			var _this;

			_this = _Audio.call(this, listener) || this;
			_this.panner = _this.context.createPanner();
			_this.panner.panningModel = 'HRTF';

			_this.panner.connect(_this.gain);

			return _this;
		}

		var _proto = PositionalAudio.prototype;

		_proto.getOutput = function getOutput() {
			return this.panner;
		};

		_proto.getRefDistance = function getRefDistance() {
			return this.panner.refDistance;
		};

		_proto.setRefDistance = function setRefDistance(value) {
			this.panner.refDistance = value;
			return this;
		};

		_proto.getRolloffFactor = function getRolloffFactor() {
			return this.panner.rolloffFactor;
		};

		_proto.setRolloffFactor = function setRolloffFactor(value) {
			this.panner.rolloffFactor = value;
			return this;
		};

		_proto.getDistanceModel = function getDistanceModel() {
			return this.panner.distanceModel;
		};

		_proto.setDistanceModel = function setDistanceModel(value) {
			this.panner.distanceModel = value;
			return this;
		};

		_proto.getMaxDistance = function getMaxDistance() {
			return this.panner.maxDistance;
		};

		_proto.setMaxDistance = function setMaxDistance(value) {
			this.panner.maxDistance = value;
			return this;
		};

		_proto.setDirectionalCone = function setDirectionalCone(coneInnerAngle, coneOuterAngle, coneOuterGain) {
			this.panner.coneInnerAngle = coneInnerAngle;
			this.panner.coneOuterAngle = coneOuterAngle;
			this.panner.coneOuterGain = coneOuterGain;
			return this;
		};

		_proto.updateMatrixWorld = function updateMatrixWorld(force) {
			_Audio.prototype.updateMatrixWorld.call(this, force);

			if (this.hasPlaybackControl === true && this.isPlaying === false) return;
			this.matrixWorld.decompose(_position$3, _quaternion$4, _scale$2);

			_orientation$1.set(0, 0, 1).applyQuaternion(_quaternion$4);

			var panner = this.panner;

			if (panner.positionX) {
				// code path for Chrome and Firefox (see #14393)
				var endTime = this.context.currentTime + this.listener.timeDelta;
				panner.positionX.linearRampToValueAtTime(_position$3.x, endTime);
				panner.positionY.linearRampToValueAtTime(_position$3.y, endTime);
				panner.positionZ.linearRampToValueAtTime(_position$3.z, endTime);
				panner.orientationX.linearRampToValueAtTime(_orientation$1.x, endTime);
				panner.orientationY.linearRampToValueAtTime(_orientation$1.y, endTime);
				panner.orientationZ.linearRampToValueAtTime(_orientation$1.z, endTime);
			} else {
				panner.setPosition(_position$3.x, _position$3.y, _position$3.z);
				panner.setOrientation(_orientation$1.x, _orientation$1.y, _orientation$1.z);
			}
		};

		return PositionalAudio;
	}(Audio);

	var AudioAnalyser = /*#__PURE__*/function () {
		function AudioAnalyser(audio, fftSize) {
			if (fftSize === void 0) {
				fftSize = 2048;
			}

			this.analyser = audio.context.createAnalyser();
			this.analyser.fftSize = fftSize;
			this.data = new Uint8Array(this.analyser.frequencyBinCount);
			audio.getOutput().connect(this.analyser);
		}

		var _proto = AudioAnalyser.prototype;

		_proto.getFrequencyData = function getFrequencyData() {
			this.analyser.getByteFrequencyData(this.data);
			return this.data;
		};

		_proto.getAverageFrequency = function getAverageFrequency() {
			var value = 0;
			var data = this.getFrequencyData();

			for (var i = 0; i < data.length; i++) {
				value += data[i];
			}

			return value / data.length;
		};

		return AudioAnalyser;
	}();

	var PropertyMixer = /*#__PURE__*/function () {
		function PropertyMixer(binding, typeName, valueSize) {
			this.binding = binding;
			this.valueSize = valueSize;
			var mixFunction, mixFunctionAdditive, setIdentity; // buffer layout: [ incoming | accu0 | accu1 | orig | addAccu | (optional work) ]
			//
			// interpolators can use .buffer as their .result
			// the data then goes to 'incoming'
			//
			// 'accu0' and 'accu1' are used frame-interleaved for
			// the cumulative result and are compared to detect
			// changes
			//
			// 'orig' stores the original state of the property
			//
			// 'add' is used for additive cumulative results
			//
			// 'work' is optional and is only present for quaternion types. It is used
			// to store intermediate quaternion multiplication results

			switch (typeName) {
				case 'quaternion':
					mixFunction = this._slerp;
					mixFunctionAdditive = this._slerpAdditive;
					setIdentity = this._setAdditiveIdentityQuaternion;
					this.buffer = new Float64Array(valueSize * 6);
					this._workIndex = 5;
					break;

				case 'string':
				case 'bool':
					mixFunction = this._select; // Use the regular mix function and for additive on these types,
					// additive is not relevant for non-numeric types

					mixFunctionAdditive = this._select;
					setIdentity = this._setAdditiveIdentityOther;
					this.buffer = new Array(valueSize * 5);
					break;

				default:
					mixFunction = this._lerp;
					mixFunctionAdditive = this._lerpAdditive;
					setIdentity = this._setAdditiveIdentityNumeric;
					this.buffer = new Float64Array(valueSize * 5);
			}

			this._mixBufferRegion = mixFunction;
			this._mixBufferRegionAdditive = mixFunctionAdditive;
			this._setIdentity = setIdentity;
			this._origIndex = 3;
			this._addIndex = 4;
			this.cumulativeWeight = 0;
			this.cumulativeWeightAdditive = 0;
			this.useCount = 0;
			this.referenceCount = 0;
		} // accumulate data in the 'incoming' region into 'accu<i>'


		var _proto = PropertyMixer.prototype;

		_proto.accumulate = function accumulate(accuIndex, weight) {
			// note: happily accumulating nothing when weight = 0, the caller knows
			// the weight and shouldn't have made the call in the first place
			var buffer = this.buffer,
					stride = this.valueSize,
					offset = accuIndex * stride + stride;
			var currentWeight = this.cumulativeWeight;

			if (currentWeight === 0) {
				// accuN := incoming * weight
				for (var i = 0; i !== stride; ++i) {
					buffer[offset + i] = buffer[i];
				}

				currentWeight = weight;
			} else {
				// accuN := accuN + incoming * weight
				currentWeight += weight;
				var mix = weight / currentWeight;

				this._mixBufferRegion(buffer, offset, 0, mix, stride);
			}

			this.cumulativeWeight = currentWeight;
		} // accumulate data in the 'incoming' region into 'add'
		;

		_proto.accumulateAdditive = function accumulateAdditive(weight) {
			var buffer = this.buffer,
					stride = this.valueSize,
					offset = stride * this._addIndex;

			if (this.cumulativeWeightAdditive === 0) {
				// add = identity
				this._setIdentity();
			} // add := add + incoming * weight


			this._mixBufferRegionAdditive(buffer, offset, 0, weight, stride);

			this.cumulativeWeightAdditive += weight;
		} // apply the state of 'accu<i>' to the binding when accus differ
		;

		_proto.apply = function apply(accuIndex) {
			var stride = this.valueSize,
					buffer = this.buffer,
					offset = accuIndex * stride + stride,
					weight = this.cumulativeWeight,
					weightAdditive = this.cumulativeWeightAdditive,
					binding = this.binding;
			this.cumulativeWeight = 0;
			this.cumulativeWeightAdditive = 0;

			if (weight < 1) {
				// accuN := accuN + original * ( 1 - cumulativeWeight )
				var originalValueOffset = stride * this._origIndex;

				this._mixBufferRegion(buffer, offset, originalValueOffset, 1 - weight, stride);
			}

			if (weightAdditive > 0) {
				// accuN := accuN + additive accuN
				this._mixBufferRegionAdditive(buffer, offset, this._addIndex * stride, 1, stride);
			}

			for (var i = stride, e = stride + stride; i !== e; ++i) {
				if (buffer[i] !== buffer[i + stride]) {
					// value has changed -> update scene graph
					binding.setValue(buffer, offset);
					break;
				}
			}
		} // remember the state of the bound property and copy it to both accus
		;

		_proto.saveOriginalState = function saveOriginalState() {
			var binding = this.binding;
			var buffer = this.buffer,
					stride = this.valueSize,
					originalValueOffset = stride * this._origIndex;
			binding.getValue(buffer, originalValueOffset); // accu[0..1] := orig -- initially detect changes against the original

			for (var i = stride, e = originalValueOffset; i !== e; ++i) {
				buffer[i] = buffer[originalValueOffset + i % stride];
			} // Add to identity for additive


			this._setIdentity();

			this.cumulativeWeight = 0;
			this.cumulativeWeightAdditive = 0;
		} // apply the state previously taken via 'saveOriginalState' to the binding
		;

		_proto.restoreOriginalState = function restoreOriginalState() {
			var originalValueOffset = this.valueSize * 3;
			this.binding.setValue(this.buffer, originalValueOffset);
		};

		_proto._setAdditiveIdentityNumeric = function _setAdditiveIdentityNumeric() {
			var startIndex = this._addIndex * this.valueSize;
			var endIndex = startIndex + this.valueSize;

			for (var i = startIndex; i < endIndex; i++) {
				this.buffer[i] = 0;
			}
		};

		_proto._setAdditiveIdentityQuaternion = function _setAdditiveIdentityQuaternion() {
			this._setAdditiveIdentityNumeric();

			this.buffer[this._addIndex * this.valueSize + 3] = 1;
		};

		_proto._setAdditiveIdentityOther = function _setAdditiveIdentityOther() {
			var startIndex = this._origIndex * this.valueSize;
			var targetIndex = this._addIndex * this.valueSize;

			for (var i = 0; i < this.valueSize; i++) {
				this.buffer[targetIndex + i] = this.buffer[startIndex + i];
			}
		} // mix functions
		;

		_proto._select = function _select(buffer, dstOffset, srcOffset, t, stride) {
			if (t >= 0.5) {
				for (var i = 0; i !== stride; ++i) {
					buffer[dstOffset + i] = buffer[srcOffset + i];
				}
			}
		};

		_proto._slerp = function _slerp(buffer, dstOffset, srcOffset, t) {
			Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t);
		};

		_proto._slerpAdditive = function _slerpAdditive(buffer, dstOffset, srcOffset, t, stride) {
			var workOffset = this._workIndex * stride; // Store result in intermediate buffer offset

			Quaternion.multiplyQuaternionsFlat(buffer, workOffset, buffer, dstOffset, buffer, srcOffset); // Slerp to the intermediate result

			Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, workOffset, t);
		};

		_proto._lerp = function _lerp(buffer, dstOffset, srcOffset, t, stride) {
			var s = 1 - t;

			for (var i = 0; i !== stride; ++i) {
				var j = dstOffset + i;
				buffer[j] = buffer[j] * s + buffer[srcOffset + i] * t;
			}
		};

		_proto._lerpAdditive = function _lerpAdditive(buffer, dstOffset, srcOffset, t, stride) {
			for (var i = 0; i !== stride; ++i) {
				var j = dstOffset + i;
				buffer[j] = buffer[j] + buffer[srcOffset + i] * t;
			}
		};

		return PropertyMixer;
	}();

	// Characters [].:/ are reserved for track binding syntax.
	var _RESERVED_CHARS_RE = '\\[\\]\\.:\\/';

	var _reservedRe = new RegExp('[' + _RESERVED_CHARS_RE + ']', 'g'); // Attempts to allow node names from any language. ES5's `\w` regexp matches
	// only latin characters, and the unicode \p{L} is not yet supported. So
	// instead, we exclude reserved characters and match everything else.


	var _wordChar = '[^' + _RESERVED_CHARS_RE + ']';

	var _wordCharOrDot = '[^' + _RESERVED_CHARS_RE.replace('\\.', '') + ']'; // Parent directories, delimited by '/' or ':'. Currently unused, but must
	// be matched to parse the rest of the track name.


	var _directoryRe = /((?:WC+[\/:])*)/.source.replace('WC', _wordChar); // Target node. May contain word characters (a-zA-Z0-9_) and '.' or '-'.


	var _nodeRe = /(WCOD+)?/.source.replace('WCOD', _wordCharOrDot); // Object on target node, and accessor. May not contain reserved
	// characters. Accessor may contain any character except closing bracket.


	var _objectRe = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace('WC', _wordChar); // Property and accessor. May not contain reserved characters. Accessor may
	// contain any non-bracket characters.


	var _propertyRe = /\.(WC+)(?:\[(.+)\])?/.source.replace('WC', _wordChar);

	var _trackRe = new RegExp('' + '^' + _directoryRe + _nodeRe + _objectRe + _propertyRe + '$');

	var _supportedObjectNames = ['material', 'materials', 'bones'];

	var Composite = /*#__PURE__*/function () {
		function Composite(targetGroup, path, optionalParsedPath) {
			var parsedPath = optionalParsedPath || PropertyBinding.parseTrackName(path);
			this._targetGroup = targetGroup;
			this._bindings = targetGroup.subscribe_(path, parsedPath);
		}

		var _proto = Composite.prototype;

		_proto.getValue = function getValue(array, offset) {
			this.bind(); // bind all binding

			var firstValidIndex = this._targetGroup.nCachedObjects_,
					binding = this._bindings[firstValidIndex]; // and only call .getValue on the first

			if (binding !== undefined) binding.getValue(array, offset);
		};

		_proto.setValue = function setValue(array, offset) {
			var bindings = this._bindings;

			for (var i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
				bindings[i].setValue(array, offset);
			}
		};

		_proto.bind = function bind() {
			var bindings = this._bindings;

			for (var i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
				bindings[i].bind();
			}
		};

		_proto.unbind = function unbind() {
			var bindings = this._bindings;

			for (var i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
				bindings[i].unbind();
			}
		};

		return Composite;
	}(); // Note: This class uses a State pattern on a per-method basis:
	// 'bind' sets 'this.getValue' / 'setValue' and shadows the
	// prototype version of these methods with one that represents
	// the bound state. When the property is not found, the methods
	// become no-ops.


	var PropertyBinding = /*#__PURE__*/function () {
		function PropertyBinding(rootNode, path, parsedPath) {
			this.path = path;
			this.parsedPath = parsedPath || PropertyBinding.parseTrackName(path);
			this.node = PropertyBinding.findNode(rootNode, this.parsedPath.nodeName) || rootNode;
			this.rootNode = rootNode; // initial state of these methods that calls 'bind'

			this.getValue = this._getValue_unbound;
			this.setValue = this._setValue_unbound;
		}

		PropertyBinding.create = function create(root, path, parsedPath) {
			if (!(root && root.isAnimationObjectGroup)) {
				return new PropertyBinding(root, path, parsedPath);
			} else {
				return new PropertyBinding.Composite(root, path, parsedPath);
			}
		}
		/**
		 * Replaces spaces with underscores and removes unsupported characters from
		 * node names, to ensure compatibility with parseTrackName().
		 *
		 * @param {string} name Node name to be sanitized.
		 * @return {string}
		 */
		;

		PropertyBinding.sanitizeNodeName = function sanitizeNodeName(name) {
			return name.replace(/\s/g, '_').replace(_reservedRe, '');
		};

		PropertyBinding.parseTrackName = function parseTrackName(trackName) {
			var matches = _trackRe.exec(trackName);

			if (!matches) {
				throw new Error('PropertyBinding: Cannot parse trackName: ' + trackName);
			}

			var results = {
				// directoryName: matches[ 1 ], // (tschw) currently unused
				nodeName: matches[2],
				objectName: matches[3],
				objectIndex: matches[4],
				propertyName: matches[5],
				// required
				propertyIndex: matches[6]
			};
			var lastDot = results.nodeName && results.nodeName.lastIndexOf('.');

			if (lastDot !== undefined && lastDot !== -1) {
				var objectName = results.nodeName.substring(lastDot + 1); // Object names must be checked against an allowlist. Otherwise, there
				// is no way to parse 'foo.bar.baz': 'baz' must be a property, but
				// 'bar' could be the objectName, or part of a nodeName (which can
				// include '.' characters).

				if (_supportedObjectNames.indexOf(objectName) !== -1) {
					results.nodeName = results.nodeName.substring(0, lastDot);
					results.objectName = objectName;
				}
			}

			if (results.propertyName === null || results.propertyName.length === 0) {
				throw new Error('PropertyBinding: can not parse propertyName from trackName: ' + trackName);
			}

			return results;
		};

		PropertyBinding.findNode = function findNode(root, nodeName) {
			if (!nodeName || nodeName === '' || nodeName === '.' || nodeName === -1 || nodeName === root.name || nodeName === root.uuid) {
				return root;
			} // search into skeleton bones.


			if (root.skeleton) {
				var bone = root.skeleton.getBoneByName(nodeName);

				if (bone !== undefined) {
					return bone;
				}
			} // search into node subtree.


			if (root.children) {
				var searchNodeSubtree = function searchNodeSubtree(children) {
					for (var i = 0; i < children.length; i++) {
						var childNode = children[i];

						if (childNode.name === nodeName || childNode.uuid === nodeName) {
							return childNode;
						}

						var result = searchNodeSubtree(childNode.children);
						if (result) return result;
					}

					return null;
				};

				var subTreeNode = searchNodeSubtree(root.children);

				if (subTreeNode) {
					return subTreeNode;
				}
			}

			return null;
		} // these are used to "bind" a nonexistent property
		;

		var _proto2 = PropertyBinding.prototype;

		_proto2._getValue_unavailable = function _getValue_unavailable() {};

		_proto2._setValue_unavailable = function _setValue_unavailable() {} // Getters
		;

		_proto2._getValue_direct = function _getValue_direct(buffer, offset) {
			buffer[offset] = this.targetObject[this.propertyName];
		};

		_proto2._getValue_array = function _getValue_array(buffer, offset) {
			var source = this.resolvedProperty;

			for (var i = 0, n = source.length; i !== n; ++i) {
				buffer[offset++] = source[i];
			}
		};

		_proto2._getValue_arrayElement = function _getValue_arrayElement(buffer, offset) {
			buffer[offset] = this.resolvedProperty[this.propertyIndex];
		};

		_proto2._getValue_toArray = function _getValue_toArray(buffer, offset) {
			this.resolvedProperty.toArray(buffer, offset);
		} // Direct
		;

		_proto2._setValue_direct = function _setValue_direct(buffer, offset) {
			this.targetObject[this.propertyName] = buffer[offset];
		};

		_proto2._setValue_direct_setNeedsUpdate = function _setValue_direct_setNeedsUpdate(buffer, offset) {
			this.targetObject[this.propertyName] = buffer[offset];
			this.targetObject.needsUpdate = true;
		};

		_proto2._setValue_direct_setMatrixWorldNeedsUpdate = function _setValue_direct_setMatrixWorldNeedsUpdate(buffer, offset) {
			this.targetObject[this.propertyName] = buffer[offset];
			this.targetObject.matrixWorldNeedsUpdate = true;
		} // EntireArray
		;

		_proto2._setValue_array = function _setValue_array(buffer, offset) {
			var dest = this.resolvedProperty;

			for (var i = 0, n = dest.length; i !== n; ++i) {
				dest[i] = buffer[offset++];
			}
		};

		_proto2._setValue_array_setNeedsUpdate = function _setValue_array_setNeedsUpdate(buffer, offset) {
			var dest = this.resolvedProperty;

			for (var i = 0, n = dest.length; i !== n; ++i) {
				dest[i] = buffer[offset++];
			}

			this.targetObject.needsUpdate = true;
		};

		_proto2._setValue_array_setMatrixWorldNeedsUpdate = function _setValue_array_setMatrixWorldNeedsUpdate(buffer, offset) {
			var dest = this.resolvedProperty;

			for (var i = 0, n = dest.length; i !== n; ++i) {
				dest[i] = buffer[offset++];
			}

			this.targetObject.matrixWorldNeedsUpdate = true;
		} // ArrayElement
		;

		_proto2._setValue_arrayElement = function _setValue_arrayElement(buffer, offset) {
			this.resolvedProperty[this.propertyIndex] = buffer[offset];
		};

		_proto2._setValue_arrayElement_setNeedsUpdate = function _setValue_arrayElement_setNeedsUpdate(buffer, offset) {
			this.resolvedProperty[this.propertyIndex] = buffer[offset];
			this.targetObject.needsUpdate = true;
		};

		_proto2._setValue_arrayElement_setMatrixWorldNeedsUpdate = function _setValue_arrayElement_setMatrixWorldNeedsUpdate(buffer, offset) {
			this.resolvedProperty[this.propertyIndex] = buffer[offset];
			this.targetObject.matrixWorldNeedsUpdate = true;
		} // HasToFromArray
		;

		_proto2._setValue_fromArray = function _setValue_fromArray(buffer, offset) {
			this.resolvedProperty.fromArray(buffer, offset);
		};

		_proto2._setValue_fromArray_setNeedsUpdate = function _setValue_fromArray_setNeedsUpdate(buffer, offset) {
			this.resolvedProperty.fromArray(buffer, offset);
			this.targetObject.needsUpdate = true;
		};

		_proto2._setValue_fromArray_setMatrixWorldNeedsUpdate = function _setValue_fromArray_setMatrixWorldNeedsUpdate(buffer, offset) {
			this.resolvedProperty.fromArray(buffer, offset);
			this.targetObject.matrixWorldNeedsUpdate = true;
		};

		_proto2._getValue_unbound = function _getValue_unbound(targetArray, offset) {
			this.bind();
			this.getValue(targetArray, offset);
		};

		_proto2._setValue_unbound = function _setValue_unbound(sourceArray, offset) {
			this.bind();
			this.setValue(sourceArray, offset);
		} // create getter / setter pair for a property in the scene graph
		;

		_proto2.bind = function bind() {
			var targetObject = this.node;
			var parsedPath = this.parsedPath;
			var objectName = parsedPath.objectName;
			var propertyName = parsedPath.propertyName;
			var propertyIndex = parsedPath.propertyIndex;

			if (!targetObject) {
				targetObject = PropertyBinding.findNode(this.rootNode, parsedPath.nodeName) || this.rootNode;
				this.node = targetObject;
			} // set fail state so we can just 'return' on error


			this.getValue = this._getValue_unavailable;
			this.setValue = this._setValue_unavailable; // ensure there is a value node

			if (!targetObject) {
				console.error('THREE.PropertyBinding: Trying to update node for track: ' + this.path + ' but it wasn\'t found.');
				return;
			}

			if (objectName) {
				var objectIndex = parsedPath.objectIndex; // special cases were we need to reach deeper into the hierarchy to get the face materials....

				switch (objectName) {
					case 'materials':
						if (!targetObject.material) {
							console.error('THREE.PropertyBinding: Can not bind to material as node does not have a material.', this);
							return;
						}

						if (!targetObject.material.materials) {
							console.error('THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.', this);
							return;
						}

						targetObject = targetObject.material.materials;
						break;

					case 'bones':
						if (!targetObject.skeleton) {
							console.error('THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.', this);
							return;
						} // potential future optimization: skip this if propertyIndex is already an integer
						// and convert the integer string to a true integer.


						targetObject = targetObject.skeleton.bones; // support resolving morphTarget names into indices.

						for (var i = 0; i < targetObject.length; i++) {
							if (targetObject[i].name === objectIndex) {
								objectIndex = i;
								break;
							}
						}

						break;

					default:
						if (targetObject[objectName] === undefined) {
							console.error('THREE.PropertyBinding: Can not bind to objectName of node undefined.', this);
							return;
						}

						targetObject = targetObject[objectName];
				}

				if (objectIndex !== undefined) {
					if (targetObject[objectIndex] === undefined) {
						console.error('THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.', this, targetObject);
						return;
					}

					targetObject = targetObject[objectIndex];
				}
			} // resolve property


			var nodeProperty = targetObject[propertyName];

			if (nodeProperty === undefined) {
				var nodeName = parsedPath.nodeName;
				console.error('THREE.PropertyBinding: Trying to update property for track: ' + nodeName + '.' + propertyName + ' but it wasn\'t found.', targetObject);
				return;
			} // determine versioning scheme


			var versioning = this.Versioning.None;
			this.targetObject = targetObject;

			if (targetObject.needsUpdate !== undefined) {
				// material
				versioning = this.Versioning.NeedsUpdate;
			} else if (targetObject.matrixWorldNeedsUpdate !== undefined) {
				// node transform
				versioning = this.Versioning.MatrixWorldNeedsUpdate;
			} // determine how the property gets bound


			var bindingType = this.BindingType.Direct;

			if (propertyIndex !== undefined) {
				// access a sub element of the property array (only primitives are supported right now)
				if (propertyName === 'morphTargetInfluences') {
					// potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.
					// support resolving morphTarget names into indices.
					if (!targetObject.geometry) {
						console.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.', this);
						return;
					}

					if (targetObject.geometry.isBufferGeometry) {
						if (!targetObject.geometry.morphAttributes) {
							console.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.', this);
							return;
						}

						if (targetObject.morphTargetDictionary[propertyIndex] !== undefined) {
							propertyIndex = targetObject.morphTargetDictionary[propertyIndex];
						}
					} else {
						console.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.', this);
						return;
					}
				}

				bindingType = this.BindingType.ArrayElement;
				this.resolvedProperty = nodeProperty;
				this.propertyIndex = propertyIndex;
			} else if (nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined) {
				// must use copy for Object3D.Euler/Quaternion
				bindingType = this.BindingType.HasFromToArray;
				this.resolvedProperty = nodeProperty;
			} else if (Array.isArray(nodeProperty)) {
				bindingType = this.BindingType.EntireArray;
				this.resolvedProperty = nodeProperty;
			} else {
				this.propertyName = propertyName;
			} // select getter / setter


			this.getValue = this.GetterByBindingType[bindingType];
			this.setValue = this.SetterByBindingTypeAndVersioning[bindingType][versioning];
		};

		_proto2.unbind = function unbind() {
			this.node = null; // back to the prototype version of getValue / setValue
			// note: avoiding to mutate the shape of 'this' via 'delete'

			this.getValue = this._getValue_unbound;
			this.setValue = this._setValue_unbound;
		};

		return PropertyBinding;
	}();

	PropertyBinding.Composite = Composite;
	PropertyBinding.prototype.BindingType = {
		Direct: 0,
		EntireArray: 1,
		ArrayElement: 2,
		HasFromToArray: 3
	};
	PropertyBinding.prototype.Versioning = {
		None: 0,
		NeedsUpdate: 1,
		MatrixWorldNeedsUpdate: 2
	};
	PropertyBinding.prototype.GetterByBindingType = [PropertyBinding.prototype._getValue_direct, PropertyBinding.prototype._getValue_array, PropertyBinding.prototype._getValue_arrayElement, PropertyBinding.prototype._getValue_toArray];
	PropertyBinding.prototype.SetterByBindingTypeAndVersioning = [[// Direct
	PropertyBinding.prototype._setValue_direct, PropertyBinding.prototype._setValue_direct_setNeedsUpdate, PropertyBinding.prototype._setValue_direct_setMatrixWorldNeedsUpdate], [// EntireArray
	PropertyBinding.prototype._setValue_array, PropertyBinding.prototype._setValue_array_setNeedsUpdate, PropertyBinding.prototype._setValue_array_setMatrixWorldNeedsUpdate], [// ArrayElement
	PropertyBinding.prototype._setValue_arrayElement, PropertyBinding.prototype._setValue_arrayElement_setNeedsUpdate, PropertyBinding.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate], [// HasToFromArray
	PropertyBinding.prototype._setValue_fromArray, PropertyBinding.prototype._setValue_fromArray_setNeedsUpdate, PropertyBinding.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];

	/**
	 *
	 * A group of objects that receives a shared animation state.
	 *
	 * Usage:
	 *
	 *	- Add objects you would otherwise pass as 'root' to the
	 *		constructor or the .clipAction method of AnimationMixer.
	 *
	 *	- Instead pass this object as 'root'.
	 *
	 *	- You can also add and remove objects later when the mixer
	 *		is running.
	 *
	 * Note:
	 *
	 *		Objects of this class appear as one object to the mixer,
	 *		so cache control of the individual objects must be done
	 *		on the group.
	 *
	 * Limitation:
	 *
	 *	- The animated properties must be compatible among the
	 *		all objects in the group.
	 *
	 *	- A single property can either be controlled through a
	 *		target group or directly, but not both.
	 */

	var AnimationObjectGroup = /*#__PURE__*/function () {
		function AnimationObjectGroup() {
			this.uuid = generateUUID(); // cached objects followed by the active ones

			this._objects = Array.prototype.slice.call(arguments);
			this.nCachedObjects_ = 0; // threshold
			// note: read by PropertyBinding.Composite

			var indices = {};
			this._indicesByUUID = indices; // for bookkeeping

			for (var i = 0, n = arguments.length; i !== n; ++i) {
				indices[arguments[i].uuid] = i;
			}

			this._paths = []; // inside: string

			this._parsedPaths = []; // inside: { we don't care, here }

			this._bindings = []; // inside: Array< PropertyBinding >

			this._bindingsIndicesByPath = {}; // inside: indices in these arrays

			var scope = this;
			this.stats = {
				objects: {
					get total() {
						return scope._objects.length;
					},

					get inUse() {
						return this.total - scope.nCachedObjects_;
					}

				},

				get bindingsPerObject() {
					return scope._bindings.length;
				}

			};
		}

		var _proto = AnimationObjectGroup.prototype;

		_proto.add = function add() {
			var objects = this._objects,
					indicesByUUID = this._indicesByUUID,
					paths = this._paths,
					parsedPaths = this._parsedPaths,
					bindings = this._bindings,
					nBindings = bindings.length;
			var knownObject = undefined,
					nObjects = objects.length,
					nCachedObjects = this.nCachedObjects_;

			for (var i = 0, n = arguments.length; i !== n; ++i) {
				var object = arguments[i],
						uuid = object.uuid;
				var index = indicesByUUID[uuid];

				if (index === undefined) {
					// unknown object -> add it to the ACTIVE region
					index = nObjects++;
					indicesByUUID[uuid] = index;
					objects.push(object); // accounting is done, now do the same for all bindings

					for (var j = 0, m = nBindings; j !== m; ++j) {
						bindings[j].push(new PropertyBinding(object, paths[j], parsedPaths[j]));
					}
				} else if (index < nCachedObjects) {
					knownObject = objects[index]; // move existing object to the ACTIVE region

					var firstActiveIndex = --nCachedObjects,
							lastCachedObject = objects[firstActiveIndex];
					indicesByUUID[lastCachedObject.uuid] = index;
					objects[index] = lastCachedObject;
					indicesByUUID[uuid] = firstActiveIndex;
					objects[firstActiveIndex] = object; // accounting is done, now do the same for all bindings

					for (var _j = 0, _m = nBindings; _j !== _m; ++_j) {
						var bindingsForPath = bindings[_j],
								lastCached = bindingsForPath[firstActiveIndex];
						var binding = bindingsForPath[index];
						bindingsForPath[index] = lastCached;

						if (binding === undefined) {
							// since we do not bother to create new bindings
							// for objects that are cached, the binding may
							// or may not exist
							binding = new PropertyBinding(object, paths[_j], parsedPaths[_j]);
						}

						bindingsForPath[firstActiveIndex] = binding;
					}
				} else if (objects[index] !== knownObject) {
					console.error('THREE.AnimationObjectGroup: Different objects with the same UUID ' + 'detected. Clean the caches or recreate your infrastructure when reloading scenes.');
				} // else the object is already where we want it to be

			} // for arguments


			this.nCachedObjects_ = nCachedObjects;
		};

		_proto.remove = function remove() {
			var objects = this._objects,
					indicesByUUID = this._indicesByUUID,
					bindings = this._bindings,
					nBindings = bindings.length;
			var nCachedObjects = this.nCachedObjects_;

			for (var i = 0, n = arguments.length; i !== n; ++i) {
				var object = arguments[i],
						uuid = object.uuid,
						index = indicesByUUID[uuid];

				if (index !== undefined && index >= nCachedObjects) {
					// move existing object into the CACHED region
					var lastCachedIndex = nCachedObjects++,
							firstActiveObject = objects[lastCachedIndex];
					indicesByUUID[firstActiveObject.uuid] = index;
					objects[index] = firstActiveObject;
					indicesByUUID[uuid] = lastCachedIndex;
					objects[lastCachedIndex] = object; // accounting is done, now do the same for all bindings

					for (var j = 0, m = nBindings; j !== m; ++j) {
						var bindingsForPath = bindings[j],
								firstActive = bindingsForPath[lastCachedIndex],
								binding = bindingsForPath[index];
						bindingsForPath[index] = firstActive;
						bindingsForPath[lastCachedIndex] = binding;
					}
				}
			} // for arguments


			this.nCachedObjects_ = nCachedObjects;
		} // remove & forget
		;

		_proto.uncache = function uncache() {
			var objects = this._objects,
					indicesByUUID = this._indicesByUUID,
					bindings = this._bindings,
					nBindings = bindings.length;
			var nCachedObjects = this.nCachedObjects_,
					nObjects = objects.length;

			for (var i = 0, n = arguments.length; i !== n; ++i) {
				var object = arguments[i],
						uuid = object.uuid,
						index = indicesByUUID[uuid];

				if (index !== undefined) {
					delete indicesByUUID[uuid];

					if (index < nCachedObjects) {
						// object is cached, shrink the CACHED region
						var firstActiveIndex = --nCachedObjects,
								lastCachedObject = objects[firstActiveIndex],
								lastIndex = --nObjects,
								lastObject = objects[lastIndex]; // last cached object takes this object's place

						indicesByUUID[lastCachedObject.uuid] = index;
						objects[index] = lastCachedObject; // last object goes to the activated slot and pop

						indicesByUUID[lastObject.uuid] = firstActiveIndex;
						objects[firstActiveIndex] = lastObject;
						objects.pop(); // accounting is done, now do the same for all bindings

						for (var j = 0, m = nBindings; j !== m; ++j) {
							var bindingsForPath = bindings[j],
									lastCached = bindingsForPath[firstActiveIndex],
									last = bindingsForPath[lastIndex];
							bindingsForPath[index] = lastCached;
							bindingsForPath[firstActiveIndex] = last;
							bindingsForPath.pop();
						}
					} else {
						// object is active, just swap with the last and pop
						var _lastIndex = --nObjects,
								_lastObject = objects[_lastIndex];

						if (_lastIndex > 0) {
							indicesByUUID[_lastObject.uuid] = index;
						}

						objects[index] = _lastObject;
						objects.pop(); // accounting is done, now do the same for all bindings

						for (var _j2 = 0, _m2 = nBindings; _j2 !== _m2; ++_j2) {
							var _bindingsForPath = bindings[_j2];
							_bindingsForPath[index] = _bindingsForPath[_lastIndex];

							_bindingsForPath.pop();
						}
					} // cached or active

				} // if object is known

			} // for arguments


			this.nCachedObjects_ = nCachedObjects;
		} // Internal interface used by befriended PropertyBinding.Composite:
		;

		_proto.subscribe_ = function subscribe_(path, parsedPath) {
			// returns an array of bindings for the given path that is changed
			// according to the contained objects in the group
			var indicesByPath = this._bindingsIndicesByPath;
			var index = indicesByPath[path];
			var bindings = this._bindings;
			if (index !== undefined) return bindings[index];
			var paths = this._paths,
					parsedPaths = this._parsedPaths,
					objects = this._objects,
					nObjects = objects.length,
					nCachedObjects = this.nCachedObjects_,
					bindingsForPath = new Array(nObjects);
			index = bindings.length;
			indicesByPath[path] = index;
			paths.push(path);
			parsedPaths.push(parsedPath);
			bindings.push(bindingsForPath);

			for (var i = nCachedObjects, n = objects.length; i !== n; ++i) {
				var object = objects[i];
				bindingsForPath[i] = new PropertyBinding(object, path, parsedPath);
			}

			return bindingsForPath;
		};

		_proto.unsubscribe_ = function unsubscribe_(path) {
			// tells the group to forget about a property path and no longer
			// update the array previously obtained with 'subscribe_'
			var indicesByPath = this._bindingsIndicesByPath,
					index = indicesByPath[path];

			if (index !== undefined) {
				var paths = this._paths,
						parsedPaths = this._parsedPaths,
						bindings = this._bindings,
						lastBindingsIndex = bindings.length - 1,
						lastBindings = bindings[lastBindingsIndex],
						lastBindingsPath = path[lastBindingsIndex];
				indicesByPath[lastBindingsPath] = index;
				bindings[index] = lastBindings;
				bindings.pop();
				parsedPaths[index] = parsedPaths[lastBindingsIndex];
				parsedPaths.pop();
				paths[index] = paths[lastBindingsIndex];
				paths.pop();
			}
		};

		return AnimationObjectGroup;
	}();

	AnimationObjectGroup.prototype.isAnimationObjectGroup = true;

	var AnimationAction = /*#__PURE__*/function () {
		function AnimationAction(mixer, clip, localRoot, blendMode) {
			if (localRoot === void 0) {
				localRoot = null;
			}

			if (blendMode === void 0) {
				blendMode = clip.blendMode;
			}

			this._mixer = mixer;
			this._clip = clip;
			this._localRoot = localRoot;
			this.blendMode = blendMode;
			var tracks = clip.tracks,
					nTracks = tracks.length,
					interpolants = new Array(nTracks);
			var interpolantSettings = {
				endingStart: ZeroCurvatureEnding,
				endingEnd: ZeroCurvatureEnding
			};

			for (var i = 0; i !== nTracks; ++i) {
				var interpolant = tracks[i].createInterpolant(null);
				interpolants[i] = interpolant;
				interpolant.settings = interpolantSettings;
			}

			this._interpolantSettings = interpolantSettings;
			this._interpolants = interpolants; // bound by the mixer
			// inside: PropertyMixer (managed by the mixer)

			this._propertyBindings = new Array(nTracks);
			this._cacheIndex = null; // for the memory manager

			this._byClipCacheIndex = null; // for the memory manager

			this._timeScaleInterpolant = null;
			this._weightInterpolant = null;
			this.loop = LoopRepeat;
			this._loopCount = -1; // global mixer time when the action is to be started
			// it's set back to 'null' upon start of the action

			this._startTime = null; // scaled local time of the action
			// gets clamped or wrapped to 0..clip.duration according to loop

			this.time = 0;
			this.timeScale = 1;
			this._effectiveTimeScale = 1;
			this.weight = 1;
			this._effectiveWeight = 1;
			this.repetitions = Infinity; // no. of repetitions when looping

			this.paused = false; // true -> zero effective time scale

			this.enabled = true; // false -> zero effective weight

			this.clampWhenFinished = false; // keep feeding the last frame?

			this.zeroSlopeAtStart = true; // for smooth interpolation w/o separate

			this.zeroSlopeAtEnd = true; // clips for start, loop and end
		} // State & Scheduling


		var _proto = AnimationAction.prototype;

		_proto.play = function play() {
			this._mixer._activateAction(this);

			return this;
		};

		_proto.stop = function stop() {
			this._mixer._deactivateAction(this);

			return this.reset();
		};

		_proto.reset = function reset() {
			this.paused = false;
			this.enabled = true;
			this.time = 0; // restart clip

			this._loopCount = -1; // forget previous loops

			this._startTime = null; // forget scheduling

			return this.stopFading().stopWarping();
		};

		_proto.isRunning = function isRunning() {
			return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this);
		} // return true when play has been called
		;

		_proto.isScheduled = function isScheduled() {
			return this._mixer._isActiveAction(this);
		};

		_proto.startAt = function startAt(time) {
			this._startTime = time;
			return this;
		};

		_proto.setLoop = function setLoop(mode, repetitions) {
			this.loop = mode;
			this.repetitions = repetitions;
			return this;
		} // Weight
		// set the weight stopping any scheduled fading
		// although .enabled = false yields an effective weight of zero, this
		// method does *not* change .enabled, because it would be confusing
		;

		_proto.setEffectiveWeight = function setEffectiveWeight(weight) {
			this.weight = weight; // note: same logic as when updated at runtime

			this._effectiveWeight = this.enabled ? weight : 0;
			return this.stopFading();
		} // return the weight considering fading and .enabled
		;

		_proto.getEffectiveWeight = function getEffectiveWeight() {
			return this._effectiveWeight;
		};

		_proto.fadeIn = function fadeIn(duration) {
			return this._scheduleFading(duration, 0, 1);
		};

		_proto.fadeOut = function fadeOut(duration) {
			return this._scheduleFading(duration, 1, 0);
		};

		_proto.crossFadeFrom = function crossFadeFrom(fadeOutAction, duration, warp) {
			fadeOutAction.fadeOut(duration);
			this.fadeIn(duration);

			if (warp) {
				var fadeInDuration = this._clip.duration,
						fadeOutDuration = fadeOutAction._clip.duration,
						startEndRatio = fadeOutDuration / fadeInDuration,
						endStartRatio = fadeInDuration / fadeOutDuration;
				fadeOutAction.warp(1.0, startEndRatio, duration);
				this.warp(endStartRatio, 1.0, duration);
			}

			return this;
		};

		_proto.crossFadeTo = function crossFadeTo(fadeInAction, duration, warp) {
			return fadeInAction.crossFadeFrom(this, duration, warp);
		};

		_proto.stopFading = function stopFading() {
			var weightInterpolant = this._weightInterpolant;

			if (weightInterpolant !== null) {
				this._weightInterpolant = null;

				this._mixer._takeBackControlInterpolant(weightInterpolant);
			}

			return this;
		} // Time Scale Control
		// set the time scale stopping any scheduled warping
		// although .paused = true yields an effective time scale of zero, this
		// method does *not* change .paused, because it would be confusing
		;

		_proto.setEffectiveTimeScale = function setEffectiveTimeScale(timeScale) {
			this.timeScale = timeScale;
			this._effectiveTimeScale = this.paused ? 0 : timeScale;
			return this.stopWarping();
		} // return the time scale considering warping and .paused
		;

		_proto.getEffectiveTimeScale = function getEffectiveTimeScale() {
			return this._effectiveTimeScale;
		};

		_proto.setDuration = function setDuration(duration) {
			this.timeScale = this._clip.duration / duration;
			return this.stopWarping();
		};

		_proto.syncWith = function syncWith(action) {
			this.time = action.time;
			this.timeScale = action.timeScale;
			return this.stopWarping();
		};

		_proto.halt = function halt(duration) {
			return this.warp(this._effectiveTimeScale, 0, duration);
		};

		_proto.warp = function warp(startTimeScale, endTimeScale, duration) {
			var mixer = this._mixer,
					now = mixer.time,
					timeScale = this.timeScale;
			var interpolant = this._timeScaleInterpolant;

			if (interpolant === null) {
				interpolant = mixer._lendControlInterpolant();
				this._timeScaleInterpolant = interpolant;
			}

			var times = interpolant.parameterPositions,
					values = interpolant.sampleValues;
			times[0] = now;
			times[1] = now + duration;
			values[0] = startTimeScale / timeScale;
			values[1] = endTimeScale / timeScale;
			return this;
		};

		_proto.stopWarping = function stopWarping() {
			var timeScaleInterpolant = this._timeScaleInterpolant;

			if (timeScaleInterpolant !== null) {
				this._timeScaleInterpolant = null;

				this._mixer._takeBackControlInterpolant(timeScaleInterpolant);
			}

			return this;
		} // Object Accessors
		;

		_proto.getMixer = function getMixer() {
			return this._mixer;
		};

		_proto.getClip = function getClip() {
			return this._clip;
		};

		_proto.getRoot = function getRoot() {
			return this._localRoot || this._mixer._root;
		} // Interna
		;

		_proto._update = function _update(time, deltaTime, timeDirection, accuIndex) {
			// called by the mixer
			if (!this.enabled) {
				// call ._updateWeight() to update ._effectiveWeight
				this._updateWeight(time);

				return;
			}

			var startTime = this._startTime;

			if (startTime !== null) {
				// check for scheduled start of action
				var timeRunning = (time - startTime) * timeDirection;

				if (timeRunning < 0 || timeDirection === 0) {
					return; // yet to come / don't decide when delta = 0
				} // start


				this._startTime = null; // unschedule

				deltaTime = timeDirection * timeRunning;
			} // apply time scale and advance time


			deltaTime *= this._updateTimeScale(time);

			var clipTime = this._updateTime(deltaTime); // note: _updateTime may disable the action resulting in
			// an effective weight of 0


			var weight = this._updateWeight(time);

			if (weight > 0) {
				var _interpolants = this._interpolants;
				var propertyMixers = this._propertyBindings;

				switch (this.blendMode) {
					case AdditiveAnimationBlendMode:
						for (var j = 0, m = _interpolants.length; j !== m; ++j) {
							_interpolants[j].evaluate(clipTime);

							propertyMixers[j].accumulateAdditive(weight);
						}

						break;

					case NormalAnimationBlendMode:
					default:
						for (var _j = 0, _m = _interpolants.length; _j !== _m; ++_j) {
							_interpolants[_j].evaluate(clipTime);

							propertyMixers[_j].accumulate(accuIndex, weight);
						}

				}
			}
		};

		_proto._updateWeight = function _updateWeight(time) {
			var weight = 0;

			if (this.enabled) {
				weight = this.weight;
				var interpolant = this._weightInterpolant;

				if (interpolant !== null) {
					var interpolantValue = interpolant.evaluate(time)[0];
					weight *= interpolantValue;

					if (time > interpolant.parameterPositions[1]) {
						this.stopFading();

						if (interpolantValue === 0) {
							// faded out, disable
							this.enabled = false;
						}
					}
				}
			}

			this._effectiveWeight = weight;
			return weight;
		};

		_proto._updateTimeScale = function _updateTimeScale(time) {
			var timeScale = 0;

			if (!this.paused) {
				timeScale = this.timeScale;
				var interpolant = this._timeScaleInterpolant;

				if (interpolant !== null) {
					var interpolantValue = interpolant.evaluate(time)[0];
					timeScale *= interpolantValue;

					if (time > interpolant.parameterPositions[1]) {
						this.stopWarping();

						if (timeScale === 0) {
							// motion has halted, pause
							this.paused = true;
						} else {
							// warp done - apply final time scale
							this.timeScale = timeScale;
						}
					}
				}
			}

			this._effectiveTimeScale = timeScale;
			return timeScale;
		};

		_proto._updateTime = function _updateTime(deltaTime) {
			var duration = this._clip.duration;
			var loop = this.loop;
			var time = this.time + deltaTime;
			var loopCount = this._loopCount;
			var pingPong = loop === LoopPingPong;

			if (deltaTime === 0) {
				if (loopCount === -1) return time;
				return pingPong && (loopCount & 1) === 1 ? duration - time : time;
			}

			if (loop === LoopOnce) {
				if (loopCount === -1) {
					// just started
					this._loopCount = 0;

					this._setEndings(true, true, false);
				}

				handle_stop: {
					if (time >= duration) {
						time = duration;
					} else if (time < 0) {
						time = 0;
					} else {
						this.time = time;
						break handle_stop;
					}

					if (this.clampWhenFinished) this.paused = true;else this.enabled = false;
					this.time = time;

					this._mixer.dispatchEvent({
						type: 'finished',
						action: this,
						direction: deltaTime < 0 ? -1 : 1
					});
				}
			} else {
				// repetitive Repeat or PingPong
				if (loopCount === -1) {
					// just started
					if (deltaTime >= 0) {
						loopCount = 0;

						this._setEndings(true, this.repetitions === 0, pingPong);
					} else {
						// when looping in reverse direction, the initial
						// transition through zero counts as a repetition,
						// so leave loopCount at -1
						this._setEndings(this.repetitions === 0, true, pingPong);
					}
				}

				if (time >= duration || time < 0) {
					// wrap around
					var loopDelta = Math.floor(time / duration); // signed

					time -= duration * loopDelta;
					loopCount += Math.abs(loopDelta);
					var pending = this.repetitions - loopCount;

					if (pending <= 0) {
						// have to stop (switch state, clamp time, fire event)
						if (this.clampWhenFinished) this.paused = true;else this.enabled = false;
						time = deltaTime > 0 ? duration : 0;
						this.time = time;

						this._mixer.dispatchEvent({
							type: 'finished',
							action: this,
							direction: deltaTime > 0 ? 1 : -1
						});
					} else {
						// keep running
						if (pending === 1) {
							// entering the last round
							var atStart = deltaTime < 0;

							this._setEndings(atStart, !atStart, pingPong);
						} else {
							this._setEndings(false, false, pingPong);
						}

						this._loopCount = loopCount;
						this.time = time;

						this._mixer.dispatchEvent({
							type: 'loop',
							action: this,
							loopDelta: loopDelta
						});
					}
				} else {
					this.time = time;
				}

				if (pingPong && (loopCount & 1) === 1) {
					// invert time for the "pong round"
					return duration - time;
				}
			}

			return time;
		};

		_proto._setEndings = function _setEndings(atStart, atEnd, pingPong) {
			var settings = this._interpolantSettings;

			if (pingPong) {
				settings.endingStart = ZeroSlopeEnding;
				settings.endingEnd = ZeroSlopeEnding;
			} else {
				// assuming for LoopOnce atStart == atEnd == true
				if (atStart) {
					settings.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding;
				} else {
					settings.endingStart = WrapAroundEnding;
				}

				if (atEnd) {
					settings.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding;
				} else {
					settings.endingEnd = WrapAroundEnding;
				}
			}
		};

		_proto._scheduleFading = function _scheduleFading(duration, weightNow, weightThen) {
			var mixer = this._mixer,
					now = mixer.time;
			var interpolant = this._weightInterpolant;

			if (interpolant === null) {
				interpolant = mixer._lendControlInterpolant();
				this._weightInterpolant = interpolant;
			}

			var times = interpolant.parameterPositions,
					values = interpolant.sampleValues;
			times[0] = now;
			values[0] = weightNow;
			times[1] = now + duration;
			values[1] = weightThen;
			return this;
		};

		return AnimationAction;
	}();

	var AnimationMixer = /*#__PURE__*/function (_EventDispatcher) {
		_inheritsLoose(AnimationMixer, _EventDispatcher);

		function AnimationMixer(root) {
			var _this;

			_this = _EventDispatcher.call(this) || this;
			_this._root = root;

			_this._initMemoryManager();

			_this._accuIndex = 0;
			_this.time = 0;
			_this.timeScale = 1.0;
			return _this;
		}

		var _proto = AnimationMixer.prototype;

		_proto._bindAction = function _bindAction(action, prototypeAction) {
			var root = action._localRoot || this._root,
					tracks = action._clip.tracks,
					nTracks = tracks.length,
					bindings = action._propertyBindings,
					interpolants = action._interpolants,
					rootUuid = root.uuid,
					bindingsByRoot = this._bindingsByRootAndName;
			var bindingsByName = bindingsByRoot[rootUuid];

			if (bindingsByName === undefined) {
				bindingsByName = {};
				bindingsByRoot[rootUuid] = bindingsByName;
			}

			for (var i = 0; i !== nTracks; ++i) {
				var track = tracks[i],
						trackName = track.name;
				var binding = bindingsByName[trackName];

				if (binding !== undefined) {
					bindings[i] = binding;
				} else {
					binding = bindings[i];

					if (binding !== undefined) {
						// existing binding, make sure the cache knows
						if (binding._cacheIndex === null) {
							++binding.referenceCount;

							this._addInactiveBinding(binding, rootUuid, trackName);
						}

						continue;
					}

					var path = prototypeAction && prototypeAction._propertyBindings[i].binding.parsedPath;
					binding = new PropertyMixer(PropertyBinding.create(root, trackName, path), track.ValueTypeName, track.getValueSize());
					++binding.referenceCount;

					this._addInactiveBinding(binding, rootUuid, trackName);

					bindings[i] = binding;
				}

				interpolants[i].resultBuffer = binding.buffer;
			}
		};

		_proto._activateAction = function _activateAction(action) {
			if (!this._isActiveAction(action)) {
				if (action._cacheIndex === null) {
					// this action has been forgotten by the cache, but the user
					// appears to be still using it -> rebind
					var rootUuid = (action._localRoot || this._root).uuid,
							clipUuid = action._clip.uuid,
							actionsForClip = this._actionsByClip[clipUuid];

					this._bindAction(action, actionsForClip && actionsForClip.knownActions[0]);

					this._addInactiveAction(action, clipUuid, rootUuid);
				}

				var bindings = action._propertyBindings; // increment reference counts / sort out state

				for (var i = 0, n = bindings.length; i !== n; ++i) {
					var binding = bindings[i];

					if (binding.useCount++ === 0) {
						this._lendBinding(binding);

						binding.saveOriginalState();
					}
				}

				this._lendAction(action);
			}
		};

		_proto._deactivateAction = function _deactivateAction(action) {
			if (this._isActiveAction(action)) {
				var bindings = action._propertyBindings; // decrement reference counts / sort out state

				for (var i = 0, n = bindings.length; i !== n; ++i) {
					var binding = bindings[i];

					if (--binding.useCount === 0) {
						binding.restoreOriginalState();

						this._takeBackBinding(binding);
					}
				}

				this._takeBackAction(action);
			}
		} // Memory manager
		;

		_proto._initMemoryManager = function _initMemoryManager() {
			this._actions = []; // 'nActiveActions' followed by inactive ones

			this._nActiveActions = 0;
			this._actionsByClip = {}; // inside:
			// {
			// 	knownActions: Array< AnimationAction > - used as prototypes
			// 	actionByRoot: AnimationAction - lookup
			// }

			this._bindings = []; // 'nActiveBindings' followed by inactive ones

			this._nActiveBindings = 0;
			this._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer >

			this._controlInterpolants = []; // same game as above

			this._nActiveControlInterpolants = 0;
			var scope = this;
			this.stats = {
				actions: {
					get total() {
						return scope._actions.length;
					},

					get inUse() {
						return scope._nActiveActions;
					}

				},
				bindings: {
					get total() {
						return scope._bindings.length;
					},

					get inUse() {
						return scope._nActiveBindings;
					}

				},
				controlInterpolants: {
					get total() {
						return scope._controlInterpolants.length;
					},

					get inUse() {
						return scope._nActiveControlInterpolants;
					}

				}
			};
		} // Memory management for AnimationAction objects
		;

		_proto._isActiveAction = function _isActiveAction(action) {
			var index = action._cacheIndex;
			return index !== null && index < this._nActiveActions;
		};

		_proto._addInactiveAction = function _addInactiveAction(action, clipUuid, rootUuid) {
			var actions = this._actions,
					actionsByClip = this._actionsByClip;
			var actionsForClip = actionsByClip[clipUuid];

			if (actionsForClip === undefined) {
				actionsForClip = {
					knownActions: [action],
					actionByRoot: {}
				};
				action._byClipCacheIndex = 0;
				actionsByClip[clipUuid] = actionsForClip;
			} else {
				var knownActions = actionsForClip.knownActions;
				action._byClipCacheIndex = knownActions.length;
				knownActions.push(action);
			}

			action._cacheIndex = actions.length;
			actions.push(action);
			actionsForClip.actionByRoot[rootUuid] = action;
		};

		_proto._removeInactiveAction = function _removeInactiveAction(action) {
			var actions = this._actions,
					lastInactiveAction = actions[actions.length - 1],
					cacheIndex = action._cacheIndex;
			lastInactiveAction._cacheIndex = cacheIndex;
			actions[cacheIndex] = lastInactiveAction;
			actions.pop();
			action._cacheIndex = null;
			var clipUuid = action._clip.uuid,
					actionsByClip = this._actionsByClip,
					actionsForClip = actionsByClip[clipUuid],
					knownActionsForClip = actionsForClip.knownActions,
					lastKnownAction = knownActionsForClip[knownActionsForClip.length - 1],
					byClipCacheIndex = action._byClipCacheIndex;
			lastKnownAction._byClipCacheIndex = byClipCacheIndex;
			knownActionsForClip[byClipCacheIndex] = lastKnownAction;
			knownActionsForClip.pop();
			action._byClipCacheIndex = null;
			var actionByRoot = actionsForClip.actionByRoot,
					rootUuid = (action._localRoot || this._root).uuid;
			delete actionByRoot[rootUuid];

			if (knownActionsForClip.length === 0) {
				delete actionsByClip[clipUuid];
			}

			this._removeInactiveBindingsForAction(action);
		};

		_proto._removeInactiveBindingsForAction = function _removeInactiveBindingsForAction(action) {
			var bindings = action._propertyBindings;

			for (var i = 0, n = bindings.length; i !== n; ++i) {
				var binding = bindings[i];

				if (--binding.referenceCount === 0) {
					this._removeInactiveBinding(binding);
				}
			}
		};

		_proto._lendAction = function _lendAction(action) {
			// [ active actions |	inactive actions	]
			// [	active actions >| inactive actions ]
			//								 s				a
			//									<-swap->
			//								 a				s
			var actions = this._actions,
					prevIndex = action._cacheIndex,
					lastActiveIndex = this._nActiveActions++,
					firstInactiveAction = actions[lastActiveIndex];
			action._cacheIndex = lastActiveIndex;
			actions[lastActiveIndex] = action;
			firstInactiveAction._cacheIndex = prevIndex;
			actions[prevIndex] = firstInactiveAction;
		};

		_proto._takeBackAction = function _takeBackAction(action) {
			// [	active actions	| inactive actions ]
			// [ active actions |< inactive actions	]
			//				a				s
			//				 <-swap->
			//				s				a
			var actions = this._actions,
					prevIndex = action._cacheIndex,
					firstInactiveIndex = --this._nActiveActions,
					lastActiveAction = actions[firstInactiveIndex];
			action._cacheIndex = firstInactiveIndex;
			actions[firstInactiveIndex] = action;
			lastActiveAction._cacheIndex = prevIndex;
			actions[prevIndex] = lastActiveAction;
		} // Memory management for PropertyMixer objects
		;

		_proto._addInactiveBinding = function _addInactiveBinding(binding, rootUuid, trackName) {
			var bindingsByRoot = this._bindingsByRootAndName,
					bindings = this._bindings;
			var bindingByName = bindingsByRoot[rootUuid];

			if (bindingByName === undefined) {
				bindingByName = {};
				bindingsByRoot[rootUuid] = bindingByName;
			}

			bindingByName[trackName] = binding;
			binding._cacheIndex = bindings.length;
			bindings.push(binding);
		};

		_proto._removeInactiveBinding = function _removeInactiveBinding(binding) {
			var bindings = this._bindings,
					propBinding = binding.binding,
					rootUuid = propBinding.rootNode.uuid,
					trackName = propBinding.path,
					bindingsByRoot = this._bindingsByRootAndName,
					bindingByName = bindingsByRoot[rootUuid],
					lastInactiveBinding = bindings[bindings.length - 1],
					cacheIndex = binding._cacheIndex;
			lastInactiveBinding._cacheIndex = cacheIndex;
			bindings[cacheIndex] = lastInactiveBinding;
			bindings.pop();
			delete bindingByName[trackName];

			if (Object.keys(bindingByName).length === 0) {
				delete bindingsByRoot[rootUuid];
			}
		};

		_proto._lendBinding = function _lendBinding(binding) {
			var bindings = this._bindings,
					prevIndex = binding._cacheIndex,
					lastActiveIndex = this._nActiveBindings++,
					firstInactiveBinding = bindings[lastActiveIndex];
			binding._cacheIndex = lastActiveIndex;
			bindings[lastActiveIndex] = binding;
			firstInactiveBinding._cacheIndex = prevIndex;
			bindings[prevIndex] = firstInactiveBinding;
		};

		_proto._takeBackBinding = function _takeBackBinding(binding) {
			var bindings = this._bindings,
					prevIndex = binding._cacheIndex,
					firstInactiveIndex = --this._nActiveBindings,
					lastActiveBinding = bindings[firstInactiveIndex];
			binding._cacheIndex = firstInactiveIndex;
			bindings[firstInactiveIndex] = binding;
			lastActiveBinding._cacheIndex = prevIndex;
			bindings[prevIndex] = lastActiveBinding;
		} // Memory management of Interpolants for weight and time scale
		;

		_proto._lendControlInterpolant = function _lendControlInterpolant() {
			var interpolants = this._controlInterpolants,
					lastActiveIndex = this._nActiveControlInterpolants++;
			var interpolant = interpolants[lastActiveIndex];

			if (interpolant === undefined) {
				interpolant = new LinearInterpolant(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer);
				interpolant.__cacheIndex = lastActiveIndex;
				interpolants[lastActiveIndex] = interpolant;
			}

			return interpolant;
		};

		_proto._takeBackControlInterpolant = function _takeBackControlInterpolant(interpolant) {
			var interpolants = this._controlInterpolants,
					prevIndex = interpolant.__cacheIndex,
					firstInactiveIndex = --this._nActiveControlInterpolants,
					lastActiveInterpolant = interpolants[firstInactiveIndex];
			interpolant.__cacheIndex = firstInactiveIndex;
			interpolants[firstInactiveIndex] = interpolant;
			lastActiveInterpolant.__cacheIndex = prevIndex;
			interpolants[prevIndex] = lastActiveInterpolant;
		} // return an action for a clip optionally using a custom root target
		// object (this method allocates a lot of dynamic memory in case a
		// previously unknown clip/root combination is specified)
		;

		_proto.clipAction = function clipAction(clip, optionalRoot, blendMode) {
			var root = optionalRoot || this._root,
					rootUuid = root.uuid;
			var clipObject = typeof clip === 'string' ? AnimationClip.findByName(root, clip) : clip;
			var clipUuid = clipObject !== null ? clipObject.uuid : clip;
			var actionsForClip = this._actionsByClip[clipUuid];
			var prototypeAction = null;

			if (blendMode === undefined) {
				if (clipObject !== null) {
					blendMode = clipObject.blendMode;
				} else {
					blendMode = NormalAnimationBlendMode;
				}
			}

			if (actionsForClip !== undefined) {
				var existingAction = actionsForClip.actionByRoot[rootUuid];

				if (existingAction !== undefined && existingAction.blendMode === blendMode) {
					return existingAction;
				} // we know the clip, so we don't have to parse all
				// the bindings again but can just copy


				prototypeAction = actionsForClip.knownActions[0]; // also, take the clip from the prototype action

				if (clipObject === null) clipObject = prototypeAction._clip;
			} // clip must be known when specified via string


			if (clipObject === null) return null; // allocate all resources required to run it

			var newAction = new AnimationAction(this, clipObject, optionalRoot, blendMode);

			this._bindAction(newAction, prototypeAction); // and make the action known to the memory manager


			this._addInactiveAction(newAction, clipUuid, rootUuid);

			return newAction;
		} // get an existing action
		;

		_proto.existingAction = function existingAction(clip, optionalRoot) {
			var root = optionalRoot || this._root,
					rootUuid = root.uuid,
					clipObject = typeof clip === 'string' ? AnimationClip.findByName(root, clip) : clip,
					clipUuid = clipObject ? clipObject.uuid : clip,
					actionsForClip = this._actionsByClip[clipUuid];

			if (actionsForClip !== undefined) {
				return actionsForClip.actionByRoot[rootUuid] || null;
			}

			return null;
		} // deactivates all previously scheduled actions
		;

		_proto.stopAllAction = function stopAllAction() {
			var actions = this._actions,
					nActions = this._nActiveActions;

			for (var i = nActions - 1; i >= 0; --i) {
				actions[i].stop();
			}

			return this;
		} // advance the time and update apply the animation
		;

		_proto.update = function update(deltaTime) {
			deltaTime *= this.timeScale;
			var actions = this._actions,
					nActions = this._nActiveActions,
					time = this.time += deltaTime,
					timeDirection = Math.sign(deltaTime),
					accuIndex = this._accuIndex ^= 1; // run active actions

			for (var i = 0; i !== nActions; ++i) {
				var action = actions[i];

				action._update(time, deltaTime, timeDirection, accuIndex);
			} // update scene graph


			var bindings = this._bindings,
					nBindings = this._nActiveBindings;

			for (var _i = 0; _i !== nBindings; ++_i) {
				bindings[_i].apply(accuIndex);
			}

			return this;
		} // Allows you to seek to a specific time in an animation.
		;

		_proto.setTime = function setTime(timeInSeconds) {
			this.time = 0; // Zero out time attribute for AnimationMixer object;

			for (var i = 0; i < this._actions.length; i++) {
				this._actions[i].time = 0; // Zero out time attribute for all associated AnimationAction objects.
			}

			return this.update(timeInSeconds); // Update used to set exact time. Returns "this" AnimationMixer object.
		} // return this mixer's root target object
		;

		_proto.getRoot = function getRoot() {
			return this._root;
		} // free all resources specific to a particular clip
		;

		_proto.uncacheClip = function uncacheClip(clip) {
			var actions = this._actions,
					clipUuid = clip.uuid,
					actionsByClip = this._actionsByClip,
					actionsForClip = actionsByClip[clipUuid];

			if (actionsForClip !== undefined) {
				// note: just calling _removeInactiveAction would mess up the
				// iteration state and also require updating the state we can
				// just throw away
				var actionsToRemove = actionsForClip.knownActions;

				for (var i = 0, n = actionsToRemove.length; i !== n; ++i) {
					var action = actionsToRemove[i];

					this._deactivateAction(action);

					var cacheIndex = action._cacheIndex,
							lastInactiveAction = actions[actions.length - 1];
					action._cacheIndex = null;
					action._byClipCacheIndex = null;
					lastInactiveAction._cacheIndex = cacheIndex;
					actions[cacheIndex] = lastInactiveAction;
					actions.pop();

					this._removeInactiveBindingsForAction(action);
				}

				delete actionsByClip[clipUuid];
			}
		} // free all resources specific to a particular root target object
		;

		_proto.uncacheRoot = function uncacheRoot(root) {
			var rootUuid = root.uuid,
					actionsByClip = this._actionsByClip;

			for (var clipUuid in actionsByClip) {
				var actionByRoot = actionsByClip[clipUuid].actionByRoot,
						action = actionByRoot[rootUuid];

				if (action !== undefined) {
					this._deactivateAction(action);

					this._removeInactiveAction(action);
				}
			}

			var bindingsByRoot = this._bindingsByRootAndName,
					bindingByName = bindingsByRoot[rootUuid];

			if (bindingByName !== undefined) {
				for (var trackName in bindingByName) {
					var binding = bindingByName[trackName];
					binding.restoreOriginalState();

					this._removeInactiveBinding(binding);
				}
			}
		} // remove a targeted clip from the cache
		;

		_proto.uncacheAction = function uncacheAction(clip, optionalRoot) {
			var action = this.existingAction(clip, optionalRoot);

			if (action !== null) {
				this._deactivateAction(action);

				this._removeInactiveAction(action);
			}
		};

		return AnimationMixer;
	}(EventDispatcher);

	AnimationMixer.prototype._controlInterpolantsResultBuffer = new Float32Array(1);

	var Uniform = /*#__PURE__*/function () {
		function Uniform(value) {
			if (typeof value === 'string') {
				console.warn('THREE.Uniform: Type parameter is no longer needed.');
				value = arguments[1];
			}

			this.value = value;
		}

		var _proto = Uniform.prototype;

		_proto.clone = function clone() {
			return new Uniform(this.value.clone === undefined ? this.value : this.value.clone());
		};

		return Uniform;
	}();

	var InstancedInterleavedBuffer = /*#__PURE__*/function (_InterleavedBuffer) {
		_inheritsLoose(InstancedInterleavedBuffer, _InterleavedBuffer);

		function InstancedInterleavedBuffer(array, stride, meshPerAttribute) {
			var _this;

			if (meshPerAttribute === void 0) {
				meshPerAttribute = 1;
			}

			_this = _InterleavedBuffer.call(this, array, stride) || this;
			_this.meshPerAttribute = meshPerAttribute;
			return _this;
		}

		var _proto = InstancedInterleavedBuffer.prototype;

		_proto.copy = function copy(source) {
			_InterleavedBuffer.prototype.copy.call(this, source);

			this.meshPerAttribute = source.meshPerAttribute;
			return this;
		};

		_proto.clone = function clone(data) {
			var ib = _InterleavedBuffer.prototype.clone.call(this, data);

			ib.meshPerAttribute = this.meshPerAttribute;
			return ib;
		};

		_proto.toJSON = function toJSON(data) {
			var json = _InterleavedBuffer.prototype.toJSON.call(this, data);

			json.isInstancedInterleavedBuffer = true;
			json.meshPerAttribute = this.meshPerAttribute;
			return json;
		};

		return InstancedInterleavedBuffer;
	}(InterleavedBuffer);

	InstancedInterleavedBuffer.prototype.isInstancedInterleavedBuffer = true;

	var GLBufferAttribute = /*#__PURE__*/function () {
		function GLBufferAttribute(buffer, type, itemSize, elementSize, count) {
			this.buffer = buffer;
			this.type = type;
			this.itemSize = itemSize;
			this.elementSize = elementSize;
			this.count = count;
			this.version = 0;
		}

		var _proto = GLBufferAttribute.prototype;

		_proto.setBuffer = function setBuffer(buffer) {
			this.buffer = buffer;
			return this;
		};

		_proto.setType = function setType(type, elementSize) {
			this.type = type;
			this.elementSize = elementSize;
			return this;
		};

		_proto.setItemSize = function setItemSize(itemSize) {
			this.itemSize = itemSize;
			return this;
		};

		_proto.setCount = function setCount(count) {
			this.count = count;
			return this;
		};

		_createClass(GLBufferAttribute, [{
			key: "needsUpdate",
			set: function set(value) {
				if (value === true) this.version++;
			}
		}]);

		return GLBufferAttribute;
	}();

	GLBufferAttribute.prototype.isGLBufferAttribute = true;

	var Raycaster = /*#__PURE__*/function () {
		function Raycaster(origin, direction, near, far) {
			if (near === void 0) {
				near = 0;
			}

			if (far === void 0) {
				far = Infinity;
			}

			this.ray = new Ray(origin, direction); // direction is assumed to be normalized (for accurate distance calculations)

			this.near = near;
			this.far = far;
			this.camera = null;
			this.layers = new Layers();
			this.params = {
				Mesh: {},
				Line: {
					threshold: 1
				},
				LOD: {},
				Points: {
					threshold: 1
				},
				Sprite: {}
			};
		}

		var _proto = Raycaster.prototype;

		_proto.set = function set(origin, direction) {
			// direction is assumed to be normalized (for accurate distance calculations)
			this.ray.set(origin, direction);
		};

		_proto.setFromCamera = function setFromCamera(coords, camera) {
			if (camera && camera.isPerspectiveCamera) {
				this.ray.origin.setFromMatrixPosition(camera.matrixWorld);
				this.ray.direction.set(coords.x, coords.y, 0.5).unproject(camera).sub(this.ray.origin).normalize();
				this.camera = camera;
			} else if (camera && camera.isOrthographicCamera) {
				this.ray.origin.set(coords.x, coords.y, (camera.near + camera.far) / (camera.near - camera.far)).unproject(camera); // set origin in plane of camera

				this.ray.direction.set(0, 0, -1).transformDirection(camera.matrixWorld);
				this.camera = camera;
			} else {
				console.error('THREE.Raycaster: Unsupported camera type: ' + camera.type);
			}
		};

		_proto.intersectObject = function intersectObject(object, recursive, intersects) {
			if (recursive === void 0) {
				recursive = true;
			}

			if (intersects === void 0) {
				intersects = [];
			}

			_intersectObject(object, this, intersects, recursive);

			intersects.sort(ascSort);
			return intersects;
		};

		_proto.intersectObjects = function intersectObjects(objects, recursive, intersects) {
			if (recursive === void 0) {
				recursive = true;
			}

			if (intersects === void 0) {
				intersects = [];
			}

			for (var i = 0, l = objects.length; i < l; i++) {
				_intersectObject(objects[i], this, intersects, recursive);
			}

			intersects.sort(ascSort);
			return intersects;
		};

		return Raycaster;
	}();

	function ascSort(a, b) {
		return a.distance - b.distance;
	}

	function _intersectObject(object, raycaster, intersects, recursive) {
		if (object.layers.test(raycaster.layers)) {
			object.raycast(raycaster, intersects);
		}

		if (recursive === true) {
			var children = object.children;

			for (var i = 0, l = children.length; i < l; i++) {
				_intersectObject(children[i], raycaster, intersects, true);
			}
		}
	}

	/**
	 * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system
	 *
	 * The polar angle (phi) is measured from the positive y-axis. The positive y-axis is up.
	 * The azimuthal angle (theta) is measured from the positive z-axis.
	 */

	var Spherical = /*#__PURE__*/function () {
		function Spherical(radius, phi, theta) {
			if (radius === void 0) {
				radius = 1;
			}

			if (phi === void 0) {
				phi = 0;
			}

			if (theta === void 0) {
				theta = 0;
			}

			this.radius = radius;
			this.phi = phi; // polar angle

			this.theta = theta; // azimuthal angle

			return this;
		}

		var _proto = Spherical.prototype;

		_proto.set = function set(radius, phi, theta) {
			this.radius = radius;
			this.phi = phi;
			this.theta = theta;
			return this;
		};

		_proto.copy = function copy(other) {
			this.radius = other.radius;
			this.phi = other.phi;
			this.theta = other.theta;
			return this;
		} // restrict phi to be betwee EPS and PI-EPS
		;

		_proto.makeSafe = function makeSafe() {
			var EPS = 0.000001;
			this.phi = Math.max(EPS, Math.min(Math.PI - EPS, this.phi));
			return this;
		};

		_proto.setFromVector3 = function setFromVector3(v) {
			return this.setFromCartesianCoords(v.x, v.y, v.z);
		};

		_proto.setFromCartesianCoords = function setFromCartesianCoords(x, y, z) {
			this.radius = Math.sqrt(x * x + y * y + z * z);

			if (this.radius === 0) {
				this.theta = 0;
				this.phi = 0;
			} else {
				this.theta = Math.atan2(x, z);
				this.phi = Math.acos(clamp(y / this.radius, -1, 1));
			}

			return this;
		};

		_proto.clone = function clone() {
			return new this.constructor().copy(this);
		};

		return Spherical;
	}();

	/**
	 * Ref: https://en.wikipedia.org/wiki/Cylindrical_coordinate_system
	 */
	var Cylindrical = /*#__PURE__*/function () {
		function Cylindrical(radius, theta, y) {
			if (radius === void 0) {
				radius = 1;
			}

			if (theta === void 0) {
				theta = 0;
			}

			if (y === void 0) {
				y = 0;
			}

			this.radius = radius; // distance from the origin to a point in the x-z plane

			this.theta = theta; // counterclockwise angle in the x-z plane measured in radians from the positive z-axis

			this.y = y; // height above the x-z plane

			return this;
		}

		var _proto = Cylindrical.prototype;

		_proto.set = function set(radius, theta, y) {
			this.radius = radius;
			this.theta = theta;
			this.y = y;
			return this;
		};

		_proto.copy = function copy(other) {
			this.radius = other.radius;
			this.theta = other.theta;
			this.y = other.y;
			return this;
		};

		_proto.setFromVector3 = function setFromVector3(v) {
			return this.setFromCartesianCoords(v.x, v.y, v.z);
		};

		_proto.setFromCartesianCoords = function setFromCartesianCoords(x, y, z) {
			this.radius = Math.sqrt(x * x + z * z);
			this.theta = Math.atan2(x, z);
			this.y = y;
			return this;
		};

		_proto.clone = function clone() {
			return new this.constructor().copy(this);
		};

		return Cylindrical;
	}();

	var _vector$8 = /*@__PURE__*/new Vector2();

	var Box2 = /*#__PURE__*/function () {
		function Box2(min, max) {
			if (min === void 0) {
				min = new Vector2(+Infinity, +Infinity);
			}

			if (max === void 0) {
				max = new Vector2(-Infinity, -Infinity);
			}

			this.min = min;
			this.max = max;
		}

		var _proto = Box2.prototype;

		_proto.set = function set(min, max) {
			this.min.copy(min);
			this.max.copy(max);
			return this;
		};

		_proto.setFromPoints = function setFromPoints(points) {
			this.makeEmpty();

			for (var i = 0, il = points.length; i < il; i++) {
				this.expandByPoint(points[i]);
			}

			return this;
		};

		_proto.setFromCenterAndSize = function setFromCenterAndSize(center, size) {
			var halfSize = _vector$8.copy(size).multiplyScalar(0.5);

			this.min.copy(center).sub(halfSize);
			this.max.copy(center).add(halfSize);
			return this;
		};

		_proto.clone = function clone() {
			return new this.constructor().copy(this);
		};

		_proto.copy = function copy(box) {
			this.min.copy(box.min);
			this.max.copy(box.max);
			return this;
		};

		_proto.makeEmpty = function makeEmpty() {
			this.min.x = this.min.y = +Infinity;
			this.max.x = this.max.y = -Infinity;
			return this;
		};

		_proto.isEmpty = function isEmpty() {
			// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes
			return this.max.x < this.min.x || this.max.y < this.min.y;
		};

		_proto.getCenter = function getCenter(target) {
			return this.isEmpty() ? target.set(0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
		};

		_proto.getSize = function getSize(target) {
			return this.isEmpty() ? target.set(0, 0) : target.subVectors(this.max, this.min);
		};

		_proto.expandByPoint = function expandByPoint(point) {
			this.min.min(point);
			this.max.max(point);
			return this;
		};

		_proto.expandByVector = function expandByVector(vector) {
			this.min.sub(vector);
			this.max.add(vector);
			return this;
		};

		_proto.expandByScalar = function expandByScalar(scalar) {
			this.min.addScalar(-scalar);
			this.max.addScalar(scalar);
			return this;
		};

		_proto.containsPoint = function containsPoint(point) {
			return point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y ? false : true;
		};

		_proto.containsBox = function containsBox(box) {
			return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y;
		};

		_proto.getParameter = function getParameter(point, target) {
			// This can potentially have a divide by zero if the box
			// has a size dimension of 0.
			return target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y));
		};

		_proto.intersectsBox = function intersectsBox(box) {
			// using 4 splitting planes to rule out intersections
			return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y ? false : true;
		};

		_proto.clampPoint = function clampPoint(point, target) {
			return target.copy(point).clamp(this.min, this.max);
		};

		_proto.distanceToPoint = function distanceToPoint(point) {
			var clampedPoint = _vector$8.copy(point).clamp(this.min, this.max);

			return clampedPoint.sub(point).length();
		};

		_proto.intersect = function intersect(box) {
			this.min.max(box.min);
			this.max.min(box.max);
			return this;
		};

		_proto.union = function union(box) {
			this.min.min(box.min);
			this.max.max(box.max);
			return this;
		};

		_proto.translate = function translate(offset) {
			this.min.add(offset);
			this.max.add(offset);
			return this;
		};

		_proto.equals = function equals(box) {
			return box.min.equals(this.min) && box.max.equals(this.max);
		};

		return Box2;
	}();

	Box2.prototype.isBox2 = true;

	var _startP = /*@__PURE__*/new Vector3();

	var _startEnd = /*@__PURE__*/new Vector3();

	var Line3 = /*#__PURE__*/function () {
		function Line3(start, end) {
			if (start === void 0) {
				start = new Vector3();
			}

			if (end === void 0) {
				end = new Vector3();
			}

			this.start = start;
			this.end = end;
		}

		var _proto = Line3.prototype;

		_proto.set = function set(start, end) {
			this.start.copy(start);
			this.end.copy(end);
			return this;
		};

		_proto.copy = function copy(line) {
			this.start.copy(line.start);
			this.end.copy(line.end);
			return this;
		};

		_proto.getCenter = function getCenter(target) {
			return target.addVectors(this.start, this.end).multiplyScalar(0.5);
		};

		_proto.delta = function delta(target) {
			return target.subVectors(this.end, this.start);
		};

		_proto.distanceSq = function distanceSq() {
			return this.start.distanceToSquared(this.end);
		};

		_proto.distance = function distance() {
			return this.start.distanceTo(this.end);
		};

		_proto.at = function at(t, target) {
			return this.delta(target).multiplyScalar(t).add(this.start);
		};

		_proto.closestPointToPointParameter = function closestPointToPointParameter(point, clampToLine) {
			_startP.subVectors(point, this.start);

			_startEnd.subVectors(this.end, this.start);

			var startEnd2 = _startEnd.dot(_startEnd);

			var startEnd_startP = _startEnd.dot(_startP);

			var t = startEnd_startP / startEnd2;

			if (clampToLine) {
				t = clamp(t, 0, 1);
			}

			return t;
		};

		_proto.closestPointToPoint = function closestPointToPoint(point, clampToLine, target) {
			var t = this.closestPointToPointParameter(point, clampToLine);
			return this.delta(target).multiplyScalar(t).add(this.start);
		};

		_proto.applyMatrix4 = function applyMatrix4(matrix) {
			this.start.applyMatrix4(matrix);
			this.end.applyMatrix4(matrix);
			return this;
		};

		_proto.equals = function equals(line) {
			return line.start.equals(this.start) && line.end.equals(this.end);
		};

		_proto.clone = function clone() {
			return new this.constructor().copy(this);
		};

		return Line3;
	}();

	var ImmediateRenderObject = /*#__PURE__*/function (_Object3D) {
		_inheritsLoose(ImmediateRenderObject, _Object3D);

		function ImmediateRenderObject(material) {
			var _this;

			_this = _Object3D.call(this) || this;
			_this.material = material;

			_this.render = function ()
			/* renderCallback */
			{};

			_this.hasPositions = false;
			_this.hasNormals = false;
			_this.hasColors = false;
			_this.hasUvs = false;
			_this.positionArray = null;
			_this.normalArray = null;
			_this.colorArray = null;
			_this.uvArray = null;
			_this.count = 0;
			return _this;
		}

		return ImmediateRenderObject;
	}(Object3D);

	ImmediateRenderObject.prototype.isImmediateRenderObject = true;

	var _vector$9 = /*@__PURE__*/new Vector3();

	var SpotLightHelper = /*#__PURE__*/function (_Object3D) {
		_inheritsLoose(SpotLightHelper, _Object3D);

		function SpotLightHelper(light, color) {
			var _this;

			_this = _Object3D.call(this) || this;
			_this.light = light;

			_this.light.updateMatrixWorld();

			_this.matrix = light.matrixWorld;
			_this.matrixAutoUpdate = false;
			_this.color = color;
			var geometry = new BufferGeometry();
			var positions = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1];

			for (var i = 0, j = 1, l = 32; i < l; i++, j++) {
				var p1 = i / l * Math.PI * 2;
				var p2 = j / l * Math.PI * 2;
				positions.push(Math.cos(p1), Math.sin(p1), 1, Math.cos(p2), Math.sin(p2), 1);
			}

			geometry.setAttribute('position', new Float32BufferAttribute(positions, 3));
			var material = new LineBasicMaterial({
				fog: false,
				toneMapped: false
			});
			_this.cone = new LineSegments(geometry, material);

			_this.add(_this.cone);

			_this.update();

			return _this;
		}

		var _proto = SpotLightHelper.prototype;

		_proto.dispose = function dispose() {
			this.cone.geometry.dispose();
			this.cone.material.dispose();
		};

		_proto.update = function update() {
			this.light.updateMatrixWorld();
			var coneLength = this.light.distance ? this.light.distance : 1000;
			var coneWidth = coneLength * Math.tan(this.light.angle);
			this.cone.scale.set(coneWidth, coneWidth, coneLength);

			_vector$9.setFromMatrixPosition(this.light.target.matrixWorld);

			this.cone.lookAt(_vector$9);

			if (this.color !== undefined) {
				this.cone.material.color.set(this.color);
			} else {
				this.cone.material.color.copy(this.light.color);
			}
		};

		return SpotLightHelper;
	}(Object3D);

	var _vector$a = /*@__PURE__*/new Vector3();

	var _boneMatrix = /*@__PURE__*/new Matrix4();

	var _matrixWorldInv = /*@__PURE__*/new Matrix4();

	var SkeletonHelper = /*#__PURE__*/function (_LineSegments) {
		_inheritsLoose(SkeletonHelper, _LineSegments);

		function SkeletonHelper(object) {
			var _this;

			var bones = getBoneList(object);
			var geometry = new BufferGeometry();
			var vertices = [];
			var colors = [];
			var color1 = new Color(0, 0, 1);
			var color2 = new Color(0, 1, 0);

			for (var i = 0; i < bones.length; i++) {
				var bone = bones[i];

				if (bone.parent && bone.parent.isBone) {
					vertices.push(0, 0, 0);
					vertices.push(0, 0, 0);
					colors.push(color1.r, color1.g, color1.b);
					colors.push(color2.r, color2.g, color2.b);
				}
			}

			geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));
			geometry.setAttribute('color', new Float32BufferAttribute(colors, 3));
			var material = new LineBasicMaterial({
				vertexColors: true,
				depthTest: false,
				depthWrite: false,
				toneMapped: false,
				transparent: true
			});
			_this = _LineSegments.call(this, geometry, material) || this;
			_this.type = 'SkeletonHelper';
			_this.isSkeletonHelper = true;
			_this.root = object;
			_this.bones = bones;
			_this.matrix = object.matrixWorld;
			_this.matrixAutoUpdate = false;
			return _this;
		}

		var _proto = SkeletonHelper.prototype;

		_proto.updateMatrixWorld = function updateMatrixWorld(force) {
			var bones = this.bones;
			var geometry = this.geometry;
			var position = geometry.getAttribute('position');

			_matrixWorldInv.copy(this.root.matrixWorld).invert();

			for (var i = 0, j = 0; i < bones.length; i++) {
				var bone = bones[i];

				if (bone.parent && bone.parent.isBone) {
					_boneMatrix.multiplyMatrices(_matrixWorldInv, bone.matrixWorld);

					_vector$a.setFromMatrixPosition(_boneMatrix);

					position.setXYZ(j, _vector$a.x, _vector$a.y, _vector$a.z);

					_boneMatrix.multiplyMatrices(_matrixWorldInv, bone.parent.matrixWorld);

					_vector$a.setFromMatrixPosition(_boneMatrix);

					position.setXYZ(j + 1, _vector$a.x, _vector$a.y, _vector$a.z);
					j += 2;
				}
			}

			geometry.getAttribute('position').needsUpdate = true;

			_LineSegments.prototype.updateMatrixWorld.call(this, force);
		};

		return SkeletonHelper;
	}(LineSegments);

	function getBoneList(object) {
		var boneList = [];

		if (object && object.isBone) {
			boneList.push(object);
		}

		for (var i = 0; i < object.children.length; i++) {
			boneList.push.apply(boneList, getBoneList(object.children[i]));
		}

		return boneList;
	}

	var PointLightHelper = /*#__PURE__*/function (_Mesh) {
		_inheritsLoose(PointLightHelper, _Mesh);

		function PointLightHelper(light, sphereSize, color) {
			var _this;

			var geometry = new SphereGeometry(sphereSize, 4, 2);
			var material = new MeshBasicMaterial({
				wireframe: true,
				fog: false,
				toneMapped: false
			});
			_this = _Mesh.call(this, geometry, material) || this;
			_this.light = light;

			_this.light.updateMatrixWorld();

			_this.color = color;
			_this.type = 'PointLightHelper';
			_this.matrix = _this.light.matrixWorld;
			_this.matrixAutoUpdate = false;

			_this.update();
			/*
			// TODO: delete this comment?
			const distanceGeometry = new THREE.IcosahedronBufferGeometry( 1, 2 );
			const distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );
				this.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );
			this.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );
				const d = light.distance;
				if ( d === 0.0 ) {
					this.lightDistance.visible = false;
				} else {
					this.lightDistance.scale.set( d, d, d );
				}
				this.add( this.lightDistance );
			*/


			return _this;
		}

		var _proto = PointLightHelper.prototype;

		_proto.dispose = function dispose() {
			this.geometry.dispose();
			this.material.dispose();
		};

		_proto.update = function update() {
			if (this.color !== undefined) {
				this.material.color.set(this.color);
			} else {
				this.material.color.copy(this.light.color);
			}
			/*
			const d = this.light.distance;
					if ( d === 0.0 ) {
						this.lightDistance.visible = false;
					} else {
						this.lightDistance.visible = true;
				this.lightDistance.scale.set( d, d, d );
					}
			*/

		};

		return PointLightHelper;
	}(Mesh);

	var _vector$b = /*@__PURE__*/new Vector3();

	var _color1 = /*@__PURE__*/new Color();

	var _color2 = /*@__PURE__*/new Color();

	var HemisphereLightHelper = /*#__PURE__*/function (_Object3D) {
		_inheritsLoose(HemisphereLightHelper, _Object3D);

		function HemisphereLightHelper(light, size, color) {
			var _this;

			_this = _Object3D.call(this) || this;
			_this.light = light;

			_this.light.updateMatrixWorld();

			_this.matrix = light.matrixWorld;
			_this.matrixAutoUpdate = false;
			_this.color = color;
			var geometry = new OctahedronGeometry(size);
			geometry.rotateY(Math.PI * 0.5);
			_this.material = new MeshBasicMaterial({
				wireframe: true,
				fog: false,
				toneMapped: false
			});
			if (_this.color === undefined) _this.material.vertexColors = true;
			var position = geometry.getAttribute('position');
			var colors = new Float32Array(position.count * 3);
			geometry.setAttribute('color', new BufferAttribute(colors, 3));

			_this.add(new Mesh(geometry, _this.material));

			_this.update();

			return _this;
		}

		var _proto = HemisphereLightHelper.prototype;

		_proto.dispose = function dispose() {
			this.children[0].geometry.dispose();
			this.children[0].material.dispose();
		};

		_proto.update = function update() {
			var mesh = this.children[0];

			if (this.color !== undefined) {
				this.material.color.set(this.color);
			} else {
				var colors = mesh.geometry.getAttribute('color');

				_color1.copy(this.light.color);

				_color2.copy(this.light.groundColor);

				for (var i = 0, l = colors.count; i < l; i++) {
					var color = i < l / 2 ? _color1 : _color2;
					colors.setXYZ(i, color.r, color.g, color.b);
				}

				colors.needsUpdate = true;
			}

			mesh.lookAt(_vector$b.setFromMatrixPosition(this.light.matrixWorld).negate());
		};

		return HemisphereLightHelper;
	}(Object3D);

	var GridHelper = /*#__PURE__*/function (_LineSegments) {
		_inheritsLoose(GridHelper, _LineSegments);

		function GridHelper(size, divisions, color1, color2) {
			var _this;

			if (size === void 0) {
				size = 10;
			}

			if (divisions === void 0) {
				divisions = 10;
			}

			if (color1 === void 0) {
				color1 = 0x444444;
			}

			if (color2 === void 0) {
				color2 = 0x888888;
			}

			color1 = new Color(color1);
			color2 = new Color(color2);
			var center = divisions / 2;
			var step = size / divisions;
			var halfSize = size / 2;
			var vertices = [],
					colors = [];

			for (var i = 0, j = 0, k = -halfSize; i <= divisions; i++, k += step) {
				vertices.push(-halfSize, 0, k, halfSize, 0, k);
				vertices.push(k, 0, -halfSize, k, 0, halfSize);
				var color = i === center ? color1 : color2;
				color.toArray(colors, j);
				j += 3;
				color.toArray(colors, j);
				j += 3;
				color.toArray(colors, j);
				j += 3;
				color.toArray(colors, j);
				j += 3;
			}

			var geometry = new BufferGeometry();
			geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));
			geometry.setAttribute('color', new Float32BufferAttribute(colors, 3));
			var material = new LineBasicMaterial({
				vertexColors: true,
				toneMapped: false
			});
			_this = _LineSegments.call(this, geometry, material) || this;
			_this.type = 'GridHelper';
			return _this;
		}

		return GridHelper;
	}(LineSegments);

	var PolarGridHelper = /*#__PURE__*/function (_LineSegments) {
		_inheritsLoose(PolarGridHelper, _LineSegments);

		function PolarGridHelper(radius, radials, circles, divisions, color1, color2) {
			var _this;

			if (radius === void 0) {
				radius = 10;
			}

			if (radials === void 0) {
				radials = 16;
			}

			if (circles === void 0) {
				circles = 8;
			}

			if (divisions === void 0) {
				divisions = 64;
			}

			if (color1 === void 0) {
				color1 = 0x444444;
			}

			if (color2 === void 0) {
				color2 = 0x888888;
			}

			color1 = new Color(color1);
			color2 = new Color(color2);
			var vertices = [];
			var colors = []; // create the radials

			for (var i = 0; i <= radials; i++) {
				var v = i / radials * (Math.PI * 2);
				var x = Math.sin(v) * radius;
				var z = Math.cos(v) * radius;
				vertices.push(0, 0, 0);
				vertices.push(x, 0, z);
				var color = i & 1 ? color1 : color2;
				colors.push(color.r, color.g, color.b);
				colors.push(color.r, color.g, color.b);
			} // create the circles


			for (var _i = 0; _i <= circles; _i++) {
				var _color = _i & 1 ? color1 : color2;

				var r = radius - radius / circles * _i;

				for (var j = 0; j < divisions; j++) {
					// first vertex
					var _v = j / divisions * (Math.PI * 2);

					var _x = Math.sin(_v) * r;

					var _z = Math.cos(_v) * r;

					vertices.push(_x, 0, _z);
					colors.push(_color.r, _color.g, _color.b); // second vertex

					_v = (j + 1) / divisions * (Math.PI * 2);
					_x = Math.sin(_v) * r;
					_z = Math.cos(_v) * r;
					vertices.push(_x, 0, _z);
					colors.push(_color.r, _color.g, _color.b);
				}
			}

			var geometry = new BufferGeometry();
			geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));
			geometry.setAttribute('color', new Float32BufferAttribute(colors, 3));
			var material = new LineBasicMaterial({
				vertexColors: true,
				toneMapped: false
			});
			_this = _LineSegments.call(this, geometry, material) || this;
			_this.type = 'PolarGridHelper';
			return _this;
		}

		return PolarGridHelper;
	}(LineSegments);

	var _v1$7 = /*@__PURE__*/new Vector3();

	var _v2$3 = /*@__PURE__*/new Vector3();

	var _v3$1 = /*@__PURE__*/new Vector3();

	var DirectionalLightHelper = /*#__PURE__*/function (_Object3D) {
		_inheritsLoose(DirectionalLightHelper, _Object3D);

		function DirectionalLightHelper(light, size, color) {
			var _this;

			_this = _Object3D.call(this) || this;
			_this.light = light;

			_this.light.updateMatrixWorld();

			_this.matrix = light.matrixWorld;
			_this.matrixAutoUpdate = false;
			_this.color = color;
			if (size === undefined) size = 1;
			var geometry = new BufferGeometry();
			geometry.setAttribute('position', new Float32BufferAttribute([-size, size, 0, size, size, 0, size, -size, 0, -size, -size, 0, -size, size, 0], 3));
			var material = new LineBasicMaterial({
				fog: false,
				toneMapped: false
			});
			_this.lightPlane = new Line(geometry, material);

			_this.add(_this.lightPlane);

			geometry = new BufferGeometry();
			geometry.setAttribute('position', new Float32BufferAttribute([0, 0, 0, 0, 0, 1], 3));
			_this.targetLine = new Line(geometry, material);

			_this.add(_this.targetLine);

			_this.update();

			return _this;
		}

		var _proto = DirectionalLightHelper.prototype;

		_proto.dispose = function dispose() {
			this.lightPlane.geometry.dispose();
			this.lightPlane.material.dispose();
			this.targetLine.geometry.dispose();
			this.targetLine.material.dispose();
		};

		_proto.update = function update() {
			_v1$7.setFromMatrixPosition(this.light.matrixWorld);

			_v2$3.setFromMatrixPosition(this.light.target.matrixWorld);

			_v3$1.subVectors(_v2$3, _v1$7);

			this.lightPlane.lookAt(_v2$3);

			if (this.color !== undefined) {
				this.lightPlane.material.color.set(this.color);
				this.targetLine.material.color.set(this.color);
			} else {
				this.lightPlane.material.color.copy(this.light.color);
				this.targetLine.material.color.copy(this.light.color);
			}

			this.targetLine.lookAt(_v2$3);
			this.targetLine.scale.z = _v3$1.length();
		};

		return DirectionalLightHelper;
	}(Object3D);

	var _vector$c = /*@__PURE__*/new Vector3();

	var _camera = /*@__PURE__*/new Camera();
	/**
	 *	- shows frustum, line of sight and up of the camera
	 *	- suitable for fast updates
	 * 	- based on frustum visualization in lightgl.js shadowmap example
	 *		http://evanw.github.com/lightgl.js/tests/shadowmap.html
	 */


	var CameraHelper = /*#__PURE__*/function (_LineSegments) {
		_inheritsLoose(CameraHelper, _LineSegments);

		function CameraHelper(camera) {
			var _this;

			var geometry = new BufferGeometry();
			var material = new LineBasicMaterial({
				color: 0xffffff,
				vertexColors: true,
				toneMapped: false
			});
			var vertices = [];
			var colors = [];
			var pointMap = {}; // colors

			var colorFrustum = new Color(0xffaa00);
			var colorCone = new Color(0xff0000);
			var colorUp = new Color(0x00aaff);
			var colorTarget = new Color(0xffffff);
			var colorCross = new Color(0x333333); // near

			addLine('n1', 'n2', colorFrustum);
			addLine('n2', 'n4', colorFrustum);
			addLine('n4', 'n3', colorFrustum);
			addLine('n3', 'n1', colorFrustum); // far

			addLine('f1', 'f2', colorFrustum);
			addLine('f2', 'f4', colorFrustum);
			addLine('f4', 'f3', colorFrustum);
			addLine('f3', 'f1', colorFrustum); // sides

			addLine('n1', 'f1', colorFrustum);
			addLine('n2', 'f2', colorFrustum);
			addLine('n3', 'f3', colorFrustum);
			addLine('n4', 'f4', colorFrustum); // cone

			addLine('p', 'n1', colorCone);
			addLine('p', 'n2', colorCone);
			addLine('p', 'n3', colorCone);
			addLine('p', 'n4', colorCone); // up

			addLine('u1', 'u2', colorUp);
			addLine('u2', 'u3', colorUp);
			addLine('u3', 'u1', colorUp); // target

			addLine('c', 't', colorTarget);
			addLine('p', 'c', colorCross); // cross

			addLine('cn1', 'cn2', colorCross);
			addLine('cn3', 'cn4', colorCross);
			addLine('cf1', 'cf2', colorCross);
			addLine('cf3', 'cf4', colorCross);

			function addLine(a, b, color) {
				addPoint(a, color);
				addPoint(b, color);
			}

			function addPoint(id, color) {
				vertices.push(0, 0, 0);
				colors.push(color.r, color.g, color.b);

				if (pointMap[id] === undefined) {
					pointMap[id] = [];
				}

				pointMap[id].push(vertices.length / 3 - 1);
			}

			geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));
			geometry.setAttribute('color', new Float32BufferAttribute(colors, 3));
			_this = _LineSegments.call(this, geometry, material) || this;
			_this.type = 'CameraHelper';
			_this.camera = camera;
			if (_this.camera.updateProjectionMatrix) _this.camera.updateProjectionMatrix();
			_this.matrix = camera.matrixWorld;
			_this.matrixAutoUpdate = false;
			_this.pointMap = pointMap;

			_this.update();

			return _this;
		}

		var _proto = CameraHelper.prototype;

		_proto.update = function update() {
			var geometry = this.geometry;
			var pointMap = this.pointMap;
			var w = 1,
					h = 1; // we need just camera projection matrix inverse
			// world matrix must be identity

			_camera.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse); // center / target


			setPoint('c', pointMap, geometry, _camera, 0, 0, -1);
			setPoint('t', pointMap, geometry, _camera, 0, 0, 1); // near

			setPoint('n1', pointMap, geometry, _camera, -w, -h, -1);
			setPoint('n2', pointMap, geometry, _camera, w, -h, -1);
			setPoint('n3', pointMap, geometry, _camera, -w, h, -1);
			setPoint('n4', pointMap, geometry, _camera, w, h, -1); // far

			setPoint('f1', pointMap, geometry, _camera, -w, -h, 1);
			setPoint('f2', pointMap, geometry, _camera, w, -h, 1);
			setPoint('f3', pointMap, geometry, _camera, -w, h, 1);
			setPoint('f4', pointMap, geometry, _camera, w, h, 1); // up

			setPoint('u1', pointMap, geometry, _camera, w * 0.7, h * 1.1, -1);
			setPoint('u2', pointMap, geometry, _camera, -w * 0.7, h * 1.1, -1);
			setPoint('u3', pointMap, geometry, _camera, 0, h * 2, -1); // cross

			setPoint('cf1', pointMap, geometry, _camera, -w, 0, 1);
			setPoint('cf2', pointMap, geometry, _camera, w, 0, 1);
			setPoint('cf3', pointMap, geometry, _camera, 0, -h, 1);
			setPoint('cf4', pointMap, geometry, _camera, 0, h, 1);
			setPoint('cn1', pointMap, geometry, _camera, -w, 0, -1);
			setPoint('cn2', pointMap, geometry, _camera, w, 0, -1);
			setPoint('cn3', pointMap, geometry, _camera, 0, -h, -1);
			setPoint('cn4', pointMap, geometry, _camera, 0, h, -1);
			geometry.getAttribute('position').needsUpdate = true;
		};

		_proto.dispose = function dispose() {
			this.geometry.dispose();
			this.material.dispose();
		};

		return CameraHelper;
	}(LineSegments);

	function setPoint(point, pointMap, geometry, camera, x, y, z) {
		_vector$c.set(x, y, z).unproject(camera);

		var points = pointMap[point];

		if (points !== undefined) {
			var position = geometry.getAttribute('position');

			for (var i = 0, l = points.length; i < l; i++) {
				position.setXYZ(points[i], _vector$c.x, _vector$c.y, _vector$c.z);
			}
		}
	}

	var _box$3 = /*@__PURE__*/new Box3();

	var BoxHelper = /*#__PURE__*/function (_LineSegments) {
		_inheritsLoose(BoxHelper, _LineSegments);

		function BoxHelper(object, color) {
			var _this;

			if (color === void 0) {
				color = 0xffff00;
			}

			var indices = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);
			var positions = new Float32Array(8 * 3);
			var geometry = new BufferGeometry();
			geometry.setIndex(new BufferAttribute(indices, 1));
			geometry.setAttribute('position', new BufferAttribute(positions, 3));
			_this = _LineSegments.call(this, geometry, new LineBasicMaterial({
				color: color,
				toneMapped: false
			})) || this;
			_this.object = object;
			_this.type = 'BoxHelper';
			_this.matrixAutoUpdate = false;

			_this.update();

			return _this;
		}

		var _proto = BoxHelper.prototype;

		_proto.update = function update(object) {
			if (object !== undefined) {
				console.warn('THREE.BoxHelper: .update() has no longer arguments.');
			}

			if (this.object !== undefined) {
				_box$3.setFromObject(this.object);
			}

			if (_box$3.isEmpty()) return;
			var min = _box$3.min;
			var max = _box$3.max;
			/*
				5____4
			1/___0/|
			| 6__|_7
			2/___3/
					0: max.x, max.y, max.z
			1: min.x, max.y, max.z
			2: min.x, min.y, max.z
			3: max.x, min.y, max.z
			4: max.x, max.y, min.z
			5: min.x, max.y, min.z
			6: min.x, min.y, min.z
			7: max.x, min.y, min.z
			*/

			var position = this.geometry.attributes.position;
			var array = position.array;
			array[0] = max.x;
			array[1] = max.y;
			array[2] = max.z;
			array[3] = min.x;
			array[4] = max.y;
			array[5] = max.z;
			array[6] = min.x;
			array[7] = min.y;
			array[8] = max.z;
			array[9] = max.x;
			array[10] = min.y;
			array[11] = max.z;
			array[12] = max.x;
			array[13] = max.y;
			array[14] = min.z;
			array[15] = min.x;
			array[16] = max.y;
			array[17] = min.z;
			array[18] = min.x;
			array[19] = min.y;
			array[20] = min.z;
			array[21] = max.x;
			array[22] = min.y;
			array[23] = min.z;
			position.needsUpdate = true;
			this.geometry.computeBoundingSphere();
		};

		_proto.setFromObject = function setFromObject(object) {
			this.object = object;
			this.update();
			return this;
		};

		_proto.copy = function copy(source) {
			LineSegments.prototype.copy.call(this, source);
			this.object = source.object;
			return this;
		};

		return BoxHelper;
	}(LineSegments);

	var Box3Helper = /*#__PURE__*/function (_LineSegments) {
		_inheritsLoose(Box3Helper, _LineSegments);

		function Box3Helper(box, color) {
			var _this;

			if (color === void 0) {
				color = 0xffff00;
			}

			var indices = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);
			var positions = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1];
			var geometry = new BufferGeometry();
			geometry.setIndex(new BufferAttribute(indices, 1));
			geometry.setAttribute('position', new Float32BufferAttribute(positions, 3));
			_this = _LineSegments.call(this, geometry, new LineBasicMaterial({
				color: color,
				toneMapped: false
			})) || this;
			_this.box = box;
			_this.type = 'Box3Helper';

			_this.geometry.computeBoundingSphere();

			return _this;
		}

		var _proto = Box3Helper.prototype;

		_proto.updateMatrixWorld = function updateMatrixWorld(force) {
			var box = this.box;
			if (box.isEmpty()) return;
			box.getCenter(this.position);
			box.getSize(this.scale);
			this.scale.multiplyScalar(0.5);

			_LineSegments.prototype.updateMatrixWorld.call(this, force);
		};

		return Box3Helper;
	}(LineSegments);

	var PlaneHelper = /*#__PURE__*/function (_Line) {
		_inheritsLoose(PlaneHelper, _Line);

		function PlaneHelper(plane, size, hex) {
			var _this;

			if (size === void 0) {
				size = 1;
			}

			if (hex === void 0) {
				hex = 0xffff00;
			}

			var color = hex;
			var positions = [1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0];
			var geometry = new BufferGeometry();
			geometry.setAttribute('position', new Float32BufferAttribute(positions, 3));
			geometry.computeBoundingSphere();
			_this = _Line.call(this, geometry, new LineBasicMaterial({
				color: color,
				toneMapped: false
			})) || this;
			_this.type = 'PlaneHelper';
			_this.plane = plane;
			_this.size = size;
			var positions2 = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1];
			var geometry2 = new BufferGeometry();
			geometry2.setAttribute('position', new Float32BufferAttribute(positions2, 3));
			geometry2.computeBoundingSphere();

			_this.add(new Mesh(geometry2, new MeshBasicMaterial({
				color: color,
				opacity: 0.2,
				transparent: true,
				depthWrite: false,
				toneMapped: false
			})));

			return _this;
		}

		var _proto = PlaneHelper.prototype;

		_proto.updateMatrixWorld = function updateMatrixWorld(force) {
			var scale = -this.plane.constant;
			if (Math.abs(scale) < 1e-8) scale = 1e-8; // sign does not matter

			this.scale.set(0.5 * this.size, 0.5 * this.size, scale);
			this.children[0].material.side = scale < 0 ? BackSide : FrontSide; // renderer flips side when determinant < 0; flipping not wanted here

			this.lookAt(this.plane.normal);

			_Line.prototype.updateMatrixWorld.call(this, force);
		};

		return PlaneHelper;
	}(Line);

	var _axis = /*@__PURE__*/new Vector3();

	var _lineGeometry, _coneGeometry;

	var ArrowHelper = /*#__PURE__*/function (_Object3D) {
		_inheritsLoose(ArrowHelper, _Object3D);

		// dir is assumed to be normalized
		function ArrowHelper(dir, origin, length, color, headLength, headWidth) {
			var _this;

			if (dir === void 0) {
				dir = new Vector3(0, 0, 1);
			}

			if (origin === void 0) {
				origin = new Vector3(0, 0, 0);
			}

			if (length === void 0) {
				length = 1;
			}

			if (color === void 0) {
				color = 0xffff00;
			}

			if (headLength === void 0) {
				headLength = length * 0.2;
			}

			if (headWidth === void 0) {
				headWidth = headLength * 0.2;
			}

			_this = _Object3D.call(this) || this;
			_this.type = 'ArrowHelper';

			if (_lineGeometry === undefined) {
				_lineGeometry = new BufferGeometry();

				_lineGeometry.setAttribute('position', new Float32BufferAttribute([0, 0, 0, 0, 1, 0], 3));

				_coneGeometry = new CylinderGeometry(0, 0.5, 1, 5, 1);

				_coneGeometry.translate(0, -0.5, 0);
			}

			_this.position.copy(origin);

			_this.line = new Line(_lineGeometry, new LineBasicMaterial({
				color: color,
				toneMapped: false
			}));
			_this.line.matrixAutoUpdate = false;

			_this.add(_this.line);

			_this.cone = new Mesh(_coneGeometry, new MeshBasicMaterial({
				color: color,
				toneMapped: false
			}));
			_this.cone.matrixAutoUpdate = false;

			_this.add(_this.cone);

			_this.setDirection(dir);

			_this.setLength(length, headLength, headWidth);

			return _this;
		}

		var _proto = ArrowHelper.prototype;

		_proto.setDirection = function setDirection(dir) {
			// dir is assumed to be normalized
			if (dir.y > 0.99999) {
				this.quaternion.set(0, 0, 0, 1);
			} else if (dir.y < -0.99999) {
				this.quaternion.set(1, 0, 0, 0);
			} else {
				_axis.set(dir.z, 0, -dir.x).normalize();

				var radians = Math.acos(dir.y);
				this.quaternion.setFromAxisAngle(_axis, radians);
			}
		};

		_proto.setLength = function setLength(length, headLength, headWidth) {
			if (headLength === void 0) {
				headLength = length * 0.2;
			}

			if (headWidth === void 0) {
				headWidth = headLength * 0.2;
			}

			this.line.scale.set(1, Math.max(0.0001, length - headLength), 1); // see #17458

			this.line.updateMatrix();
			this.cone.scale.set(headWidth, headLength, headWidth);
			this.cone.position.y = length;
			this.cone.updateMatrix();
		};

		_proto.setColor = function setColor(color) {
			this.line.material.color.set(color);
			this.cone.material.color.set(color);
		};

		_proto.copy = function copy(source) {
			_Object3D.prototype.copy.call(this, source, false);

			this.line.copy(source.line);
			this.cone.copy(source.cone);
			return this;
		};

		return ArrowHelper;
	}(Object3D);

	var AxesHelper = /*#__PURE__*/function (_LineSegments) {
		_inheritsLoose(AxesHelper, _LineSegments);

		function AxesHelper(size) {
			var _this;

			if (size === void 0) {
				size = 1;
			}

			var vertices = [0, 0, 0, size, 0, 0, 0, 0, 0, 0, size, 0, 0, 0, 0, 0, 0, size];
			var colors = [1, 0, 0, 1, 0.6, 0, 0, 1, 0, 0.6, 1, 0, 0, 0, 1, 0, 0.6, 1];
			var geometry = new BufferGeometry();
			geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));
			geometry.setAttribute('color', new Float32BufferAttribute(colors, 3));
			var material = new LineBasicMaterial({
				vertexColors: true,
				toneMapped: false
			});
			_this = _LineSegments.call(this, geometry, material) || this;
			_this.type = 'AxesHelper';
			return _this;
		}

		var _proto = AxesHelper.prototype;

		_proto.setColors = function setColors(xAxisColor, yAxisColor, zAxisColor) {
			var color = new Color();
			var array = this.geometry.attributes.color.array;
			color.set(xAxisColor);
			color.toArray(array, 0);
			color.toArray(array, 3);
			color.set(yAxisColor);
			color.toArray(array, 6);
			color.toArray(array, 9);
			color.set(zAxisColor);
			color.toArray(array, 12);
			color.toArray(array, 15);
			this.geometry.attributes.color.needsUpdate = true;
			return this;
		};

		_proto.dispose = function dispose() {
			this.geometry.dispose();
			this.material.dispose();
		};

		return AxesHelper;
	}(LineSegments);

	var ShapePath = /*#__PURE__*/function () {
		function ShapePath() {
			this.type = 'ShapePath';
			this.color = new Color();
			this.subPaths = [];
			this.currentPath = null;
		}

		var _proto = ShapePath.prototype;

		_proto.moveTo = function moveTo(x, y) {
			this.currentPath = new Path();
			this.subPaths.push(this.currentPath);
			this.currentPath.moveTo(x, y);
			return this;
		};

		_proto.lineTo = function lineTo(x, y) {
			this.currentPath.lineTo(x, y);
			return this;
		};

		_proto.quadraticCurveTo = function quadraticCurveTo(aCPx, aCPy, aX, aY) {
			this.currentPath.quadraticCurveTo(aCPx, aCPy, aX, aY);
			return this;
		};

		_proto.bezierCurveTo = function bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
			this.currentPath.bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY);
			return this;
		};

		_proto.splineThru = function splineThru(pts) {
			this.currentPath.splineThru(pts);
			return this;
		};

		_proto.toShapes = function toShapes(isCCW, noHoles) {
			function toShapesNoHoles(inSubpaths) {
				var shapes = [];

				for (var i = 0, l = inSubpaths.length; i < l; i++) {
					var _tmpPath = inSubpaths[i];

					var _tmpShape = new Shape();

					_tmpShape.curves = _tmpPath.curves;
					shapes.push(_tmpShape);
				}

				return shapes;
			}

			function isPointInsidePolygon(inPt, inPolygon) {
				var polyLen = inPolygon.length; // inPt on polygon contour => immediate success		or
				// toggling of inside/outside at every single! intersection point of an edge
				//	with the horizontal line through inPt, left of inPt
				//	not counting lowerY endpoints of edges and whole edges on that line

				var inside = false;

				for (var p = polyLen - 1, q = 0; q < polyLen; p = q++) {
					var edgeLowPt = inPolygon[p];
					var edgeHighPt = inPolygon[q];
					var edgeDx = edgeHighPt.x - edgeLowPt.x;
					var edgeDy = edgeHighPt.y - edgeLowPt.y;

					if (Math.abs(edgeDy) > Number.EPSILON) {
						// not parallel
						if (edgeDy < 0) {
							edgeLowPt = inPolygon[q];
							edgeDx = -edgeDx;
							edgeHighPt = inPolygon[p];
							edgeDy = -edgeDy;
						}

						if (inPt.y < edgeLowPt.y || inPt.y > edgeHighPt.y) continue;

						if (inPt.y === edgeLowPt.y) {
							if (inPt.x === edgeLowPt.x) return true; // inPt is on contour ?
							// continue;				// no intersection or edgeLowPt => doesn't count !!!
						} else {
							var perpEdge = edgeDy * (inPt.x - edgeLowPt.x) - edgeDx * (inPt.y - edgeLowPt.y);
							if (perpEdge === 0) return true; // inPt is on contour ?

							if (perpEdge < 0) continue;
							inside = !inside; // true intersection left of inPt
						}
					} else {
						// parallel or collinear
						if (inPt.y !== edgeLowPt.y) continue; // parallel
						// edge lies on the same horizontal line as inPt

						if (edgeHighPt.x <= inPt.x && inPt.x <= edgeLowPt.x || edgeLowPt.x <= inPt.x && inPt.x <= edgeHighPt.x) return true; // inPt: Point on contour !
						// continue;
					}
				}

				return inside;
			}

			var isClockWise = ShapeUtils.isClockWise;
			var subPaths = this.subPaths;
			if (subPaths.length === 0) return [];
			if (noHoles === true) return toShapesNoHoles(subPaths);
			var solid, tmpPath, tmpShape;
			var shapes = [];

			if (subPaths.length === 1) {
				tmpPath = subPaths[0];
				tmpShape = new Shape();
				tmpShape.curves = tmpPath.curves;
				shapes.push(tmpShape);
				return shapes;
			}

			var holesFirst = !isClockWise(subPaths[0].getPoints());
			holesFirst = isCCW ? !holesFirst : holesFirst; // console.log("Holes first", holesFirst);

			var betterShapeHoles = [];
			var newShapes = [];
			var newShapeHoles = [];
			var mainIdx = 0;
			var tmpPoints;
			newShapes[mainIdx] = undefined;
			newShapeHoles[mainIdx] = [];

			for (var i = 0, l = subPaths.length; i < l; i++) {
				tmpPath = subPaths[i];
				tmpPoints = tmpPath.getPoints();
				solid = isClockWise(tmpPoints);
				solid = isCCW ? !solid : solid;

				if (solid) {
					if (!holesFirst && newShapes[mainIdx]) mainIdx++;
					newShapes[mainIdx] = {
						s: new Shape(),
						p: tmpPoints
					};
					newShapes[mainIdx].s.curves = tmpPath.curves;
					if (holesFirst) mainIdx++;
					newShapeHoles[mainIdx] = []; //console.log('cw', i);
				} else {
					newShapeHoles[mainIdx].push({
						h: tmpPath,
						p: tmpPoints[0]
					}); //console.log('ccw', i);
				}
			} // only Holes? -> probably all Shapes with wrong orientation


			if (!newShapes[0]) return toShapesNoHoles(subPaths);

			if (newShapes.length > 1) {
				var ambiguous = false;
				var toChange = [];

				for (var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {
					betterShapeHoles[sIdx] = [];
				}

				for (var _sIdx = 0, _sLen = newShapes.length; _sIdx < _sLen; _sIdx++) {
					var sho = newShapeHoles[_sIdx];

					for (var hIdx = 0; hIdx < sho.length; hIdx++) {
						var ho = sho[hIdx];
						var hole_unassigned = true;

						for (var s2Idx = 0; s2Idx < newShapes.length; s2Idx++) {
							if (isPointInsidePolygon(ho.p, newShapes[s2Idx].p)) {
								if (_sIdx !== s2Idx) toChange.push({
									froms: _sIdx,
									tos: s2Idx,
									hole: hIdx
								});

								if (hole_unassigned) {
									hole_unassigned = false;
									betterShapeHoles[s2Idx].push(ho);
								} else {
									ambiguous = true;
								}
							}
						}

						if (hole_unassigned) {
							betterShapeHoles[_sIdx].push(ho);
						}
					}
				} // console.log("ambiguous: ", ambiguous);


				if (toChange.length > 0) {
					// console.log("to change: ", toChange);
					if (!ambiguous) newShapeHoles = betterShapeHoles;
				}
			}

			var tmpHoles;

			for (var _i = 0, il = newShapes.length; _i < il; _i++) {
				tmpShape = newShapes[_i].s;
				shapes.push(tmpShape);
				tmpHoles = newShapeHoles[_i];

				for (var j = 0, jl = tmpHoles.length; j < jl; j++) {
					tmpShape.holes.push(tmpHoles[j].h);
				}
			} //console.log("shape", shapes);


			return shapes;
		};

		return ShapePath;
	}();

	var _floatView = new Float32Array(1);

	var _int32View = new Int32Array(_floatView.buffer);

	var DataUtils = /*#__PURE__*/function () {
		function DataUtils() {}

		// Converts float32 to float16 (stored as uint16 value).
		DataUtils.toHalfFloat = function toHalfFloat(val) {
			if (val > 65504) {
				console.warn('THREE.DataUtils.toHalfFloat(): value exceeds 65504.');
				val = 65504; // maximum representable value in float16
			} // Source: http://gamedev.stackexchange.com/questions/17326/conversion-of-a-number-from-single-precision-floating-point-representation-to-a/17410#17410

			/* This method is faster than the OpenEXR implementation (very often
			* used, eg. in Ogre), with the additional benefit of rounding, inspired
			* by James Tursa?s half-precision code. */


			_floatView[0] = val;
			var x = _int32View[0];
			var bits = x >> 16 & 0x8000;
			/* Get the sign */

			var m = x >> 12 & 0x07ff;
			/* Keep one extra bit for rounding */

			var e = x >> 23 & 0xff;
			/* Using int is faster here */

			/* If zero, or denormal, or exponent underflows too much for a denormal
				* half, return signed zero. */

			if (e < 103) return bits;
			/* If NaN, return NaN. If Inf or exponent overflow, return Inf. */

			if (e > 142) {
				bits |= 0x7c00;
				/* If exponent was 0xff and one mantissa bit was set, it means NaN,
							* not Inf, so make sure we set one mantissa bit too. */

				bits |= (e == 255 ? 0 : 1) && x & 0x007fffff;
				return bits;
			}
			/* If exponent underflows but not too much, return a denormal */


			if (e < 113) {
				m |= 0x0800;
				/* Extra rounding may overflow and set mantissa to 0 and exponent
					* to 1, which is OK. */

				bits |= (m >> 114 - e) + (m >> 113 - e & 1);
				return bits;
			}

			bits |= e - 112 << 10 | m >> 1;
			/* Extra rounding. An overflow will set mantissa to 0 and increment
				* the exponent, which is OK. */

			bits += m & 1;
			return bits;
		};

		return DataUtils;
	}();

	var LineStrip = 0;
	var LinePieces = 1;
	var NoColors = 0;
	var FaceColors = 1;
	var VertexColors = 2;
	function MeshFaceMaterial(materials) {
		console.warn('THREE.MeshFaceMaterial has been removed. Use an Array instead.');
		return materials;
	}
	function MultiMaterial(materials) {
		if (materials === void 0) {
			materials = [];
		}

		console.warn('THREE.MultiMaterial has been removed. Use an Array instead.');
		materials.isMultiMaterial = true;
		materials.materials = materials;

		materials.clone = function () {
			return materials.slice();
		};

		return materials;
	}
	function PointCloud(geometry, material) {
		console.warn('THREE.PointCloud has been renamed to THREE.Points.');
		return new Points(geometry, material);
	}
	function Particle(material) {
		console.warn('THREE.Particle has been renamed to THREE.Sprite.');
		return new Sprite(material);
	}
	function ParticleSystem(geometry, material) {
		console.warn('THREE.ParticleSystem has been renamed to THREE.Points.');
		return new Points(geometry, material);
	}
	function PointCloudMaterial(parameters) {
		console.warn('THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.');
		return new PointsMaterial(parameters);
	}
	function ParticleBasicMaterial(parameters) {
		console.warn('THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.');
		return new PointsMaterial(parameters);
	}
	function ParticleSystemMaterial(parameters) {
		console.warn('THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.');
		return new PointsMaterial(parameters);
	}
	function Vertex(x, y, z) {
		console.warn('THREE.Vertex has been removed. Use THREE.Vector3 instead.');
		return new Vector3(x, y, z);
	} //

	function DynamicBufferAttribute(array, itemSize) {
		console.warn('THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setUsage( THREE.DynamicDrawUsage ) instead.');
		return new BufferAttribute(array, itemSize).setUsage(DynamicDrawUsage);
	}
	function Int8Attribute(array, itemSize) {
		console.warn('THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead.');
		return new Int8BufferAttribute(array, itemSize);
	}
	function Uint8Attribute(array, itemSize) {
		console.warn('THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead.');
		return new Uint8BufferAttribute(array, itemSize);
	}
	function Uint8ClampedAttribute(array, itemSize) {
		console.warn('THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead.');
		return new Uint8ClampedBufferAttribute(array, itemSize);
	}
	function Int16Attribute(array, itemSize) {
		console.warn('THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead.');
		return new Int16BufferAttribute(array, itemSize);
	}
	function Uint16Attribute(array, itemSize) {
		console.warn('THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead.');
		return new Uint16BufferAttribute(array, itemSize);
	}
	function Int32Attribute(array, itemSize) {
		console.warn('THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead.');
		return new Int32BufferAttribute(array, itemSize);
	}
	function Uint32Attribute(array, itemSize) {
		console.warn('THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead.');
		return new Uint32BufferAttribute(array, itemSize);
	}
	function Float32Attribute(array, itemSize) {
		console.warn('THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead.');
		return new Float32BufferAttribute(array, itemSize);
	}
	function Float64Attribute(array, itemSize) {
		console.warn('THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead.');
		return new Float64BufferAttribute(array, itemSize);
	} //

	Curve.create = function (construct, getPoint) {
		console.log('THREE.Curve.create() has been deprecated');
		construct.prototype = Object.create(Curve.prototype);
		construct.prototype.constructor = construct;
		construct.prototype.getPoint = getPoint;
		return construct;
	}; //


	Path.prototype.fromPoints = function (points) {
		console.warn('THREE.Path: .fromPoints() has been renamed to .setFromPoints().');
		return this.setFromPoints(points);
	}; //


	function AxisHelper(size) {
		console.warn('THREE.AxisHelper has been renamed to THREE.AxesHelper.');
		return new AxesHelper(size);
	}
	function BoundingBoxHelper(object, color) {
		console.warn('THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead.');
		return new BoxHelper(object, color);
	}
	function EdgesHelper(object, hex) {
		console.warn('THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead.');
		return new LineSegments(new EdgesGeometry(object.geometry), new LineBasicMaterial({
			color: hex !== undefined ? hex : 0xffffff
		}));
	}

	GridHelper.prototype.setColors = function () {
		console.error('THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.');
	};

	SkeletonHelper.prototype.update = function () {
		console.error('THREE.SkeletonHelper: update() no longer needs to be called.');
	};

	function WireframeHelper(object, hex) {
		console.warn('THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead.');
		return new LineSegments(new WireframeGeometry(object.geometry), new LineBasicMaterial({
			color: hex !== undefined ? hex : 0xffffff
		}));
	} //

	Loader.prototype.extractUrlBase = function (url) {
		console.warn('THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead.');
		return LoaderUtils.extractUrlBase(url);
	};

	Loader.Handlers = {
		add: function add()
		/* regex, loader */
		{
			console.error('THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.');
		},
		get: function get()
		/* file */
		{
			console.error('THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.');
		}
	};
	function XHRLoader(manager) {
		console.warn('THREE.XHRLoader has been renamed to THREE.FileLoader.');
		return new FileLoader(manager);
	}
	function BinaryTextureLoader(manager) {
		console.warn('THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader.');
		return new DataTextureLoader(manager);
	} //

	Box2.prototype.center = function (optionalTarget) {
		console.warn('THREE.Box2: .center() has been renamed to .getCenter().');
		return this.getCenter(optionalTarget);
	};

	Box2.prototype.empty = function () {
		console.warn('THREE.Box2: .empty() has been renamed to .isEmpty().');
		return this.isEmpty();
	};

	Box2.prototype.isIntersectionBox = function (box) {
		console.warn('THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().');
		return this.intersectsBox(box);
	};

	Box2.prototype.size = function (optionalTarget) {
		console.warn('THREE.Box2: .size() has been renamed to .getSize().');
		return this.getSize(optionalTarget);
	}; //


	Box3.prototype.center = function (optionalTarget) {
		console.warn('THREE.Box3: .center() has been renamed to .getCenter().');
		return this.getCenter(optionalTarget);
	};

	Box3.prototype.empty = function () {
		console.warn('THREE.Box3: .empty() has been renamed to .isEmpty().');
		return this.isEmpty();
	};

	Box3.prototype.isIntersectionBox = function (box) {
		console.warn('THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().');
		return this.intersectsBox(box);
	};

	Box3.prototype.isIntersectionSphere = function (sphere) {
		console.warn('THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().');
		return this.intersectsSphere(sphere);
	};

	Box3.prototype.size = function (optionalTarget) {
		console.warn('THREE.Box3: .size() has been renamed to .getSize().');
		return this.getSize(optionalTarget);
	}; //


	Sphere.prototype.empty = function () {
		console.warn('THREE.Sphere: .empty() has been renamed to .isEmpty().');
		return this.isEmpty();
	}; //


	Frustum.prototype.setFromMatrix = function (m) {
		console.warn('THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix().');
		return this.setFromProjectionMatrix(m);
	}; //


	Line3.prototype.center = function (optionalTarget) {
		console.warn('THREE.Line3: .center() has been renamed to .getCenter().');
		return this.getCenter(optionalTarget);
	}; //


	Matrix3.prototype.flattenToArrayOffset = function (array, offset) {
		console.warn('THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.');
		return this.toArray(array, offset);
	};

	Matrix3.prototype.multiplyVector3 = function (vector) {
		console.warn('THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.');
		return vector.applyMatrix3(this);
	};

	Matrix3.prototype.multiplyVector3Array = function ()
	/* a */
	{
		console.error('THREE.Matrix3: .multiplyVector3Array() has been removed.');
	};

	Matrix3.prototype.applyToBufferAttribute = function (attribute) {
		console.warn('THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead.');
		return attribute.applyMatrix3(this);
	};

	Matrix3.prototype.applyToVector3Array = function ()
	/* array, offset, length */
	{
		console.error('THREE.Matrix3: .applyToVector3Array() has been removed.');
	};

	Matrix3.prototype.getInverse = function (matrix) {
		console.warn('THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead.');
		return this.copy(matrix).invert();
	}; //


	Matrix4.prototype.extractPosition = function (m) {
		console.warn('THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().');
		return this.copyPosition(m);
	};

	Matrix4.prototype.flattenToArrayOffset = function (array, offset) {
		console.warn('THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.');
		return this.toArray(array, offset);
	};

	Matrix4.prototype.getPosition = function () {
		console.warn('THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.');
		return new Vector3().setFromMatrixColumn(this, 3);
	};

	Matrix4.prototype.setRotationFromQuaternion = function (q) {
		console.warn('THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().');
		return this.makeRotationFromQuaternion(q);
	};

	Matrix4.prototype.multiplyToArray = function () {
		console.warn('THREE.Matrix4: .multiplyToArray() has been removed.');
	};

	Matrix4.prototype.multiplyVector3 = function (vector) {
		console.warn('THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.');
		return vector.applyMatrix4(this);
	};

	Matrix4.prototype.multiplyVector4 = function (vector) {
		console.warn('THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.');
		return vector.applyMatrix4(this);
	};

	Matrix4.prototype.multiplyVector3Array = function ()
	/* a */
	{
		console.error('THREE.Matrix4: .multiplyVector3Array() has been removed.');
	};

	Matrix4.prototype.rotateAxis = function (v) {
		console.warn('THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.');
		v.transformDirection(this);
	};

	Matrix4.prototype.crossVector = function (vector) {
		console.warn('THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.');
		return vector.applyMatrix4(this);
	};

	Matrix4.prototype.translate = function () {
		console.error('THREE.Matrix4: .translate() has been removed.');
	};

	Matrix4.prototype.rotateX = function () {
		console.error('THREE.Matrix4: .rotateX() has been removed.');
	};

	Matrix4.prototype.rotateY = function () {
		console.error('THREE.Matrix4: .rotateY() has been removed.');
	};

	Matrix4.prototype.rotateZ = function () {
		console.error('THREE.Matrix4: .rotateZ() has been removed.');
	};

	Matrix4.prototype.rotateByAxis = function () {
		console.error('THREE.Matrix4: .rotateByAxis() has been removed.');
	};

	Matrix4.prototype.applyToBufferAttribute = function (attribute) {
		console.warn('THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead.');
		return attribute.applyMatrix4(this);
	};

	Matrix4.prototype.applyToVector3Array = function ()
	/* array, offset, length */
	{
		console.error('THREE.Matrix4: .applyToVector3Array() has been removed.');
	};

	Matrix4.prototype.makeFrustum = function (left, right, bottom, top, near, far) {
		console.warn('THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.');
		return this.makePerspective(left, right, top, bottom, near, far);
	};

	Matrix4.prototype.getInverse = function (matrix) {
		console.warn('THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead.');
		return this.copy(matrix).invert();
	}; //


	Plane.prototype.isIntersectionLine = function (line) {
		console.warn('THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().');
		return this.intersectsLine(line);
	}; //


	Quaternion.prototype.multiplyVector3 = function (vector) {
		console.warn('THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.');
		return vector.applyQuaternion(this);
	};

	Quaternion.prototype.inverse = function () {
		console.warn('THREE.Quaternion: .inverse() has been renamed to invert().');
		return this.invert();
	}; //


	Ray.prototype.isIntersectionBox = function (box) {
		console.warn('THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().');
		return this.intersectsBox(box);
	};

	Ray.prototype.isIntersectionPlane = function (plane) {
		console.warn('THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().');
		return this.intersectsPlane(plane);
	};

	Ray.prototype.isIntersectionSphere = function (sphere) {
		console.warn('THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().');
		return this.intersectsSphere(sphere);
	}; //


	Triangle.prototype.area = function () {
		console.warn('THREE.Triangle: .area() has been renamed to .getArea().');
		return this.getArea();
	};

	Triangle.prototype.barycoordFromPoint = function (point, target) {
		console.warn('THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().');
		return this.getBarycoord(point, target);
	};

	Triangle.prototype.midpoint = function (target) {
		console.warn('THREE.Triangle: .midpoint() has been renamed to .getMidpoint().');
		return this.getMidpoint(target);
	};

	Triangle.prototypenormal = function (target) {
		console.warn('THREE.Triangle: .normal() has been renamed to .getNormal().');
		return this.getNormal(target);
	};

	Triangle.prototype.plane = function (target) {
		console.warn('THREE.Triangle: .plane() has been renamed to .getPlane().');
		return this.getPlane(target);
	};

	Triangle.barycoordFromPoint = function (point, a, b, c, target) {
		console.warn('THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().');
		return Triangle.getBarycoord(point, a, b, c, target);
	};

	Triangle.normal = function (a, b, c, target) {
		console.warn('THREE.Triangle: .normal() has been renamed to .getNormal().');
		return Triangle.getNormal(a, b, c, target);
	}; //


	Shape.prototype.extractAllPoints = function (divisions) {
		console.warn('THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead.');
		return this.extractPoints(divisions);
	};

	Shape.prototype.extrude = function (options) {
		console.warn('THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.');
		return new ExtrudeGeometry(this, options);
	};

	Shape.prototype.makeGeometry = function (options) {
		console.warn('THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.');
		return new ShapeGeometry(this, options);
	}; //


	Vector2.prototype.fromAttribute = function (attribute, index, offset) {
		console.warn('THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().');
		return this.fromBufferAttribute(attribute, index, offset);
	};

	Vector2.prototype.distanceToManhattan = function (v) {
		console.warn('THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo().');
		return this.manhattanDistanceTo(v);
	};

	Vector2.prototype.lengthManhattan = function () {
		console.warn('THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength().');
		return this.manhattanLength();
	}; //


	Vector3.prototype.setEulerFromRotationMatrix = function () {
		console.error('THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.');
	};

	Vector3.prototype.setEulerFromQuaternion = function () {
		console.error('THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.');
	};

	Vector3.prototype.getPositionFromMatrix = function (m) {
		console.warn('THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().');
		return this.setFromMatrixPosition(m);
	};

	Vector3.prototype.getScaleFromMatrix = function (m) {
		console.warn('THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().');
		return this.setFromMatrixScale(m);
	};

	Vector3.prototype.getColumnFromMatrix = function (index, matrix) {
		console.warn('THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().');
		return this.setFromMatrixColumn(matrix, index);
	};

	Vector3.prototype.applyProjection = function (m) {
		console.warn('THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.');
		return this.applyMatrix4(m);
	};

	Vector3.prototype.fromAttribute = function (attribute, index, offset) {
		console.warn('THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().');
		return this.fromBufferAttribute(attribute, index, offset);
	};

	Vector3.prototype.distanceToManhattan = function (v) {
		console.warn('THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo().');
		return this.manhattanDistanceTo(v);
	};

	Vector3.prototype.lengthManhattan = function () {
		console.warn('THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength().');
		return this.manhattanLength();
	}; //


	Vector4.prototype.fromAttribute = function (attribute, index, offset) {
		console.warn('THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().');
		return this.fromBufferAttribute(attribute, index, offset);
	};

	Vector4.prototype.lengthManhattan = function () {
		console.warn('THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength().');
		return this.manhattanLength();
	}; //


	Object3D.prototype.getChildByName = function (name) {
		console.warn('THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().');
		return this.getObjectByName(name);
	};

	Object3D.prototype.renderDepth = function () {
		console.warn('THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.');
	};

	Object3D.prototype.translate = function (distance, axis) {
		console.warn('THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.');
		return this.translateOnAxis(axis, distance);
	};

	Object3D.prototype.getWorldRotation = function () {
		console.error('THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.');
	};

	Object3D.prototype.applyMatrix = function (matrix) {
		console.warn('THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4().');
		return this.applyMatrix4(matrix);
	};

	Object.defineProperties(Object3D.prototype, {
		eulerOrder: {
			get: function get() {
				console.warn('THREE.Object3D: .eulerOrder is now .rotation.order.');
				return this.rotation.order;
			},
			set: function set(value) {
				console.warn('THREE.Object3D: .eulerOrder is now .rotation.order.');
				this.rotation.order = value;
			}
		},
		useQuaternion: {
			get: function get() {
				console.warn('THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.');
			},
			set: function set() {
				console.warn('THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.');
			}
		}
	});

	Mesh.prototype.setDrawMode = function () {
		console.error('THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.');
	};

	Object.defineProperties(Mesh.prototype, {
		drawMode: {
			get: function get() {
				console.error('THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode.');
				return TrianglesDrawMode;
			},
			set: function set() {
				console.error('THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.');
			}
		}
	});

	SkinnedMesh.prototype.initBones = function () {
		console.error('THREE.SkinnedMesh: initBones() has been removed.');
	}; //


	PerspectiveCamera.prototype.setLens = function (focalLength, filmGauge) {
		console.warn('THREE.PerspectiveCamera.setLens is deprecated. ' + 'Use .setFocalLength and .filmGauge for a photographic setup.');
		if (filmGauge !== undefined) this.filmGauge = filmGauge;
		this.setFocalLength(focalLength);
	}; //


	Object.defineProperties(Light.prototype, {
		onlyShadow: {
			set: function set() {
				console.warn('THREE.Light: .onlyShadow has been removed.');
			}
		},
		shadowCameraFov: {
			set: function set(value) {
				console.warn('THREE.Light: .shadowCameraFov is now .shadow.camera.fov.');
				this.shadow.camera.fov = value;
			}
		},
		shadowCameraLeft: {
			set: function set(value) {
				console.warn('THREE.Light: .shadowCameraLeft is now .shadow.camera.left.');
				this.shadow.camera.left = value;
			}
		},
		shadowCameraRight: {
			set: function set(value) {
				console.warn('THREE.Light: .shadowCameraRight is now .shadow.camera.right.');
				this.shadow.camera.right = value;
			}
		},
		shadowCameraTop: {
			set: function set(value) {
				console.warn('THREE.Light: .shadowCameraTop is now .shadow.camera.top.');
				this.shadow.camera.top = value;
			}
		},
		shadowCameraBottom: {
			set: function set(value) {
				console.warn('THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.');
				this.shadow.camera.bottom = value;
			}
		},
		shadowCameraNear: {
			set: function set(value) {
				console.warn('THREE.Light: .shadowCameraNear is now .shadow.camera.near.');
				this.shadow.camera.near = value;
			}
		},
		shadowCameraFar: {
			set: function set(value) {
				console.warn('THREE.Light: .shadowCameraFar is now .shadow.camera.far.');
				this.shadow.camera.far = value;
			}
		},
		shadowCameraVisible: {
			set: function set() {
				console.warn('THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.');
			}
		},
		shadowBias: {
			set: function set(value) {
				console.warn('THREE.Light: .shadowBias is now .shadow.bias.');
				this.shadow.bias = value;
			}
		},
		shadowDarkness: {
			set: function set() {
				console.warn('THREE.Light: .shadowDarkness has been removed.');
			}
		},
		shadowMapWidth: {
			set: function set(value) {
				console.warn('THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.');
				this.shadow.mapSize.width = value;
			}
		},
		shadowMapHeight: {
			set: function set(value) {
				console.warn('THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.');
				this.shadow.mapSize.height = value;
			}
		}
	}); //

	Object.defineProperties(BufferAttribute.prototype, {
		length: {
			get: function get() {
				console.warn('THREE.BufferAttribute: .length has been deprecated. Use .count instead.');
				return this.array.length;
			}
		},
		dynamic: {
			get: function get() {
				console.warn('THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.');
				return this.usage === DynamicDrawUsage;
			},
			set: function set()
			/* value */
			{
				console.warn('THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.');
				this.setUsage(DynamicDrawUsage);
			}
		}
	});

	BufferAttribute.prototype.setDynamic = function (value) {
		console.warn('THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead.');
		this.setUsage(value === true ? DynamicDrawUsage : StaticDrawUsage);
		return this;
	};

	BufferAttribute.prototype.copyIndicesArray = function ()
	/* indices */
	{
		console.error('THREE.BufferAttribute: .copyIndicesArray() has been removed.');
	}, BufferAttribute.prototype.setArray = function ()
	/* array */
	{
		console.error('THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers');
	}; //

	BufferGeometry.prototype.addIndex = function (index) {
		console.warn('THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().');
		this.setIndex(index);
	};

	BufferGeometry.prototype.addAttribute = function (name, attribute) {
		console.warn('THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute().');

		if (!(attribute && attribute.isBufferAttribute) && !(attribute && attribute.isInterleavedBufferAttribute)) {
			console.warn('THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).');
			return this.setAttribute(name, new BufferAttribute(arguments[1], arguments[2]));
		}

		if (name === 'index') {
			console.warn('THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.');
			this.setIndex(attribute);
			return this;
		}

		return this.setAttribute(name, attribute);
	};

	BufferGeometry.prototype.addDrawCall = function (start, count, indexOffset) {
		if (indexOffset !== undefined) {
			console.warn('THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.');
		}

		console.warn('THREE.BufferGeometry: .addDrawCall() is now .addGroup().');
		this.addGroup(start, count);
	};

	BufferGeometry.prototype.clearDrawCalls = function () {
		console.warn('THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().');
		this.clearGroups();
	};

	BufferGeometry.prototype.computeOffsets = function () {
		console.warn('THREE.BufferGeometry: .computeOffsets() has been removed.');
	};

	BufferGeometry.prototype.removeAttribute = function (name) {
		console.warn('THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute().');
		return this.deleteAttribute(name);
	};

	BufferGeometry.prototype.applyMatrix = function (matrix) {
		console.warn('THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4().');
		return this.applyMatrix4(matrix);
	};

	Object.defineProperties(BufferGeometry.prototype, {
		drawcalls: {
			get: function get() {
				console.error('THREE.BufferGeometry: .drawcalls has been renamed to .groups.');
				return this.groups;
			}
		},
		offsets: {
			get: function get() {
				console.warn('THREE.BufferGeometry: .offsets has been renamed to .groups.');
				return this.groups;
			}
		}
	});

	InterleavedBuffer.prototype.setDynamic = function (value) {
		console.warn('THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead.');
		this.setUsage(value === true ? DynamicDrawUsage : StaticDrawUsage);
		return this;
	};

	InterleavedBuffer.prototype.setArray = function ()
	/* array */
	{
		console.error('THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers');
	}; //


	ExtrudeGeometry.prototype.getArrays = function () {
		console.error('THREE.ExtrudeGeometry: .getArrays() has been removed.');
	};

	ExtrudeGeometry.prototype.addShapeList = function () {
		console.error('THREE.ExtrudeGeometry: .addShapeList() has been removed.');
	};

	ExtrudeGeometry.prototype.addShape = function () {
		console.error('THREE.ExtrudeGeometry: .addShape() has been removed.');
	}; //


	Scene.prototype.dispose = function () {
		console.error('THREE.Scene: .dispose() has been removed.');
	}; //


	Uniform.prototype.onUpdate = function () {
		console.warn('THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.');
		return this;
	}; //


	Object.defineProperties(Material.prototype, {
		wrapAround: {
			get: function get() {
				console.warn('THREE.Material: .wrapAround has been removed.');
			},
			set: function set() {
				console.warn('THREE.Material: .wrapAround has been removed.');
			}
		},
		overdraw: {
			get: function get() {
				console.warn('THREE.Material: .overdraw has been removed.');
			},
			set: function set() {
				console.warn('THREE.Material: .overdraw has been removed.');
			}
		},
		wrapRGB: {
			get: function get() {
				console.warn('THREE.Material: .wrapRGB has been removed.');
				return new Color();
			}
		},
		shading: {
			get: function get() {
				console.error('THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.');
			},
			set: function set(value) {
				console.warn('THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.');
				this.flatShading = value === FlatShading;
			}
		},
		stencilMask: {
			get: function get() {
				console.warn('THREE.' + this.type + ': .stencilMask has been removed. Use .stencilFuncMask instead.');
				return this.stencilFuncMask;
			},
			set: function set(value) {
				console.warn('THREE.' + this.type + ': .stencilMask has been removed. Use .stencilFuncMask instead.');
				this.stencilFuncMask = value;
			}
		},
		vertexTangents: {
			get: function get() {
				console.warn('THREE.' + this.type + ': .vertexTangents has been removed.');
			},
			set: function set() {
				console.warn('THREE.' + this.type + ': .vertexTangents has been removed.');
			}
		}
	});
	Object.defineProperties(ShaderMaterial.prototype, {
		derivatives: {
			get: function get() {
				console.warn('THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.');
				return this.extensions.derivatives;
			},
			set: function set(value) {
				console.warn('THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.');
				this.extensions.derivatives = value;
			}
		}
	}); //

	WebGLRenderer.prototype.clearTarget = function (renderTarget, color, depth, stencil) {
		console.warn('THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead.');
		this.setRenderTarget(renderTarget);
		this.clear(color, depth, stencil);
	};

	WebGLRenderer.prototype.animate = function (callback) {
		console.warn('THREE.WebGLRenderer: .animate() is now .setAnimationLoop().');
		this.setAnimationLoop(callback);
	};

	WebGLRenderer.prototype.getCurrentRenderTarget = function () {
		console.warn('THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget().');
		return this.getRenderTarget();
	};

	WebGLRenderer.prototype.getMaxAnisotropy = function () {
		console.warn('THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy().');
		return this.capabilities.getMaxAnisotropy();
	};

	WebGLRenderer.prototype.getPrecision = function () {
		console.warn('THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision.');
		return this.capabilities.precision;
	};

	WebGLRenderer.prototype.resetGLState = function () {
		console.warn('THREE.WebGLRenderer: .resetGLState() is now .state.reset().');
		return this.state.reset();
	};

	WebGLRenderer.prototype.supportsFloatTextures = function () {
		console.warn('THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \'OES_texture_float\' ).');
		return this.extensions.get('OES_texture_float');
	};

	WebGLRenderer.prototype.supportsHalfFloatTextures = function () {
		console.warn('THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \'OES_texture_half_float\' ).');
		return this.extensions.get('OES_texture_half_float');
	};

	WebGLRenderer.prototype.supportsStandardDerivatives = function () {
		console.warn('THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \'OES_standard_derivatives\' ).');
		return this.extensions.get('OES_standard_derivatives');
	};

	WebGLRenderer.prototype.supportsCompressedTextureS3TC = function () {
		console.warn('THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \'WEBGL_compressed_texture_s3tc\' ).');
		return this.extensions.get('WEBGL_compressed_texture_s3tc');
	};

	WebGLRenderer.prototype.supportsCompressedTexturePVRTC = function () {
		console.warn('THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \'WEBGL_compressed_texture_pvrtc\' ).');
		return this.extensions.get('WEBGL_compressed_texture_pvrtc');
	};

	WebGLRenderer.prototype.supportsBlendMinMax = function () {
		console.warn('THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \'EXT_blend_minmax\' ).');
		return this.extensions.get('EXT_blend_minmax');
	};

	WebGLRenderer.prototype.supportsVertexTextures = function () {
		console.warn('THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.');
		return this.capabilities.vertexTextures;
	};

	WebGLRenderer.prototype.supportsInstancedArrays = function () {
		console.warn('THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( \'ANGLE_instanced_arrays\' ).');
		return this.extensions.get('ANGLE_instanced_arrays');
	};

	WebGLRenderer.prototype.enableScissorTest = function (boolean) {
		console.warn('THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().');
		this.setScissorTest(boolean);
	};

	WebGLRenderer.prototype.initMaterial = function () {
		console.warn('THREE.WebGLRenderer: .initMaterial() has been removed.');
	};

	WebGLRenderer.prototype.addPrePlugin = function () {
		console.warn('THREE.WebGLRenderer: .addPrePlugin() has been removed.');
	};

	WebGLRenderer.prototype.addPostPlugin = function () {
		console.warn('THREE.WebGLRenderer: .addPostPlugin() has been removed.');
	};

	WebGLRenderer.prototype.updateShadowMap = function () {
		console.warn('THREE.WebGLRenderer: .updateShadowMap() has been removed.');
	};

	WebGLRenderer.prototype.setFaceCulling = function () {
		console.warn('THREE.WebGLRenderer: .setFaceCulling() has been removed.');
	};

	WebGLRenderer.prototype.allocTextureUnit = function () {
		console.warn('THREE.WebGLRenderer: .allocTextureUnit() has been removed.');
	};

	WebGLRenderer.prototype.setTexture = function () {
		console.warn('THREE.WebGLRenderer: .setTexture() has been removed.');
	};

	WebGLRenderer.prototype.setTexture2D = function () {
		console.warn('THREE.WebGLRenderer: .setTexture2D() has been removed.');
	};

	WebGLRenderer.prototype.setTextureCube = function () {
		console.warn('THREE.WebGLRenderer: .setTextureCube() has been removed.');
	};

	WebGLRenderer.prototype.getActiveMipMapLevel = function () {
		console.warn('THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel().');
		return this.getActiveMipmapLevel();
	};

	Object.defineProperties(WebGLRenderer.prototype, {
		shadowMapEnabled: {
			get: function get() {
				return this.shadowMap.enabled;
			},
			set: function set(value) {
				console.warn('THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.');
				this.shadowMap.enabled = value;
			}
		},
		shadowMapType: {
			get: function get() {
				return this.shadowMap.type;
			},
			set: function set(value) {
				console.warn('THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.');
				this.shadowMap.type = value;
			}
		},
		shadowMapCullFace: {
			get: function get() {
				console.warn('THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.');
				return undefined;
			},
			set: function set()
			/* value */
			{
				console.warn('THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.');
			}
		},
		context: {
			get: function get() {
				console.warn('THREE.WebGLRenderer: .context has been removed. Use .getContext() instead.');
				return this.getContext();
			}
		},
		vr: {
			get: function get() {
				console.warn('THREE.WebGLRenderer: .vr has been renamed to .xr');
				return this.xr;
			}
		},
		gammaInput: {
			get: function get() {
				console.warn('THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.');
				return false;
			},
			set: function set() {
				console.warn('THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.');
			}
		},
		gammaOutput: {
			get: function get() {
				console.warn('THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.');
				return false;
			},
			set: function set(value) {
				console.warn('THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.');
				this.outputEncoding = value === true ? sRGBEncoding : LinearEncoding;
			}
		},
		toneMappingWhitePoint: {
			get: function get() {
				console.warn('THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.');
				return 1.0;
			},
			set: function set() {
				console.warn('THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.');
			}
		}
	});
	Object.defineProperties(WebGLShadowMap.prototype, {
		cullFace: {
			get: function get() {
				console.warn('THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.');
				return undefined;
			},
			set: function set()
			/* cullFace */
			{
				console.warn('THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.');
			}
		},
		renderReverseSided: {
			get: function get() {
				console.warn('THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.');
				return undefined;
			},
			set: function set() {
				console.warn('THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.');
			}
		},
		renderSingleSided: {
			get: function get() {
				console.warn('THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.');
				return undefined;
			},
			set: function set() {
				console.warn('THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.');
			}
		}
	});
	function WebGLRenderTargetCube(width, height, options) {
		console.warn('THREE.WebGLRenderTargetCube( width, height, options ) is now WebGLCubeRenderTarget( size, options ).');
		return new WebGLCubeRenderTarget(width, options);
	} //

	Object.defineProperties(WebGLRenderTarget.prototype, {
		wrapS: {
			get: function get() {
				console.warn('THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.');
				return this.texture.wrapS;
			},
			set: function set(value) {
				console.warn('THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.');
				this.texture.wrapS = value;
			}
		},
		wrapT: {
			get: function get() {
				console.warn('THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.');
				return this.texture.wrapT;
			},
			set: function set(value) {
				console.warn('THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.');
				this.texture.wrapT = value;
			}
		},
		magFilter: {
			get: function get() {
				console.warn('THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.');
				return this.texture.magFilter;
			},
			set: function set(value) {
				console.warn('THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.');
				this.texture.magFilter = value;
			}
		},
		minFilter: {
			get: function get() {
				console.warn('THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.');
				return this.texture.minFilter;
			},
			set: function set(value) {
				console.warn('THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.');
				this.texture.minFilter = value;
			}
		},
		anisotropy: {
			get: function get() {
				console.warn('THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.');
				return this.texture.anisotropy;
			},
			set: function set(value) {
				console.warn('THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.');
				this.texture.anisotropy = value;
			}
		},
		offset: {
			get: function get() {
				console.warn('THREE.WebGLRenderTarget: .offset is now .texture.offset.');
				return this.texture.offset;
			},
			set: function set(value) {
				console.warn('THREE.WebGLRenderTarget: .offset is now .texture.offset.');
				this.texture.offset = value;
			}
		},
		repeat: {
			get: function get() {
				console.warn('THREE.WebGLRenderTarget: .repeat is now .texture.repeat.');
				return this.texture.repeat;
			},
			set: function set(value) {
				console.warn('THREE.WebGLRenderTarget: .repeat is now .texture.repeat.');
				this.texture.repeat = value;
			}
		},
		format: {
			get: function get() {
				console.warn('THREE.WebGLRenderTarget: .format is now .texture.format.');
				return this.texture.format;
			},
			set: function set(value) {
				console.warn('THREE.WebGLRenderTarget: .format is now .texture.format.');
				this.texture.format = value;
			}
		},
		type: {
			get: function get() {
				console.warn('THREE.WebGLRenderTarget: .type is now .texture.type.');
				return this.texture.type;
			},
			set: function set(value) {
				console.warn('THREE.WebGLRenderTarget: .type is now .texture.type.');
				this.texture.type = value;
			}
		},
		generateMipmaps: {
			get: function get() {
				console.warn('THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.');
				return this.texture.generateMipmaps;
			},
			set: function set(value) {
				console.warn('THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.');
				this.texture.generateMipmaps = value;
			}
		}
	}); //

	Audio.prototype.load = function (file) {
		console.warn('THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.');
		var scope = this;
		var audioLoader = new AudioLoader();
		audioLoader.load(file, function (buffer) {
			scope.setBuffer(buffer);
		});
		return this;
	};

	AudioAnalyser.prototype.getData = function () {
		console.warn('THREE.AudioAnalyser: .getData() is now .getFrequencyData().');
		return this.getFrequencyData();
	}; //


	CubeCamera.prototype.updateCubeMap = function (renderer, scene) {
		console.warn('THREE.CubeCamera: .updateCubeMap() is now .update().');
		return this.update(renderer, scene);
	};

	CubeCamera.prototype.clear = function (renderer, color, depth, stencil) {
		console.warn('THREE.CubeCamera: .clear() is now .renderTarget.clear().');
		return this.renderTarget.clear(renderer, color, depth, stencil);
	};

	ImageUtils.crossOrigin = undefined;

	ImageUtils.loadTexture = function (url, mapping, onLoad, onError) {
		console.warn('THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.');
		var loader = new TextureLoader();
		loader.setCrossOrigin(this.crossOrigin);
		var texture = loader.load(url, onLoad, undefined, onError);
		if (mapping) texture.mapping = mapping;
		return texture;
	};

	ImageUtils.loadTextureCube = function (urls, mapping, onLoad, onError) {
		console.warn('THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.');
		var loader = new CubeTextureLoader();
		loader.setCrossOrigin(this.crossOrigin);
		var texture = loader.load(urls, onLoad, undefined, onError);
		if (mapping) texture.mapping = mapping;
		return texture;
	};

	ImageUtils.loadCompressedTexture = function () {
		console.error('THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.');
	};

	ImageUtils.loadCompressedTextureCube = function () {
		console.error('THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.');
	}; //


	function CanvasRenderer() {
		console.error('THREE.CanvasRenderer has been removed');
	} //

	function JSONLoader() {
		console.error('THREE.JSONLoader has been removed.');
	} //

	var SceneUtils = {
		createMultiMaterialObject: function createMultiMaterialObject()
		/* geometry, materials */
		{
			console.error('THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js');
		},
		detach: function detach()
		/* child, parent, scene */
		{
			console.error('THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js');
		},
		attach: function attach()
		/* child, scene, parent */
		{
			console.error('THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js');
		}
	}; //

	function LensFlare() {
		console.error('THREE.LensFlare has been moved to /examples/jsm/objects/Lensflare.js');
	} //

	function ParametricGeometry() {
		console.error('THREE.ParametricGeometry has been moved to /examples/jsm/geometries/ParametricGeometry.js');
		return new BufferGeometry();
	}
	function TextGeometry() {
		console.error('THREE.TextGeometry has been moved to /examples/jsm/geometries/TextGeometry.js');
		return new BufferGeometry();
	}
	function FontLoader() {
		console.error('THREE.FontLoader has been moved to /examples/jsm/loaders/FontLoader.js');
	}
	function Font() {
		console.error('THREE.Font has been moved to /examples/jsm/loaders/FontLoader.js');
	}

	if (typeof __THREE_DEVTOOLS__ !== 'undefined') {
		/* eslint-disable no-undef */
		__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('register', {
			detail: {
				revision: REVISION
			}
		}));
		/* eslint-enable no-undef */

	}

	if (typeof window !== 'undefined') {
		if (window.__THREE__) {
			console.warn('WARNING: Multiple instances of Three.js being imported.');
		} else {
			window.__THREE__ = REVISION;
		}
	}

	exports.ACESFilmicToneMapping = ACESFilmicToneMapping;
	exports.AddEquation = AddEquation;
	exports.AddOperation = AddOperation;
	exports.AdditiveAnimationBlendMode = AdditiveAnimationBlendMode;
	exports.AdditiveBlending = AdditiveBlending;
	exports.AlphaFormat = AlphaFormat;
	exports.AlwaysDepth = AlwaysDepth;
	exports.AlwaysStencilFunc = AlwaysStencilFunc;
	exports.AmbientLight = AmbientLight;
	exports.AmbientLightProbe = AmbientLightProbe;
	exports.AnimationClip = AnimationClip;
	exports.AnimationLoader = AnimationLoader;
	exports.AnimationMixer = AnimationMixer;
	exports.AnimationObjectGroup = AnimationObjectGroup;
	exports.AnimationUtils = AnimationUtils;
	exports.ArcCurve = ArcCurve;
	exports.ArrayCamera = ArrayCamera;
	exports.ArrowHelper = ArrowHelper;
	exports.Audio = Audio;
	exports.AudioAnalyser = AudioAnalyser;
	exports.AudioContext = AudioContext;
	exports.AudioListener = AudioListener;
	exports.AudioLoader = AudioLoader;
	exports.AxesHelper = AxesHelper;
	exports.AxisHelper = AxisHelper;
	exports.BackSide = BackSide;
	exports.BasicDepthPacking = BasicDepthPacking;
	exports.BasicShadowMap = BasicShadowMap;
	exports.BinaryTextureLoader = BinaryTextureLoader;
	exports.Bone = Bone;
	exports.BooleanKeyframeTrack = BooleanKeyframeTrack;
	exports.BoundingBoxHelper = BoundingBoxHelper;
	exports.Box2 = Box2;
	exports.Box3 = Box3;
	exports.Box3Helper = Box3Helper;
	exports.BoxBufferGeometry = BoxGeometry;
	exports.BoxGeometry = BoxGeometry;
	exports.BoxHelper = BoxHelper;
	exports.BufferAttribute = BufferAttribute;
	exports.BufferGeometry = BufferGeometry;
	exports.BufferGeometryLoader = BufferGeometryLoader;
	exports.ByteType = ByteType;
	exports.Cache = Cache;
	exports.Camera = Camera;
	exports.CameraHelper = CameraHelper;
	exports.CanvasRenderer = CanvasRenderer;
	exports.CanvasTexture = CanvasTexture;
	exports.CatmullRomCurve3 = CatmullRomCurve3;
	exports.CineonToneMapping = CineonToneMapping;
	exports.CircleBufferGeometry = CircleGeometry;
	exports.CircleGeometry = CircleGeometry;
	exports.ClampToEdgeWrapping = ClampToEdgeWrapping;
	exports.Clock = Clock;
	exports.Color = Color;
	exports.ColorKeyframeTrack = ColorKeyframeTrack;
	exports.CompressedTexture = CompressedTexture;
	exports.CompressedTextureLoader = CompressedTextureLoader;
	exports.ConeBufferGeometry = ConeGeometry;
	exports.ConeGeometry = ConeGeometry;
	exports.CubeCamera = CubeCamera;
	exports.CubeReflectionMapping = CubeReflectionMapping;
	exports.CubeRefractionMapping = CubeRefractionMapping;
	exports.CubeTexture = CubeTexture;
	exports.CubeTextureLoader = CubeTextureLoader;
	exports.CubeUVReflectionMapping = CubeUVReflectionMapping;
	exports.CubeUVRefractionMapping = CubeUVRefractionMapping;
	exports.CubicBezierCurve = CubicBezierCurve;
	exports.CubicBezierCurve3 = CubicBezierCurve3;
	exports.CubicInterpolant = CubicInterpolant;
	exports.CullFaceBack = CullFaceBack;
	exports.CullFaceFront = CullFaceFront;
	exports.CullFaceFrontBack = CullFaceFrontBack;
	exports.CullFaceNone = CullFaceNone;
	exports.Curve = Curve;
	exports.CurvePath = CurvePath;
	exports.CustomBlending = CustomBlending;
	exports.CustomToneMapping = CustomToneMapping;
	exports.CylinderBufferGeometry = CylinderGeometry;
	exports.CylinderGeometry = CylinderGeometry;
	exports.Cylindrical = Cylindrical;
	exports.DataTexture = DataTexture;
	exports.DataTexture2DArray = DataTexture2DArray;
	exports.DataTexture3D = DataTexture3D;
	exports.DataTextureLoader = DataTextureLoader;
	exports.DataUtils = DataUtils;
	exports.DecrementStencilOp = DecrementStencilOp;
	exports.DecrementWrapStencilOp = DecrementWrapStencilOp;
	exports.DefaultLoadingManager = DefaultLoadingManager;
	exports.DepthFormat = DepthFormat;
	exports.DepthStencilFormat = DepthStencilFormat;
	exports.DepthTexture = DepthTexture;
	exports.DirectionalLight = DirectionalLight;
	exports.DirectionalLightHelper = DirectionalLightHelper;
	exports.DiscreteInterpolant = DiscreteInterpolant;
	exports.DodecahedronBufferGeometry = DodecahedronGeometry;
	exports.DodecahedronGeometry = DodecahedronGeometry;
	exports.DoubleSide = DoubleSide;
	exports.DstAlphaFactor = DstAlphaFactor;
	exports.DstColorFactor = DstColorFactor;
	exports.DynamicBufferAttribute = DynamicBufferAttribute;
	exports.DynamicCopyUsage = DynamicCopyUsage;
	exports.DynamicDrawUsage = DynamicDrawUsage;
	exports.DynamicReadUsage = DynamicReadUsage;
	exports.EdgesGeometry = EdgesGeometry;
	exports.EdgesHelper = EdgesHelper;
	exports.EllipseCurve = EllipseCurve;
	exports.EqualDepth = EqualDepth;
	exports.EqualStencilFunc = EqualStencilFunc;
	exports.EquirectangularReflectionMapping = EquirectangularReflectionMapping;
	exports.EquirectangularRefractionMapping = EquirectangularRefractionMapping;
	exports.Euler = Euler;
	exports.EventDispatcher = EventDispatcher;
	exports.ExtrudeBufferGeometry = ExtrudeGeometry;
	exports.ExtrudeGeometry = ExtrudeGeometry;
	exports.FaceColors = FaceColors;
	exports.FileLoader = FileLoader;
	exports.FlatShading = FlatShading;
	exports.Float16BufferAttribute = Float16BufferAttribute;
	exports.Float32Attribute = Float32Attribute;
	exports.Float32BufferAttribute = Float32BufferAttribute;
	exports.Float64Attribute = Float64Attribute;
	exports.Float64BufferAttribute = Float64BufferAttribute;
	exports.FloatType = FloatType;
	exports.Fog = Fog;
	exports.FogExp2 = FogExp2;
	exports.Font = Font;
	exports.FontLoader = FontLoader;
	exports.FrontSide = FrontSide;
	exports.Frustum = Frustum;
	exports.GLBufferAttribute = GLBufferAttribute;
	exports.GLSL1 = GLSL1;
	exports.GLSL3 = GLSL3;
	exports.GammaEncoding = GammaEncoding;
	exports.GreaterDepth = GreaterDepth;
	exports.GreaterEqualDepth = GreaterEqualDepth;
	exports.GreaterEqualStencilFunc = GreaterEqualStencilFunc;
	exports.GreaterStencilFunc = GreaterStencilFunc;
	exports.GridHelper = GridHelper;
	exports.Group = Group;
	exports.HalfFloatType = HalfFloatType;
	exports.HemisphereLight = HemisphereLight;
	exports.HemisphereLightHelper = HemisphereLightHelper;
	exports.HemisphereLightProbe = HemisphereLightProbe;
	exports.IcosahedronBufferGeometry = IcosahedronGeometry;
	exports.IcosahedronGeometry = IcosahedronGeometry;
	exports.ImageBitmapLoader = ImageBitmapLoader;
	exports.ImageLoader = ImageLoader;
	exports.ImageUtils = ImageUtils;
	exports.ImmediateRenderObject = ImmediateRenderObject;
	exports.IncrementStencilOp = IncrementStencilOp;
	exports.IncrementWrapStencilOp = IncrementWrapStencilOp;
	exports.InstancedBufferAttribute = InstancedBufferAttribute;
	exports.InstancedBufferGeometry = InstancedBufferGeometry;
	exports.InstancedInterleavedBuffer = InstancedInterleavedBuffer;
	exports.InstancedMesh = InstancedMesh;
	exports.Int16Attribute = Int16Attribute;
	exports.Int16BufferAttribute = Int16BufferAttribute;
	exports.Int32Attribute = Int32Attribute;
	exports.Int32BufferAttribute = Int32BufferAttribute;
	exports.Int8Attribute = Int8Attribute;
	exports.Int8BufferAttribute = Int8BufferAttribute;
	exports.IntType = IntType;
	exports.InterleavedBuffer = InterleavedBuffer;
	exports.InterleavedBufferAttribute = InterleavedBufferAttribute;
	exports.Interpolant = Interpolant;
	exports.InterpolateDiscrete = InterpolateDiscrete;
	exports.InterpolateLinear = InterpolateLinear;
	exports.InterpolateSmooth = InterpolateSmooth;
	exports.InvertStencilOp = InvertStencilOp;
	exports.JSONLoader = JSONLoader;
	exports.KeepStencilOp = KeepStencilOp;
	exports.KeyframeTrack = KeyframeTrack;
	exports.LOD = LOD;
	exports.LatheBufferGeometry = LatheGeometry;
	exports.LatheGeometry = LatheGeometry;
	exports.Layers = Layers;
	exports.LensFlare = LensFlare;
	exports.LessDepth = LessDepth;
	exports.LessEqualDepth = LessEqualDepth;
	exports.LessEqualStencilFunc = LessEqualStencilFunc;
	exports.LessStencilFunc = LessStencilFunc;
	exports.Light = Light;
	exports.LightProbe = LightProbe;
	exports.Line = Line;
	exports.Line3 = Line3;
	exports.LineBasicMaterial = LineBasicMaterial;
	exports.LineCurve = LineCurve;
	exports.LineCurve3 = LineCurve3;
	exports.LineDashedMaterial = LineDashedMaterial;
	exports.LineLoop = LineLoop;
	exports.LinePieces = LinePieces;
	exports.LineSegments = LineSegments;
	exports.LineStrip = LineStrip;
	exports.LinearEncoding = LinearEncoding;
	exports.LinearFilter = LinearFilter;
	exports.LinearInterpolant = LinearInterpolant;
	exports.LinearMipMapLinearFilter = LinearMipMapLinearFilter;
	exports.LinearMipMapNearestFilter = LinearMipMapNearestFilter;
	exports.LinearMipmapLinearFilter = LinearMipmapLinearFilter;
	exports.LinearMipmapNearestFilter = LinearMipmapNearestFilter;
	exports.LinearToneMapping = LinearToneMapping;
	exports.Loader = Loader;
	exports.LoaderUtils = LoaderUtils;
	exports.LoadingManager = LoadingManager;
	exports.LogLuvEncoding = LogLuvEncoding;
	exports.LoopOnce = LoopOnce;
	exports.LoopPingPong = LoopPingPong;
	exports.LoopRepeat = LoopRepeat;
	exports.LuminanceAlphaFormat = LuminanceAlphaFormat;
	exports.LuminanceFormat = LuminanceFormat;
	exports.MOUSE = MOUSE;
	exports.Material = Material;
	exports.MaterialLoader = MaterialLoader;
	exports.Math = MathUtils;
	exports.MathUtils = MathUtils;
	exports.Matrix3 = Matrix3;
	exports.Matrix4 = Matrix4;
	exports.MaxEquation = MaxEquation;
	exports.Mesh = Mesh;
	exports.MeshBasicMaterial = MeshBasicMaterial;
	exports.MeshDepthMaterial = MeshDepthMaterial;
	exports.MeshDistanceMaterial = MeshDistanceMaterial;
	exports.MeshFaceMaterial = MeshFaceMaterial;
	exports.MeshLambertMaterial = MeshLambertMaterial;
	exports.MeshMatcapMaterial = MeshMatcapMaterial;
	exports.MeshNormalMaterial = MeshNormalMaterial;
	exports.MeshPhongMaterial = MeshPhongMaterial;
	exports.MeshPhysicalMaterial = MeshPhysicalMaterial;
	exports.MeshStandardMaterial = MeshStandardMaterial;
	exports.MeshToonMaterial = MeshToonMaterial;
	exports.MinEquation = MinEquation;
	exports.MirroredRepeatWrapping = MirroredRepeatWrapping;
	exports.MixOperation = MixOperation;
	exports.MultiMaterial = MultiMaterial;
	exports.MultiplyBlending = MultiplyBlending;
	exports.MultiplyOperation = MultiplyOperation;
	exports.NearestFilter = NearestFilter;
	exports.NearestMipMapLinearFilter = NearestMipMapLinearFilter;
	exports.NearestMipMapNearestFilter = NearestMipMapNearestFilter;
	exports.NearestMipmapLinearFilter = NearestMipmapLinearFilter;
	exports.NearestMipmapNearestFilter = NearestMipmapNearestFilter;
	exports.NeverDepth = NeverDepth;
	exports.NeverStencilFunc = NeverStencilFunc;
	exports.NoBlending = NoBlending;
	exports.NoColors = NoColors;
	exports.NoToneMapping = NoToneMapping;
	exports.NormalAnimationBlendMode = NormalAnimationBlendMode;
	exports.NormalBlending = NormalBlending;
	exports.NotEqualDepth = NotEqualDepth;
	exports.NotEqualStencilFunc = NotEqualStencilFunc;
	exports.NumberKeyframeTrack = NumberKeyframeTrack;
	exports.Object3D = Object3D;
	exports.ObjectLoader = ObjectLoader;
	exports.ObjectSpaceNormalMap = ObjectSpaceNormalMap;
	exports.OctahedronBufferGeometry = OctahedronGeometry;
	exports.OctahedronGeometry = OctahedronGeometry;
	exports.OneFactor = OneFactor;
	exports.OneMinusDstAlphaFactor = OneMinusDstAlphaFactor;
	exports.OneMinusDstColorFactor = OneMinusDstColorFactor;
	exports.OneMinusSrcAlphaFactor = OneMinusSrcAlphaFactor;
	exports.OneMinusSrcColorFactor = OneMinusSrcColorFactor;
	exports.OrthographicCamera = OrthographicCamera;
	exports.PCFShadowMap = PCFShadowMap;
	exports.PCFSoftShadowMap = PCFSoftShadowMap;
	exports.PMREMGenerator = PMREMGenerator;
	exports.ParametricGeometry = ParametricGeometry;
	exports.Particle = Particle;
	exports.ParticleBasicMaterial = ParticleBasicMaterial;
	exports.ParticleSystem = ParticleSystem;
	exports.ParticleSystemMaterial = ParticleSystemMaterial;
	exports.Path = Path;
	exports.PerspectiveCamera = PerspectiveCamera;
	exports.Plane = Plane;
	exports.PlaneBufferGeometry = PlaneGeometry;
	exports.PlaneGeometry = PlaneGeometry;
	exports.PlaneHelper = PlaneHelper;
	exports.PointCloud = PointCloud;
	exports.PointCloudMaterial = PointCloudMaterial;
	exports.PointLight = PointLight;
	exports.PointLightHelper = PointLightHelper;
	exports.Points = Points;
	exports.PointsMaterial = PointsMaterial;
	exports.PolarGridHelper = PolarGridHelper;
	exports.PolyhedronBufferGeometry = PolyhedronGeometry;
	exports.PolyhedronGeometry = PolyhedronGeometry;
	exports.PositionalAudio = PositionalAudio;
	exports.PropertyBinding = PropertyBinding;
	exports.PropertyMixer = PropertyMixer;
	exports.QuadraticBezierCurve = QuadraticBezierCurve;
	exports.QuadraticBezierCurve3 = QuadraticBezierCurve3;
	exports.Quaternion = Quaternion;
	exports.QuaternionKeyframeTrack = QuaternionKeyframeTrack;
	exports.QuaternionLinearInterpolant = QuaternionLinearInterpolant;
	exports.REVISION = REVISION;
	exports.RGBADepthPacking = RGBADepthPacking;
	exports.RGBAFormat = RGBAFormat;
	exports.RGBAIntegerFormat = RGBAIntegerFormat;
	exports.RGBA_ASTC_10x10_Format = RGBA_ASTC_10x10_Format;
	exports.RGBA_ASTC_10x5_Format = RGBA_ASTC_10x5_Format;
	exports.RGBA_ASTC_10x6_Format = RGBA_ASTC_10x6_Format;
	exports.RGBA_ASTC_10x8_Format = RGBA_ASTC_10x8_Format;
	exports.RGBA_ASTC_12x10_Format = RGBA_ASTC_12x10_Format;
	exports.RGBA_ASTC_12x12_Format = RGBA_ASTC_12x12_Format;
	exports.RGBA_ASTC_4x4_Format = RGBA_ASTC_4x4_Format;
	exports.RGBA_ASTC_5x4_Format = RGBA_ASTC_5x4_Format;
	exports.RGBA_ASTC_5x5_Format = RGBA_ASTC_5x5_Format;
	exports.RGBA_ASTC_6x5_Format = RGBA_ASTC_6x5_Format;
	exports.RGBA_ASTC_6x6_Format = RGBA_ASTC_6x6_Format;
	exports.RGBA_ASTC_8x5_Format = RGBA_ASTC_8x5_Format;
	exports.RGBA_ASTC_8x6_Format = RGBA_ASTC_8x6_Format;
	exports.RGBA_ASTC_8x8_Format = RGBA_ASTC_8x8_Format;
	exports.RGBA_BPTC_Format = RGBA_BPTC_Format;
	exports.RGBA_ETC2_EAC_Format = RGBA_ETC2_EAC_Format;
	exports.RGBA_PVRTC_2BPPV1_Format = RGBA_PVRTC_2BPPV1_Format;
	exports.RGBA_PVRTC_4BPPV1_Format = RGBA_PVRTC_4BPPV1_Format;
	exports.RGBA_S3TC_DXT1_Format = RGBA_S3TC_DXT1_Format;
	exports.RGBA_S3TC_DXT3_Format = RGBA_S3TC_DXT3_Format;
	exports.RGBA_S3TC_DXT5_Format = RGBA_S3TC_DXT5_Format;
	exports.RGBDEncoding = RGBDEncoding;
	exports.RGBEEncoding = RGBEEncoding;
	exports.RGBEFormat = RGBEFormat;
	exports.RGBFormat = RGBFormat;
	exports.RGBIntegerFormat = RGBIntegerFormat;
	exports.RGBM16Encoding = RGBM16Encoding;
	exports.RGBM7Encoding = RGBM7Encoding;
	exports.RGB_ETC1_Format = RGB_ETC1_Format;
	exports.RGB_ETC2_Format = RGB_ETC2_Format;
	exports.RGB_PVRTC_2BPPV1_Format = RGB_PVRTC_2BPPV1_Format;
	exports.RGB_PVRTC_4BPPV1_Format = RGB_PVRTC_4BPPV1_Format;
	exports.RGB_S3TC_DXT1_Format = RGB_S3TC_DXT1_Format;
	exports.RGFormat = RGFormat;
	exports.RGIntegerFormat = RGIntegerFormat;
	exports.RawShaderMaterial = RawShaderMaterial;
	exports.Ray = Ray;
	exports.Raycaster = Raycaster;
	exports.RectAreaLight = RectAreaLight;
	exports.RedFormat = RedFormat;
	exports.RedIntegerFormat = RedIntegerFormat;
	exports.ReinhardToneMapping = ReinhardToneMapping;
	exports.RepeatWrapping = RepeatWrapping;
	exports.ReplaceStencilOp = ReplaceStencilOp;
	exports.ReverseSubtractEquation = ReverseSubtractEquation;
	exports.RingBufferGeometry = RingGeometry;
	exports.RingGeometry = RingGeometry;
	exports.SRGB8_ALPHA8_ASTC_10x10_Format = SRGB8_ALPHA8_ASTC_10x10_Format;
	exports.SRGB8_ALPHA8_ASTC_10x5_Format = SRGB8_ALPHA8_ASTC_10x5_Format;
	exports.SRGB8_ALPHA8_ASTC_10x6_Format = SRGB8_ALPHA8_ASTC_10x6_Format;
	exports.SRGB8_ALPHA8_ASTC_10x8_Format = SRGB8_ALPHA8_ASTC_10x8_Format;
	exports.SRGB8_ALPHA8_ASTC_12x10_Format = SRGB8_ALPHA8_ASTC_12x10_Format;
	exports.SRGB8_ALPHA8_ASTC_12x12_Format = SRGB8_ALPHA8_ASTC_12x12_Format;
	exports.SRGB8_ALPHA8_ASTC_4x4_Format = SRGB8_ALPHA8_ASTC_4x4_Format;
	exports.SRGB8_ALPHA8_ASTC_5x4_Format = SRGB8_ALPHA8_ASTC_5x4_Format;
	exports.SRGB8_ALPHA8_ASTC_5x5_Format = SRGB8_ALPHA8_ASTC_5x5_Format;
	exports.SRGB8_ALPHA8_ASTC_6x5_Format = SRGB8_ALPHA8_ASTC_6x5_Format;
	exports.SRGB8_ALPHA8_ASTC_6x6_Format = SRGB8_ALPHA8_ASTC_6x6_Format;
	exports.SRGB8_ALPHA8_ASTC_8x5_Format = SRGB8_ALPHA8_ASTC_8x5_Format;
	exports.SRGB8_ALPHA8_ASTC_8x6_Format = SRGB8_ALPHA8_ASTC_8x6_Format;
	exports.SRGB8_ALPHA8_ASTC_8x8_Format = SRGB8_ALPHA8_ASTC_8x8_Format;
	exports.Scene = Scene;
	exports.SceneUtils = SceneUtils;
	exports.ShaderChunk = ShaderChunk;
	exports.ShaderLib = ShaderLib;
	exports.ShaderMaterial = ShaderMaterial;
	exports.ShadowMaterial = ShadowMaterial;
	exports.Shape = Shape;
	exports.ShapeBufferGeometry = ShapeGeometry;
	exports.ShapeGeometry = ShapeGeometry;
	exports.ShapePath = ShapePath;
	exports.ShapeUtils = ShapeUtils;
	exports.ShortType = ShortType;
	exports.Skeleton = Skeleton;
	exports.SkeletonHelper = SkeletonHelper;
	exports.SkinnedMesh = SkinnedMesh;
	exports.SmoothShading = SmoothShading;
	exports.Sphere = Sphere;
	exports.SphereBufferGeometry = SphereGeometry;
	exports.SphereGeometry = SphereGeometry;
	exports.Spherical = Spherical;
	exports.SphericalHarmonics3 = SphericalHarmonics3;
	exports.SplineCurve = SplineCurve;
	exports.SpotLight = SpotLight;
	exports.SpotLightHelper = SpotLightHelper;
	exports.Sprite = Sprite;
	exports.SpriteMaterial = SpriteMaterial;
	exports.SrcAlphaFactor = SrcAlphaFactor;
	exports.SrcAlphaSaturateFactor = SrcAlphaSaturateFactor;
	exports.SrcColorFactor = SrcColorFactor;
	exports.StaticCopyUsage = StaticCopyUsage;
	exports.StaticDrawUsage = StaticDrawUsage;
	exports.StaticReadUsage = StaticReadUsage;
	exports.StereoCamera = StereoCamera;
	exports.StreamCopyUsage = StreamCopyUsage;
	exports.StreamDrawUsage = StreamDrawUsage;
	exports.StreamReadUsage = StreamReadUsage;
	exports.StringKeyframeTrack = StringKeyframeTrack;
	exports.SubtractEquation = SubtractEquation;
	exports.SubtractiveBlending = SubtractiveBlending;
	exports.TOUCH = TOUCH;
	exports.TangentSpaceNormalMap = TangentSpaceNormalMap;
	exports.TetrahedronBufferGeometry = TetrahedronGeometry;
	exports.TetrahedronGeometry = TetrahedronGeometry;
	exports.TextGeometry = TextGeometry;
	exports.Texture = Texture;
	exports.TextureLoader = TextureLoader;
	exports.TorusBufferGeometry = TorusGeometry;
	exports.TorusGeometry = TorusGeometry;
	exports.TorusKnotBufferGeometry = TorusKnotGeometry;
	exports.TorusKnotGeometry = TorusKnotGeometry;
	exports.Triangle = Triangle;
	exports.TriangleFanDrawMode = TriangleFanDrawMode;
	exports.TriangleStripDrawMode = TriangleStripDrawMode;
	exports.TrianglesDrawMode = TrianglesDrawMode;
	exports.TubeBufferGeometry = TubeGeometry;
	exports.TubeGeometry = TubeGeometry;
	exports.UVMapping = UVMapping;
	exports.Uint16Attribute = Uint16Attribute;
	exports.Uint16BufferAttribute = Uint16BufferAttribute;
	exports.Uint32Attribute = Uint32Attribute;
	exports.Uint32BufferAttribute = Uint32BufferAttribute;
	exports.Uint8Attribute = Uint8Attribute;
	exports.Uint8BufferAttribute = Uint8BufferAttribute;
	exports.Uint8ClampedAttribute = Uint8ClampedAttribute;
	exports.Uint8ClampedBufferAttribute = Uint8ClampedBufferAttribute;
	exports.Uniform = Uniform;
	exports.UniformsLib = UniformsLib;
	exports.UniformsUtils = UniformsUtils;
	exports.UnsignedByteType = UnsignedByteType;
	exports.UnsignedInt248Type = UnsignedInt248Type;
	exports.UnsignedIntType = UnsignedIntType;
	exports.UnsignedShort4444Type = UnsignedShort4444Type;
	exports.UnsignedShort5551Type = UnsignedShort5551Type;
	exports.UnsignedShort565Type = UnsignedShort565Type;
	exports.UnsignedShortType = UnsignedShortType;
	exports.VSMShadowMap = VSMShadowMap;
	exports.Vector2 = Vector2;
	exports.Vector3 = Vector3;
	exports.Vector4 = Vector4;
	exports.VectorKeyframeTrack = VectorKeyframeTrack;
	exports.Vertex = Vertex;
	exports.VertexColors = VertexColors;
	exports.VideoTexture = VideoTexture;
	exports.WebGL1Renderer = WebGL1Renderer;
	exports.WebGLCubeRenderTarget = WebGLCubeRenderTarget;
	exports.WebGLMultipleRenderTargets = WebGLMultipleRenderTargets;
	exports.WebGLMultisampleRenderTarget = WebGLMultisampleRenderTarget;
	exports.WebGLRenderTarget = WebGLRenderTarget;
	exports.WebGLRenderTargetCube = WebGLRenderTargetCube;
	exports.WebGLRenderer = WebGLRenderer;
	exports.WebGLUtils = WebGLUtils;
	exports.WireframeGeometry = WireframeGeometry;
	exports.WireframeHelper = WireframeHelper;
	exports.WrapAroundEnding = WrapAroundEnding;
	exports.XHRLoader = XHRLoader;
	exports.ZeroCurvatureEnding = ZeroCurvatureEnding;
	exports.ZeroFactor = ZeroFactor;
	exports.ZeroSlopeEnding = ZeroSlopeEnding;
	exports.ZeroStencilOp = ZeroStencilOp;
	exports.sRGBEncoding = sRGBEncoding;

	Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGhyZWUuanMiLCJzb3VyY2VzIjpbXSwic291cmNlc0NvbnRlbnQiOltdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiIn0=
